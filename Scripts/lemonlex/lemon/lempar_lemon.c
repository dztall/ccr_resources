/*
** This file contains all sources (including headers) to the LEMON
** LALR(1) parser generator.  The sources have been combined into a
** single file to make it easy to include LEMON in the source tree
** and Makefile of another program.
**
** The author of this program disclaims copyright.
*/
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <assert.h>

#ifndef __WIN32__
#   if defined(_WIN32) || defined(WIN32)
#       define __WIN32__
#   endif
#endif

#define LEMONEX 1

#ifdef __WIN32__
#ifdef __cplusplus
extern "C" {
#endif
extern int access(const char *path, int mode);
#ifdef __cplusplus
}
#endif
#else /* __WIN32__ */
#include <unistd.h>
#ifdef LEMONEX
#include <sys/stat.h>
#endif
#endif

#ifdef LEMONEX
#include <errno.h>
#endif

/* #define PRIVATE static */
#define PRIVATE

#ifdef LEMONEX
#ifndef LEMONEX_DBG
#define LEMONEX_DBG 0
#endif
#endif

#ifdef TEST
#define MAXRHS 5       /* Set low to exercise exception code */
#else
#define MAXRHS 1000
#endif

static int showPrecedenceConflict = 0;
static char *msort(char*,char**,int(*)(const char*,const char*));

/*
** Compilers are getting increasingly pedantic about type conversions
** as C evolves ever closer to Ada....  To work around the latest problems
** we have to define the following variant of strlen().
*/
#define lemonStrlen(X)   ((int)strlen(X))

/*
** Compilers are starting to complain about the use of sprintf() and strcpy(),
** saying they are unsafe.  So we define our own versions of those routines too.
**
** There are three routines here:  lemon_sprintf(), lemon_vsprintf(), and
** lemon_addtext(). The first two are replacements for sprintf() and vsprintf().
** The third is a helper routine for vsnprintf() that adds texts to the end of a
** buffer, making sure the buffer is always zero-terminated.
**
** The string formatter is a minimal subset of stdlib sprintf() supporting only
** a few simply conversions:
**
**   %d
**   %s
**   %.*s
**
*/
static void lemon_addtext(
  char *zBuf,           /* The buffer to which text is added */
  int *pnUsed,          /* Slots of the buffer used so far */
  const char *zIn,      /* Text to add */
  int nIn,              /* Bytes of text to add.  -1 to use strlen() */
  int iWidth            /* Field width.  Negative to left justify */
){
  if( nIn<0 ) for(nIn=0; zIn[nIn]; nIn++){}
  while( iWidth>nIn ){ zBuf[(*pnUsed)++] = ' '; iWidth--; }
  if( nIn==0 ) return;
  memcpy(&zBuf[*pnUsed], zIn, nIn);
  *pnUsed += nIn;
  while( (-iWidth)>nIn ){ zBuf[(*pnUsed)++] = ' '; iWidth++; }
  zBuf[*pnUsed] = 0;
}
static int lemon_vsprintf(char *str, const char *zFormat, va_list ap){
  int i, j, k, c;
  int nUsed = 0;
  const char *z;
  char zTemp[50];
  str[0] = 0;
  for(i=j=0; (c = zFormat[i])!=0; i++){
    if( c=='%' ){
      int iWidth = 0;
      lemon_addtext(str, &nUsed, &zFormat[j], i-j, 0);
      c = zFormat[++i];
      if( isdigit(c) || (c=='-' && isdigit(zFormat[i+1])) ){
        if( c=='-' ) i++;
        while( isdigit(zFormat[i]) ) iWidth = iWidth*10 + zFormat[i++] - '0';
        if( c=='-' ) iWidth = -iWidth;
        c = zFormat[i];
      }
      if( c=='d' ){
        int v = va_arg(ap, int);
        if( v<0 ){
          lemon_addtext(str, &nUsed, "-", 1, iWidth);
          v = -v;
        }else if( v==0 ){
          lemon_addtext(str, &nUsed, "0", 1, iWidth);
        }
        k = 0;
        while( v>0 ){
          k++;
          zTemp[sizeof(zTemp)-k] = (v%10) + '0';
          v /= 10;
        }
        lemon_addtext(str, &nUsed, &zTemp[sizeof(zTemp)-k], k, iWidth);
      }else if( c=='s' ){
        z = va_arg(ap, const char*);
        lemon_addtext(str, &nUsed, z, -1, iWidth);
      }else if( c=='.' && memcmp(&zFormat[i], ".*s", 3)==0 ){
        i += 2;
        k = va_arg(ap, int);
        z = va_arg(ap, const char*);
        lemon_addtext(str, &nUsed, z, k, iWidth);
      }else if( c=='%' ){
        lemon_addtext(str, &nUsed, "%", 1, 0);
      }else{
        fprintf(stderr, "illegal format\n");
        exit(1);
      }
      j = i+1;
    }
  }
  lemon_addtext(str, &nUsed, &zFormat[j], i-j, 0);
  return nUsed;
}
static int lemon_sprintf(char *str, const char *format, ...){
  va_list ap;
  int rc;
  va_start(ap, format);
  rc = lemon_vsprintf(str, format, ap);
  va_end(ap);
  return rc;
}
static void lemon_strcpy(char *dest, const char *src){
  while( (*(dest++) = *(src++))!=0 ){}
}
static void lemon_strcat(char *dest, const char *src){
  while( *dest ) dest++;
  lemon_strcpy(dest, src);
}


/* a few forward declarations... */
struct rule;
struct lemon;
struct action;

static struct action *Action_new(void);
static struct action *Action_sort(struct action *);

/********** From the file "build.h" ************************************/
void FindRulePrecedences();
void FindFirstSets();
void FindStates();
void FindLinks();
void FindFollowSets();
void FindActions();

/********* From the file "configlist.h" *********************************/
void Configlist_init(void);
struct config *Configlist_add(struct rule *, int);
struct config *Configlist_addbasis(struct rule *, int);
void Configlist_closure(struct lemon *);
void Configlist_sort(void);
void Configlist_sortbasis(void);
struct config *Configlist_return(void);
struct config *Configlist_basis(void);
void Configlist_eat(struct config *);
void Configlist_reset(void);

/********* From the file "error.h" ***************************************/
void ErrorMsg(const char *, int,const char *, ...);

/****** From the file "option.h" ******************************************/
enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,
         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR};
struct s_options {
  enum option_type type;
  const char *label;
  char *arg;
  const char *message;
};
int    OptInit(char**,struct s_options*,FILE*);
int    OptNArgs(void);
char  *OptArg(int);
void   OptErr(int);
void   OptPrint(void);

/******** From the file "parse.h" *****************************************/
void Parse(struct lemon *lemp);

/********* From the file "plink.h" ***************************************/
struct plink *Plink_new(void);
void Plink_add(struct plink **, struct config *);
void Plink_copy(struct plink **, struct plink *);
void Plink_delete(struct plink *);

/********** From the file "report.h" *************************************/
void Reprint(struct lemon *);
void ReportOutput(struct lemon *);
void ReportTable(struct lemon *, int);
void ReportHeader(struct lemon *);
void CompressTables(struct lemon *);
void ResortStates(struct lemon *);

/********** From the file "set.h" ****************************************/
void  SetSize(int);             /* All sets will be of size N */
char *SetNew(void);               /* A new set for element 0..N */
void  SetFree(char*);             /* Deallocate a set */
int SetAdd(char*,int);            /* Add element to a set */
int SetUnion(char *,char *);    /* A <- A U B, thru element N */
#define SetFind(X,Y) (X[Y])       /* True if Y is in set X */

/********** From the file "struct.h" *************************************/
/*
** Principal data structures for the LEMON parser generator.
*/

typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;

/* Symbols (terminals and nonterminals) of the grammar are stored
** in the following: */
enum symbol_type {
  TERMINAL,
  NONTERMINAL,
  MULTITERMINAL
};
enum e_assoc {
    LEFT,
    RIGHT,
    NONE,
    UNK
};
struct symbol {
  const char *name;        /* Name of the symbol */
  int index;               /* Index number for this symbol */
  enum symbol_type type;   /* Symbols are all either TERMINALS or NTs */
  struct rule *rule;       /* Linked list of rules of this (if an NT) */
  struct symbol *fallback; /* fallback token in case this token doesn't parse */
  int prec;                /* Precedence if defined (-1 otherwise) */
  enum e_assoc assoc;      /* Associativity if precedence is defined */
  char *firstset;          /* First-set for all rules of this symbol */
  Boolean lambda;          /* True if NT and can generate an empty string */
  int useCnt;              /* Number of times used */
  char *destructor;        /* Code which executes whenever this symbol is
                           ** popped from the stack during error processing */
  int destLineno;          /* Line number for start of destructor */
  char *datatype;          /* The data type of information held by this
                           ** object. Only used if type==NONTERMINAL */
  int dtnum;               /* The data type number.  In the parser, the value
                           ** stack is a union.  The .yy%d element of this
                           ** union is the correct data type for this object */
  /* The following fields are used by MULTITERMINALs only */
  int nsubsym;             /* Number of constituent symbols in the MULTI */
  struct symbol **subsym;  /* Array of constituent symbols */
#ifdef LEMONEX
  int defined;             /* true if this symbol has been defined in lexer */
#endif
};

#ifdef LEMONEX
static int s_lxclasslist[] =
{
  /* begin code generated by cvt.py */
  0, 'l',
  0x0061, 0x007A, /* LATIN SMALL LETTER A */  0x00B5, 0x00B5, /* MICRO SIGN */
  0x00DF, 0x00F6, /* LATIN SMALL LETTER SHARP S */
  0x00F8, 0x00FF, /* LATIN SMALL LETTER O WITH STROKE */
  0x0101, 0x0101, /* LATIN SMALL LETTER A WITH MACRON */
  0x0103, 0x0103, /* LATIN SMALL LETTER A WITH BREVE */
  0x0105, 0x0105, /* LATIN SMALL LETTER A WITH OGONEK */
  0x0107, 0x0107, /* LATIN SMALL LETTER C WITH ACUTE */
  0x0109, 0x0109, /* LATIN SMALL LETTER C WITH CIRCUMFLEX */
  0x010B, 0x010B, /* LATIN SMALL LETTER C WITH DOT ABOVE */
  0x010D, 0x010D, /* LATIN SMALL LETTER C WITH CARON */
  0x010F, 0x010F, /* LATIN SMALL LETTER D WITH CARON */
  0x0111, 0x0111, /* LATIN SMALL LETTER D WITH STROKE */
  0x0113, 0x0113, /* LATIN SMALL LETTER E WITH MACRON */
  0x0115, 0x0115, /* LATIN SMALL LETTER E WITH BREVE */
  0x0117, 0x0117, /* LATIN SMALL LETTER E WITH DOT ABOVE */
  0x0119, 0x0119, /* LATIN SMALL LETTER E WITH OGONEK */
  0x011B, 0x011B, /* LATIN SMALL LETTER E WITH CARON */
  0x011D, 0x011D, /* LATIN SMALL LETTER G WITH CIRCUMFLEX */
  0x011F, 0x011F, /* LATIN SMALL LETTER G WITH BREVE */
  0x0121, 0x0121, /* LATIN SMALL LETTER G WITH DOT ABOVE */
  0x0123, 0x0123, /* LATIN SMALL LETTER G WITH CEDILLA */
  0x0125, 0x0125, /* LATIN SMALL LETTER H WITH CIRCUMFLEX */
  0x0127, 0x0127, /* LATIN SMALL LETTER H WITH STROKE */
  0x0129, 0x0129, /* LATIN SMALL LETTER I WITH TILDE */
  0x012B, 0x012B, /* LATIN SMALL LETTER I WITH MACRON */
  0x012D, 0x012D, /* LATIN SMALL LETTER I WITH BREVE */
  0x012F, 0x012F, /* LATIN SMALL LETTER I WITH OGONEK */
  0x0131, 0x0131, /* LATIN SMALL LETTER DOTLESS I */
  0x0133, 0x0133, /* LATIN SMALL LIGATURE IJ */
  0x0135, 0x0135, /* LATIN SMALL LETTER J WITH CIRCUMFLEX */
  0x0137, 0x0138, /* LATIN SMALL LETTER K WITH CEDILLA */
  0x013A, 0x013A, /* LATIN SMALL LETTER L WITH ACUTE */
  0x013C, 0x013C, /* LATIN SMALL LETTER L WITH CEDILLA */
  0x013E, 0x013E, /* LATIN SMALL LETTER L WITH CARON */
  0x0140, 0x0140, /* LATIN SMALL LETTER L WITH MIDDLE DOT */
  0x0142, 0x0142, /* LATIN SMALL LETTER L WITH STROKE */
  0x0144, 0x0144, /* LATIN SMALL LETTER N WITH ACUTE */
  0x0146, 0x0146, /* LATIN SMALL LETTER N WITH CEDILLA */
  0x0148, 0x0149, /* LATIN SMALL LETTER N WITH CARON */
  0x014B, 0x014B, /* LATIN SMALL LETTER ENG */
  0x014D, 0x014D, /* LATIN SMALL LETTER O WITH MACRON */
  0x014F, 0x014F, /* LATIN SMALL LETTER O WITH BREVE */
  0x0151, 0x0151, /* LATIN SMALL LETTER O WITH DOUBLE ACUTE */
  0x0153, 0x0153, /* LATIN SMALL LIGATURE OE */
  0x0155, 0x0155, /* LATIN SMALL LETTER R WITH ACUTE */
  0x0157, 0x0157, /* LATIN SMALL LETTER R WITH CEDILLA */
  0x0159, 0x0159, /* LATIN SMALL LETTER R WITH CARON */
  0x015B, 0x015B, /* LATIN SMALL LETTER S WITH ACUTE */
  0x015D, 0x015D, /* LATIN SMALL LETTER S WITH CIRCUMFLEX */
  0x015F, 0x015F, /* LATIN SMALL LETTER S WITH CEDILLA */
  0x0161, 0x0161, /* LATIN SMALL LETTER S WITH CARON */
  0x0163, 0x0163, /* LATIN SMALL LETTER T WITH CEDILLA */
  0x0165, 0x0165, /* LATIN SMALL LETTER T WITH CARON */
  0x0167, 0x0167, /* LATIN SMALL LETTER T WITH STROKE */
  0x0169, 0x0169, /* LATIN SMALL LETTER U WITH TILDE */
  0x016B, 0x016B, /* LATIN SMALL LETTER U WITH MACRON */
  0x016D, 0x016D, /* LATIN SMALL LETTER U WITH BREVE */
  0x016F, 0x016F, /* LATIN SMALL LETTER U WITH RING ABOVE */
  0x0171, 0x0171, /* LATIN SMALL LETTER U WITH DOUBLE ACUTE */
  0x0173, 0x0173, /* LATIN SMALL LETTER U WITH OGONEK */
  0x0175, 0x0175, /* LATIN SMALL LETTER W WITH CIRCUMFLEX */
  0x0177, 0x0177, /* LATIN SMALL LETTER Y WITH CIRCUMFLEX */
  0x017A, 0x017A, /* LATIN SMALL LETTER Z WITH ACUTE */
  0x017C, 0x017C, /* LATIN SMALL LETTER Z WITH DOT ABOVE */
  0x017E, 0x0180, /* LATIN SMALL LETTER Z WITH CARON */
  0x0183, 0x0183, /* LATIN SMALL LETTER B WITH TOPBAR */
  0x0185, 0x0185, /* LATIN SMALL LETTER TONE SIX */
  0x0188, 0x0188, /* LATIN SMALL LETTER C WITH HOOK */
  0x018C, 0x018D, /* LATIN SMALL LETTER D WITH TOPBAR */
  0x0192, 0x0192, /* LATIN SMALL LETTER F WITH HOOK */
  0x0195, 0x0195, /* LATIN SMALL LETTER HV */
  0x0199, 0x019B, /* LATIN SMALL LETTER K WITH HOOK */
  0x019E, 0x019E, /* LATIN SMALL LETTER N WITH LONG RIGHT LEG */
  0x01A1, 0x01A1, /* LATIN SMALL LETTER O WITH HORN */
  0x01A3, 0x01A3, /* LATIN SMALL LETTER OI */
  0x01A5, 0x01A5, /* LATIN SMALL LETTER P WITH HOOK */
  0x01A8, 0x01A8, /* LATIN SMALL LETTER TONE TWO */
  0x01AA, 0x01AB, /* LATIN LETTER REVERSED ESH LOOP */
  0x01AD, 0x01AD, /* LATIN SMALL LETTER T WITH HOOK */
  0x01B0, 0x01B0, /* LATIN SMALL LETTER U WITH HORN */
  0x01B4, 0x01B4, /* LATIN SMALL LETTER Y WITH HOOK */
  0x01B6, 0x01B6, /* LATIN SMALL LETTER Z WITH STROKE */
  0x01B9, 0x01BA, /* LATIN SMALL LETTER EZH REVERSED */
  0x01BD, 0x01BF, /* LATIN SMALL LETTER TONE FIVE */
  0x01C6, 0x01C6, /* LATIN SMALL LETTER DZ WITH CARON */
  0x01C9, 0x01C9, /* LATIN SMALL LETTER LJ */
  0x01CC, 0x01CC, /* LATIN SMALL LETTER NJ */
  0x01CE, 0x01CE, /* LATIN SMALL LETTER A WITH CARON */
  0x01D0, 0x01D0, /* LATIN SMALL LETTER I WITH CARON */
  0x01D2, 0x01D2, /* LATIN SMALL LETTER O WITH CARON */
  0x01D4, 0x01D4, /* LATIN SMALL LETTER U WITH CARON */
  0x01D6, 0x01D6, /* LATIN SMALL LETTER U WITH DIAERESIS AND MACRON */
  0x01D8, 0x01D8, /* LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE */
  0x01DA, 0x01DA, /* LATIN SMALL LETTER U WITH DIAERESIS AND CARON */
  0x01DC, 0x01DD, /* LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE */
  0x01DF, 0x01DF, /* LATIN SMALL LETTER A WITH DIAERESIS AND MACRON */
  0x01E1, 0x01E1, /* LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON */
  0x01E3, 0x01E3, /* LATIN SMALL LETTER AE WITH MACRON */
  0x01E5, 0x01E5, /* LATIN SMALL LETTER G WITH STROKE */
  0x01E7, 0x01E7, /* LATIN SMALL LETTER G WITH CARON */
  0x01E9, 0x01E9, /* LATIN SMALL LETTER K WITH CARON */
  0x01EB, 0x01EB, /* LATIN SMALL LETTER O WITH OGONEK */
  0x01ED, 0x01ED, /* LATIN SMALL LETTER O WITH OGONEK AND MACRON */
  0x01EF, 0x01F0, /* LATIN SMALL LETTER EZH WITH CARON */
  0x01F3, 0x01F3, /* LATIN SMALL LETTER DZ */
  0x01F5, 0x01F5, /* LATIN SMALL LETTER G WITH ACUTE */
  0x01F9, 0x01F9, /* LATIN SMALL LETTER N WITH GRAVE */
  0x01FB, 0x01FB, /* LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE */
  0x01FD, 0x01FD, /* LATIN SMALL LETTER AE WITH ACUTE */
  0x01FF, 0x01FF, /* LATIN SMALL LETTER O WITH STROKE AND ACUTE */
  0x0201, 0x0201, /* LATIN SMALL LETTER A WITH DOUBLE GRAVE */
  0x0203, 0x0203, /* LATIN SMALL LETTER A WITH INVERTED BREVE */
  0x0205, 0x0205, /* LATIN SMALL LETTER E WITH DOUBLE GRAVE */
  0x0207, 0x0207, /* LATIN SMALL LETTER E WITH INVERTED BREVE */
  0x0209, 0x0209, /* LATIN SMALL LETTER I WITH DOUBLE GRAVE */
  0x020B, 0x020B, /* LATIN SMALL LETTER I WITH INVERTED BREVE */
  0x020D, 0x020D, /* LATIN SMALL LETTER O WITH DOUBLE GRAVE */
  0x020F, 0x020F, /* LATIN SMALL LETTER O WITH INVERTED BREVE */
  0x0211, 0x0211, /* LATIN SMALL LETTER R WITH DOUBLE GRAVE */
  0x0213, 0x0213, /* LATIN SMALL LETTER R WITH INVERTED BREVE */
  0x0215, 0x0215, /* LATIN SMALL LETTER U WITH DOUBLE GRAVE */
  0x0217, 0x0217, /* LATIN SMALL LETTER U WITH INVERTED BREVE */
  0x0219, 0x0219, /* LATIN SMALL LETTER S WITH COMMA BELOW */
  0x021B, 0x021B, /* LATIN SMALL LETTER T WITH COMMA BELOW */
  0x021D, 0x021D, /* LATIN SMALL LETTER YOGH */
  0x021F, 0x021F, /* LATIN SMALL LETTER H WITH CARON */
  0x0221, 0x0221, /* LATIN SMALL LETTER D WITH CURL */
  0x0223, 0x0223, /* LATIN SMALL LETTER OU */
  0x0225, 0x0225, /* LATIN SMALL LETTER Z WITH HOOK */
  0x0227, 0x0227, /* LATIN SMALL LETTER A WITH DOT ABOVE */
  0x0229, 0x0229, /* LATIN SMALL LETTER E WITH CEDILLA */
  0x022B, 0x022B, /* LATIN SMALL LETTER O WITH DIAERESIS AND MACRON */
  0x022D, 0x022D, /* LATIN SMALL LETTER O WITH TILDE AND MACRON */
  0x022F, 0x022F, /* LATIN SMALL LETTER O WITH DOT ABOVE */
  0x0231, 0x0231, /* LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON */
  0x0233, 0x0239, /* LATIN SMALL LETTER Y WITH MACRON */
  0x023C, 0x023C, /* LATIN SMALL LETTER C WITH STROKE */
  0x023F, 0x0240, /* LATIN SMALL LETTER S WITH SWASH TAIL */
  0x0242, 0x0242, /* LATIN SMALL LETTER GLOTTAL STOP */
  0x0247, 0x0247, /* LATIN SMALL LETTER E WITH STROKE */
  0x0249, 0x0249, /* LATIN SMALL LETTER J WITH STROKE */
  0x024B, 0x024B, /* LATIN SMALL LETTER Q WITH HOOK TAIL */
  0x024D, 0x024D, /* LATIN SMALL LETTER R WITH STROKE */
  0x024F, 0x0293, /* LATIN SMALL LETTER Y WITH STROKE */
  0x0295, 0x02AF, /* LATIN LETTER PHARYNGEAL VOICED FRICATIVE */
  0x0371, 0x0371, /* GREEK SMALL LETTER HETA */
  0x0373, 0x0373, /* GREEK SMALL LETTER ARCHAIC SAMPI */
  0x0377, 0x0377, /* GREEK SMALL LETTER PAMPHYLIAN DIGAMMA */
  0x037B, 0x037D, /* GREEK SMALL REVERSED LUNATE SIGMA SYMBOL */
  0x0390, 0x0390, /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
  0x03AC, 0x03CE, /* GREEK SMALL LETTER ALPHA WITH TONOS */
  0x03D0, 0x03D1, /* GREEK BETA SYMBOL */
  0x03D5, 0x03D7, /* GREEK PHI SYMBOL */
  0x03D9, 0x03D9, /* GREEK SMALL LETTER ARCHAIC KOPPA */
  0x03DB, 0x03DB, /* GREEK SMALL LETTER STIGMA */
  0x03DD, 0x03DD, /* GREEK SMALL LETTER DIGAMMA */
  0x03DF, 0x03DF, /* GREEK SMALL LETTER KOPPA */
  0x03E1, 0x03E1, /* GREEK SMALL LETTER SAMPI */
  0x03E3, 0x03E3, /* COPTIC SMALL LETTER SHEI */
  0x03E5, 0x03E5, /* COPTIC SMALL LETTER FEI */
  0x03E7, 0x03E7, /* COPTIC SMALL LETTER KHEI */
  0x03E9, 0x03E9, /* COPTIC SMALL LETTER HORI */
  0x03EB, 0x03EB, /* COPTIC SMALL LETTER GANGIA */
  0x03ED, 0x03ED, /* COPTIC SMALL LETTER SHIMA */
  0x03EF, 0x03F3, /* COPTIC SMALL LETTER DEI */
  0x03F5, 0x03F5, /* GREEK LUNATE EPSILON SYMBOL */
  0x03F8, 0x03F8, /* GREEK SMALL LETTER SHO */
  0x03FB, 0x03FC, /* GREEK SMALL LETTER SAN */
  0x0430, 0x045F, /* CYRILLIC SMALL LETTER A */
  0x0461, 0x0461, /* CYRILLIC SMALL LETTER OMEGA */
  0x0463, 0x0463, /* CYRILLIC SMALL LETTER YAT */
  0x0465, 0x0465, /* CYRILLIC SMALL LETTER IOTIFIED E */
  0x0467, 0x0467, /* CYRILLIC SMALL LETTER LITTLE YUS */
  0x0469, 0x0469, /* CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS */
  0x046B, 0x046B, /* CYRILLIC SMALL LETTER BIG YUS */
  0x046D, 0x046D, /* CYRILLIC SMALL LETTER IOTIFIED BIG YUS */
  0x046F, 0x046F, /* CYRILLIC SMALL LETTER KSI */
  0x0471, 0x0471, /* CYRILLIC SMALL LETTER PSI */
  0x0473, 0x0473, /* CYRILLIC SMALL LETTER FITA */
  0x0475, 0x0475, /* CYRILLIC SMALL LETTER IZHITSA */
  0x0477, 0x0477, /* CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT */
  0x0479, 0x0479, /* CYRILLIC SMALL LETTER UK */
  0x047B, 0x047B, /* CYRILLIC SMALL LETTER ROUND OMEGA */
  0x047D, 0x047D, /* CYRILLIC SMALL LETTER OMEGA WITH TITLO */
  0x047F, 0x047F, /* CYRILLIC SMALL LETTER OT */
  0x0481, 0x0481, /* CYRILLIC SMALL LETTER KOPPA */
  0x048B, 0x048B, /* CYRILLIC SMALL LETTER SHORT I WITH TAIL */
  0x048D, 0x048D, /* CYRILLIC SMALL LETTER SEMISOFT SIGN */
  0x048F, 0x048F, /* CYRILLIC SMALL LETTER ER WITH TICK */
  0x0491, 0x0491, /* CYRILLIC SMALL LETTER GHE WITH UPTURN */
  0x0493, 0x0493, /* CYRILLIC SMALL LETTER GHE WITH STROKE */
  0x0495, 0x0495, /* CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK */
  0x0497, 0x0497, /* CYRILLIC SMALL LETTER ZHE WITH DESCENDER */
  0x0499, 0x0499, /* CYRILLIC SMALL LETTER ZE WITH DESCENDER */
  0x049B, 0x049B, /* CYRILLIC SMALL LETTER KA WITH DESCENDER */
  0x049D, 0x049D, /* CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE */
  0x049F, 0x049F, /* CYRILLIC SMALL LETTER KA WITH STROKE */
  0x04A1, 0x04A1, /* CYRILLIC SMALL LETTER BASHKIR KA */
  0x04A3, 0x04A3, /* CYRILLIC SMALL LETTER EN WITH DESCENDER */
  0x04A5, 0x04A5, /* CYRILLIC SMALL LIGATURE EN GHE */
  0x04A7, 0x04A7, /* CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK */
  0x04A9, 0x04A9, /* CYRILLIC SMALL LETTER ABKHASIAN HA */
  0x04AB, 0x04AB, /* CYRILLIC SMALL LETTER ES WITH DESCENDER */
  0x04AD, 0x04AD, /* CYRILLIC SMALL LETTER TE WITH DESCENDER */
  0x04AF, 0x04AF, /* CYRILLIC SMALL LETTER STRAIGHT U */
  0x04B1, 0x04B1, /* CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE */
  0x04B3, 0x04B3, /* CYRILLIC SMALL LETTER HA WITH DESCENDER */
  0x04B5, 0x04B5, /* CYRILLIC SMALL LIGATURE TE TSE */
  0x04B7, 0x04B7, /* CYRILLIC SMALL LETTER CHE WITH DESCENDER */
  0x04B9, 0x04B9, /* CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE */
  0x04BB, 0x04BB, /* CYRILLIC SMALL LETTER SHHA */
  0x04BD, 0x04BD, /* CYRILLIC SMALL LETTER ABKHASIAN CHE */
  0x04BF, 0x04BF, /* CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER */
  0x04C2, 0x04C2, /* CYRILLIC SMALL LETTER ZHE WITH BREVE */
  0x04C4, 0x04C4, /* CYRILLIC SMALL LETTER KA WITH HOOK */
  0x04C6, 0x04C6, /* CYRILLIC SMALL LETTER EL WITH TAIL */
  0x04C8, 0x04C8, /* CYRILLIC SMALL LETTER EN WITH HOOK */
  0x04CA, 0x04CA, /* CYRILLIC SMALL LETTER EN WITH TAIL */
  0x04CC, 0x04CC, /* CYRILLIC SMALL LETTER KHAKASSIAN CHE */
  0x04CE, 0x04CF, /* CYRILLIC SMALL LETTER EM WITH TAIL */
  0x04D1, 0x04D1, /* CYRILLIC SMALL LETTER A WITH BREVE */
  0x04D3, 0x04D3, /* CYRILLIC SMALL LETTER A WITH DIAERESIS */
  0x04D5, 0x04D5, /* CYRILLIC SMALL LIGATURE A IE */
  0x04D7, 0x04D7, /* CYRILLIC SMALL LETTER IE WITH BREVE */
  0x04D9, 0x04D9, /* CYRILLIC SMALL LETTER SCHWA */
  0x04DB, 0x04DB, /* CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS */
  0x04DD, 0x04DD, /* CYRILLIC SMALL LETTER ZHE WITH DIAERESIS */
  0x04DF, 0x04DF, /* CYRILLIC SMALL LETTER ZE WITH DIAERESIS */
  0x04E1, 0x04E1, /* CYRILLIC SMALL LETTER ABKHASIAN DZE */
  0x04E3, 0x04E3, /* CYRILLIC SMALL LETTER I WITH MACRON */
  0x04E5, 0x04E5, /* CYRILLIC SMALL LETTER I WITH DIAERESIS */
  0x04E7, 0x04E7, /* CYRILLIC SMALL LETTER O WITH DIAERESIS */
  0x04E9, 0x04E9, /* CYRILLIC SMALL LETTER BARRED O */
  0x04EB, 0x04EB, /* CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS */
  0x04ED, 0x04ED, /* CYRILLIC SMALL LETTER E WITH DIAERESIS */
  0x04EF, 0x04EF, /* CYRILLIC SMALL LETTER U WITH MACRON */
  0x04F1, 0x04F1, /* CYRILLIC SMALL LETTER U WITH DIAERESIS */
  0x04F3, 0x04F3, /* CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE */
  0x04F5, 0x04F5, /* CYRILLIC SMALL LETTER CHE WITH DIAERESIS */
  0x04F7, 0x04F7, /* CYRILLIC SMALL LETTER GHE WITH DESCENDER */
  0x04F9, 0x04F9, /* CYRILLIC SMALL LETTER YERU WITH DIAERESIS */
  0x04FB, 0x04FB, /* CYRILLIC SMALL LETTER GHE WITH STROKE AND HOOK */
  0x04FD, 0x04FD, /* CYRILLIC SMALL LETTER HA WITH HOOK */
  0x04FF, 0x04FF, /* CYRILLIC SMALL LETTER HA WITH STROKE */
  0x0501, 0x0501, /* CYRILLIC SMALL LETTER KOMI DE */
  0x0503, 0x0503, /* CYRILLIC SMALL LETTER KOMI DJE */
  0x0505, 0x0505, /* CYRILLIC SMALL LETTER KOMI ZJE */
  0x0507, 0x0507, /* CYRILLIC SMALL LETTER KOMI DZJE */
  0x0509, 0x0509, /* CYRILLIC SMALL LETTER KOMI LJE */
  0x050B, 0x050B, /* CYRILLIC SMALL LETTER KOMI NJE */
  0x050D, 0x050D, /* CYRILLIC SMALL LETTER KOMI SJE */
  0x050F, 0x050F, /* CYRILLIC SMALL LETTER KOMI TJE */
  0x0511, 0x0511, /* CYRILLIC SMALL LETTER REVERSED ZE */
  0x0513, 0x0513, /* CYRILLIC SMALL LETTER EL WITH HOOK */
  0x0515, 0x0515, /* CYRILLIC SMALL LETTER LHA */
  0x0517, 0x0517, /* CYRILLIC SMALL LETTER RHA */
  0x0519, 0x0519, /* CYRILLIC SMALL LETTER YAE */
  0x051B, 0x051B, /* CYRILLIC SMALL LETTER QA */
  0x051D, 0x051D, /* CYRILLIC SMALL LETTER WE */
  0x051F, 0x051F, /* CYRILLIC SMALL LETTER ALEUT KA */
  0x0521, 0x0521, /* CYRILLIC SMALL LETTER EL WITH MIDDLE HOOK */
  0x0523, 0x0523, /* CYRILLIC SMALL LETTER EN WITH MIDDLE HOOK */
  0x0525, 0x0525, /* CYRILLIC SMALL LETTER PE WITH DESCENDER */
  0x0527, 0x0527, /* CYRILLIC SMALL LETTER SHHA WITH DESCENDER */
  0x0529, 0x0529, /* CYRILLIC SMALL LETTER EN WITH LEFT HOOK */
  0x052B, 0x052B, /* CYRILLIC SMALL LETTER DZZHE */
  0x052D, 0x052D, /* CYRILLIC SMALL LETTER DCHE */
  0x052F, 0x052F, /* CYRILLIC SMALL LETTER EL WITH DESCENDER */
  0x0561, 0x0587, /* ARMENIAN SMALL LETTER AYB */
  0x13F8, 0x13FD, /* CHEROKEE SMALL LETTER YE */
  0x1D00, 0x1D2B, /* LATIN LETTER SMALL CAPITAL A */
  0x1D6B, 0x1D77, /* LATIN SMALL LETTER UE */
  0x1D79, 0x1D9A, /* LATIN SMALL LETTER INSULAR G */
  0x1E01, 0x1E01, /* LATIN SMALL LETTER A WITH RING BELOW */
  0x1E03, 0x1E03, /* LATIN SMALL LETTER B WITH DOT ABOVE */
  0x1E05, 0x1E05, /* LATIN SMALL LETTER B WITH DOT BELOW */
  0x1E07, 0x1E07, /* LATIN SMALL LETTER B WITH LINE BELOW */
  0x1E09, 0x1E09, /* LATIN SMALL LETTER C WITH CEDILLA AND ACUTE */
  0x1E0B, 0x1E0B, /* LATIN SMALL LETTER D WITH DOT ABOVE */
  0x1E0D, 0x1E0D, /* LATIN SMALL LETTER D WITH DOT BELOW */
  0x1E0F, 0x1E0F, /* LATIN SMALL LETTER D WITH LINE BELOW */
  0x1E11, 0x1E11, /* LATIN SMALL LETTER D WITH CEDILLA */
  0x1E13, 0x1E13, /* LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW */
  0x1E15, 0x1E15, /* LATIN SMALL LETTER E WITH MACRON AND GRAVE */
  0x1E17, 0x1E17, /* LATIN SMALL LETTER E WITH MACRON AND ACUTE */
  0x1E19, 0x1E19, /* LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW */
  0x1E1B, 0x1E1B, /* LATIN SMALL LETTER E WITH TILDE BELOW */
  0x1E1D, 0x1E1D, /* LATIN SMALL LETTER E WITH CEDILLA AND BREVE */
  0x1E1F, 0x1E1F, /* LATIN SMALL LETTER F WITH DOT ABOVE */
  0x1E21, 0x1E21, /* LATIN SMALL LETTER G WITH MACRON */
  0x1E23, 0x1E23, /* LATIN SMALL LETTER H WITH DOT ABOVE */
  0x1E25, 0x1E25, /* LATIN SMALL LETTER H WITH DOT BELOW */
  0x1E27, 0x1E27, /* LATIN SMALL LETTER H WITH DIAERESIS */
  0x1E29, 0x1E29, /* LATIN SMALL LETTER H WITH CEDILLA */
  0x1E2B, 0x1E2B, /* LATIN SMALL LETTER H WITH BREVE BELOW */
  0x1E2D, 0x1E2D, /* LATIN SMALL LETTER I WITH TILDE BELOW */
  0x1E2F, 0x1E2F, /* LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE */
  0x1E31, 0x1E31, /* LATIN SMALL LETTER K WITH ACUTE */
  0x1E33, 0x1E33, /* LATIN SMALL LETTER K WITH DOT BELOW */
  0x1E35, 0x1E35, /* LATIN SMALL LETTER K WITH LINE BELOW */
  0x1E37, 0x1E37, /* LATIN SMALL LETTER L WITH DOT BELOW */
  0x1E39, 0x1E39, /* LATIN SMALL LETTER L WITH DOT BELOW AND MACRON */
  0x1E3B, 0x1E3B, /* LATIN SMALL LETTER L WITH LINE BELOW */
  0x1E3D, 0x1E3D, /* LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW */
  0x1E3F, 0x1E3F, /* LATIN SMALL LETTER M WITH ACUTE */
  0x1E41, 0x1E41, /* LATIN SMALL LETTER M WITH DOT ABOVE */
  0x1E43, 0x1E43, /* LATIN SMALL LETTER M WITH DOT BELOW */
  0x1E45, 0x1E45, /* LATIN SMALL LETTER N WITH DOT ABOVE */
  0x1E47, 0x1E47, /* LATIN SMALL LETTER N WITH DOT BELOW */
  0x1E49, 0x1E49, /* LATIN SMALL LETTER N WITH LINE BELOW */
  0x1E4B, 0x1E4B, /* LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW */
  0x1E4D, 0x1E4D, /* LATIN SMALL LETTER O WITH TILDE AND ACUTE */
  0x1E4F, 0x1E4F, /* LATIN SMALL LETTER O WITH TILDE AND DIAERESIS */
  0x1E51, 0x1E51, /* LATIN SMALL LETTER O WITH MACRON AND GRAVE */
  0x1E53, 0x1E53, /* LATIN SMALL LETTER O WITH MACRON AND ACUTE */
  0x1E55, 0x1E55, /* LATIN SMALL LETTER P WITH ACUTE */
  0x1E57, 0x1E57, /* LATIN SMALL LETTER P WITH DOT ABOVE */
  0x1E59, 0x1E59, /* LATIN SMALL LETTER R WITH DOT ABOVE */
  0x1E5B, 0x1E5B, /* LATIN SMALL LETTER R WITH DOT BELOW */
  0x1E5D, 0x1E5D, /* LATIN SMALL LETTER R WITH DOT BELOW AND MACRON */
  0x1E5F, 0x1E5F, /* LATIN SMALL LETTER R WITH LINE BELOW */
  0x1E61, 0x1E61, /* LATIN SMALL LETTER S WITH DOT ABOVE */
  0x1E63, 0x1E63, /* LATIN SMALL LETTER S WITH DOT BELOW */
  0x1E65, 0x1E65, /* LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE */
  0x1E67, 0x1E67, /* LATIN SMALL LETTER S WITH CARON AND DOT ABOVE */
  0x1E69, 0x1E69, /* LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE */
  0x1E6B, 0x1E6B, /* LATIN SMALL LETTER T WITH DOT ABOVE */
  0x1E6D, 0x1E6D, /* LATIN SMALL LETTER T WITH DOT BELOW */
  0x1E6F, 0x1E6F, /* LATIN SMALL LETTER T WITH LINE BELOW */
  0x1E71, 0x1E71, /* LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW */
  0x1E73, 0x1E73, /* LATIN SMALL LETTER U WITH DIAERESIS BELOW */
  0x1E75, 0x1E75, /* LATIN SMALL LETTER U WITH TILDE BELOW */
  0x1E77, 0x1E77, /* LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW */
  0x1E79, 0x1E79, /* LATIN SMALL LETTER U WITH TILDE AND ACUTE */
  0x1E7B, 0x1E7B, /* LATIN SMALL LETTER U WITH MACRON AND DIAERESIS */
  0x1E7D, 0x1E7D, /* LATIN SMALL LETTER V WITH TILDE */
  0x1E7F, 0x1E7F, /* LATIN SMALL LETTER V WITH DOT BELOW */
  0x1E81, 0x1E81, /* LATIN SMALL LETTER W WITH GRAVE */
  0x1E83, 0x1E83, /* LATIN SMALL LETTER W WITH ACUTE */
  0x1E85, 0x1E85, /* LATIN SMALL LETTER W WITH DIAERESIS */
  0x1E87, 0x1E87, /* LATIN SMALL LETTER W WITH DOT ABOVE */
  0x1E89, 0x1E89, /* LATIN SMALL LETTER W WITH DOT BELOW */
  0x1E8B, 0x1E8B, /* LATIN SMALL LETTER X WITH DOT ABOVE */
  0x1E8D, 0x1E8D, /* LATIN SMALL LETTER X WITH DIAERESIS */
  0x1E8F, 0x1E8F, /* LATIN SMALL LETTER Y WITH DOT ABOVE */
  0x1E91, 0x1E91, /* LATIN SMALL LETTER Z WITH CIRCUMFLEX */
  0x1E93, 0x1E93, /* LATIN SMALL LETTER Z WITH DOT BELOW */
  0x1E95, 0x1E9D, /* LATIN SMALL LETTER Z WITH LINE BELOW */
  0x1E9F, 0x1E9F, /* LATIN SMALL LETTER DELTA */
  0x1EA1, 0x1EA1, /* LATIN SMALL LETTER A WITH DOT BELOW */
  0x1EA3, 0x1EA3, /* LATIN SMALL LETTER A WITH HOOK ABOVE */
  0x1EA5, 0x1EA5, /* LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE */
  0x1EA7, 0x1EA7, /* LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE */
  0x1EA9, 0x1EA9, /* LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1EAB, 0x1EAB, /* LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE */
  0x1EAD, 0x1EAD, /* LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
  0x1EAF, 0x1EAF, /* LATIN SMALL LETTER A WITH BREVE AND ACUTE */
  0x1EB1, 0x1EB1, /* LATIN SMALL LETTER A WITH BREVE AND GRAVE */
  0x1EB3, 0x1EB3, /* LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE */
  0x1EB5, 0x1EB5, /* LATIN SMALL LETTER A WITH BREVE AND TILDE */
  0x1EB7, 0x1EB7, /* LATIN SMALL LETTER A WITH BREVE AND DOT BELOW */
  0x1EB9, 0x1EB9, /* LATIN SMALL LETTER E WITH DOT BELOW */
  0x1EBB, 0x1EBB, /* LATIN SMALL LETTER E WITH HOOK ABOVE */
  0x1EBD, 0x1EBD, /* LATIN SMALL LETTER E WITH TILDE */
  0x1EBF, 0x1EBF, /* LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE */
  0x1EC1, 0x1EC1, /* LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE */
  0x1EC3, 0x1EC3, /* LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1EC5, 0x1EC5, /* LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE */
  0x1EC7, 0x1EC7, /* LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
  0x1EC9, 0x1EC9, /* LATIN SMALL LETTER I WITH HOOK ABOVE */
  0x1ECB, 0x1ECB, /* LATIN SMALL LETTER I WITH DOT BELOW */
  0x1ECD, 0x1ECD, /* LATIN SMALL LETTER O WITH DOT BELOW */
  0x1ECF, 0x1ECF, /* LATIN SMALL LETTER O WITH HOOK ABOVE */
  0x1ED1, 0x1ED1, /* LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE */
  0x1ED3, 0x1ED3, /* LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE */
  0x1ED5, 0x1ED5, /* LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1ED7, 0x1ED7, /* LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE */
  0x1ED9, 0x1ED9, /* LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
  0x1EDB, 0x1EDB, /* LATIN SMALL LETTER O WITH HORN AND ACUTE */
  0x1EDD, 0x1EDD, /* LATIN SMALL LETTER O WITH HORN AND GRAVE */
  0x1EDF, 0x1EDF, /* LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE */
  0x1EE1, 0x1EE1, /* LATIN SMALL LETTER O WITH HORN AND TILDE */
  0x1EE3, 0x1EE3, /* LATIN SMALL LETTER O WITH HORN AND DOT BELOW */
  0x1EE5, 0x1EE5, /* LATIN SMALL LETTER U WITH DOT BELOW */
  0x1EE7, 0x1EE7, /* LATIN SMALL LETTER U WITH HOOK ABOVE */
  0x1EE9, 0x1EE9, /* LATIN SMALL LETTER U WITH HORN AND ACUTE */
  0x1EEB, 0x1EEB, /* LATIN SMALL LETTER U WITH HORN AND GRAVE */
  0x1EED, 0x1EED, /* LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE */
  0x1EEF, 0x1EEF, /* LATIN SMALL LETTER U WITH HORN AND TILDE */
  0x1EF1, 0x1EF1, /* LATIN SMALL LETTER U WITH HORN AND DOT BELOW */
  0x1EF3, 0x1EF3, /* LATIN SMALL LETTER Y WITH GRAVE */
  0x1EF5, 0x1EF5, /* LATIN SMALL LETTER Y WITH DOT BELOW */
  0x1EF7, 0x1EF7, /* LATIN SMALL LETTER Y WITH HOOK ABOVE */
  0x1EF9, 0x1EF9, /* LATIN SMALL LETTER Y WITH TILDE */
  0x1EFB, 0x1EFB, /* LATIN SMALL LETTER MIDDLE-WELSH LL */
  0x1EFD, 0x1EFD, /* LATIN SMALL LETTER MIDDLE-WELSH V */
  0x1EFF, 0x1F07, /* LATIN SMALL LETTER Y WITH LOOP */
  0x1F10, 0x1F15, /* GREEK SMALL LETTER EPSILON WITH PSILI */
  0x1F20, 0x1F27, /* GREEK SMALL LETTER ETA WITH PSILI */
  0x1F30, 0x1F37, /* GREEK SMALL LETTER IOTA WITH PSILI */
  0x1F40, 0x1F45, /* GREEK SMALL LETTER OMICRON WITH PSILI */
  0x1F50, 0x1F57, /* GREEK SMALL LETTER UPSILON WITH PSILI */
  0x1F60, 0x1F67, /* GREEK SMALL LETTER OMEGA WITH PSILI */
  0x1F70, 0x1F87, /* GREEK SMALL LETTER ALPHA WITH VARIA */
  0x1F90, 0x1F97, /* GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI */
  0x1FA0, 0x1FA7, /* GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI */
  0x1FB0, 0x1FB7, /* GREEK SMALL LETTER ALPHA WITH VRACHY */
  0x1FBE, 0x1FBE, /* GREEK PROSGEGRAMMENI */
  0x1FC2, 0x1FC7, /* GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI */
  0x1FD0, 0x1FD7, /* GREEK SMALL LETTER IOTA WITH VRACHY */
  0x1FE0, 0x1FE7, /* GREEK SMALL LETTER UPSILON WITH VRACHY */
  0x1FF2, 0x1FF7, /* GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI */
  0x210A, 0x210A, /* SCRIPT SMALL G */
  0x210E, 0x210F, /* PLANCK CONSTANT */
  0x2113, 0x2113, /* SCRIPT SMALL L */
  0x212F, 0x212F, /* SCRIPT SMALL E */
  0x2134, 0x2134, /* SCRIPT SMALL O */
  0x2139, 0x2139, /* INFORMATION SOURCE */
  0x213C, 0x213D, /* DOUBLE-STRUCK SMALL PI */
  0x2146, 0x2149, /* DOUBLE-STRUCK ITALIC SMALL D */
  0x214E, 0x214E, /* TURNED SMALL F */
  0x2184, 0x2184, /* LATIN SMALL LETTER REVERSED C */
  0x2C30, 0x2C5E, /* GLAGOLITIC SMALL LETTER AZU */
  0x2C61, 0x2C61, /* LATIN SMALL LETTER L WITH DOUBLE BAR */
  0x2C65, 0x2C66, /* LATIN SMALL LETTER A WITH STROKE */
  0x2C68, 0x2C68, /* LATIN SMALL LETTER H WITH DESCENDER */
  0x2C6A, 0x2C6A, /* LATIN SMALL LETTER K WITH DESCENDER */
  0x2C6C, 0x2C6C, /* LATIN SMALL LETTER Z WITH DESCENDER */
  0x2C71, 0x2C71, /* LATIN SMALL LETTER V WITH RIGHT HOOK */
  0x2C73, 0x2C74, /* LATIN SMALL LETTER W WITH HOOK */
  0x2C76, 0x2C7B, /* LATIN SMALL LETTER HALF H */
  0x2C81, 0x2C81, /* COPTIC SMALL LETTER ALFA */
  0x2C83, 0x2C83, /* COPTIC SMALL LETTER VIDA */
  0x2C85, 0x2C85, /* COPTIC SMALL LETTER GAMMA */
  0x2C87, 0x2C87, /* COPTIC SMALL LETTER DALDA */
  0x2C89, 0x2C89, /* COPTIC SMALL LETTER EIE */
  0x2C8B, 0x2C8B, /* COPTIC SMALL LETTER SOU */
  0x2C8D, 0x2C8D, /* COPTIC SMALL LETTER ZATA */
  0x2C8F, 0x2C8F, /* COPTIC SMALL LETTER HATE */
  0x2C91, 0x2C91, /* COPTIC SMALL LETTER THETHE */
  0x2C93, 0x2C93, /* COPTIC SMALL LETTER IAUDA */
  0x2C95, 0x2C95, /* COPTIC SMALL LETTER KAPA */
  0x2C97, 0x2C97, /* COPTIC SMALL LETTER LAULA */
  0x2C99, 0x2C99, /* COPTIC SMALL LETTER MI */
  0x2C9B, 0x2C9B, /* COPTIC SMALL LETTER NI */
  0x2C9D, 0x2C9D, /* COPTIC SMALL LETTER KSI */
  0x2C9F, 0x2C9F, /* COPTIC SMALL LETTER O */
  0x2CA1, 0x2CA1, /* COPTIC SMALL LETTER PI */
  0x2CA3, 0x2CA3, /* COPTIC SMALL LETTER RO */
  0x2CA5, 0x2CA5, /* COPTIC SMALL LETTER SIMA */
  0x2CA7, 0x2CA7, /* COPTIC SMALL LETTER TAU */
  0x2CA9, 0x2CA9, /* COPTIC SMALL LETTER UA */
  0x2CAB, 0x2CAB, /* COPTIC SMALL LETTER FI */
  0x2CAD, 0x2CAD, /* COPTIC SMALL LETTER KHI */
  0x2CAF, 0x2CAF, /* COPTIC SMALL LETTER PSI */
  0x2CB1, 0x2CB1, /* COPTIC SMALL LETTER OOU */
  0x2CB3, 0x2CB3, /* COPTIC SMALL LETTER DIALECT-P ALEF */
  0x2CB5, 0x2CB5, /* COPTIC SMALL LETTER OLD COPTIC AIN */
  0x2CB7, 0x2CB7, /* COPTIC SMALL LETTER CRYPTOGRAMMIC EIE */
  0x2CB9, 0x2CB9, /* COPTIC SMALL LETTER DIALECT-P KAPA */
  0x2CBB, 0x2CBB, /* COPTIC SMALL LETTER DIALECT-P NI */
  0x2CBD, 0x2CBD, /* COPTIC SMALL LETTER CRYPTOGRAMMIC NI */
  0x2CBF, 0x2CBF, /* COPTIC SMALL LETTER OLD COPTIC OOU */
  0x2CC1, 0x2CC1, /* COPTIC SMALL LETTER SAMPI */
  0x2CC3, 0x2CC3, /* COPTIC SMALL LETTER CROSSED SHEI */
  0x2CC5, 0x2CC5, /* COPTIC SMALL LETTER OLD COPTIC SHEI */
  0x2CC7, 0x2CC7, /* COPTIC SMALL LETTER OLD COPTIC ESH */
  0x2CC9, 0x2CC9, /* COPTIC SMALL LETTER AKHMIMIC KHEI */
  0x2CCB, 0x2CCB, /* COPTIC SMALL LETTER DIALECT-P HORI */
  0x2CCD, 0x2CCD, /* COPTIC SMALL LETTER OLD COPTIC HORI */
  0x2CCF, 0x2CCF, /* COPTIC SMALL LETTER OLD COPTIC HA */
  0x2CD1, 0x2CD1, /* COPTIC SMALL LETTER L-SHAPED HA */
  0x2CD3, 0x2CD3, /* COPTIC SMALL LETTER OLD COPTIC HEI */
  0x2CD5, 0x2CD5, /* COPTIC SMALL LETTER OLD COPTIC HAT */
  0x2CD7, 0x2CD7, /* COPTIC SMALL LETTER OLD COPTIC GANGIA */
  0x2CD9, 0x2CD9, /* COPTIC SMALL LETTER OLD COPTIC DJA */
  0x2CDB, 0x2CDB, /* COPTIC SMALL LETTER OLD COPTIC SHIMA */
  0x2CDD, 0x2CDD, /* COPTIC SMALL LETTER OLD NUBIAN SHIMA */
  0x2CDF, 0x2CDF, /* COPTIC SMALL LETTER OLD NUBIAN NGI */
  0x2CE1, 0x2CE1, /* COPTIC SMALL LETTER OLD NUBIAN NYI */
  0x2CE3, 0x2CE4, /* COPTIC SMALL LETTER OLD NUBIAN WAU */
  0x2CEC, 0x2CEC, /* COPTIC SMALL LETTER CRYPTOGRAMMIC SHEI */
  0x2CEE, 0x2CEE, /* COPTIC SMALL LETTER CRYPTOGRAMMIC GANGIA */
  0x2CF3, 0x2CF3, /* COPTIC SMALL LETTER BOHAIRIC KHEI */
  0x2D00, 0x2D2D, /* GEORGIAN SMALL LETTER AN */
  0xA641, 0xA641, /* CYRILLIC SMALL LETTER ZEMLYA */
  0xA643, 0xA643, /* CYRILLIC SMALL LETTER DZELO */
  0xA645, 0xA645, /* CYRILLIC SMALL LETTER REVERSED DZE */
  0xA647, 0xA647, /* CYRILLIC SMALL LETTER IOTA */
  0xA649, 0xA649, /* CYRILLIC SMALL LETTER DJERV */
  0xA64B, 0xA64B, /* CYRILLIC SMALL LETTER MONOGRAPH UK */
  0xA64D, 0xA64D, /* CYRILLIC SMALL LETTER BROAD OMEGA */
  0xA64F, 0xA64F, /* CYRILLIC SMALL LETTER NEUTRAL YER */
  0xA651, 0xA651, /* CYRILLIC SMALL LETTER YERU WITH BACK YER */
  0xA653, 0xA653, /* CYRILLIC SMALL LETTER IOTIFIED YAT */
  0xA655, 0xA655, /* CYRILLIC SMALL LETTER REVERSED YU */
  0xA657, 0xA657, /* CYRILLIC SMALL LETTER IOTIFIED A */
  0xA659, 0xA659, /* CYRILLIC SMALL LETTER CLOSED LITTLE YUS */
  0xA65B, 0xA65B, /* CYRILLIC SMALL LETTER BLENDED YUS */
  0xA65D, 0xA65D, /* CYRILLIC SMALL LETTER IOTIFIED CLOSED LITTLE YUS */
  0xA65F, 0xA65F, /* CYRILLIC SMALL LETTER YN */
  0xA661, 0xA661, /* CYRILLIC SMALL LETTER REVERSED TSE */
  0xA663, 0xA663, /* CYRILLIC SMALL LETTER SOFT DE */
  0xA665, 0xA665, /* CYRILLIC SMALL LETTER SOFT EL */
  0xA667, 0xA667, /* CYRILLIC SMALL LETTER SOFT EM */
  0xA669, 0xA669, /* CYRILLIC SMALL LETTER MONOCULAR O */
  0xA66B, 0xA66B, /* CYRILLIC SMALL LETTER BINOCULAR O */
  0xA66D, 0xA66D, /* CYRILLIC SMALL LETTER DOUBLE MONOCULAR O */
  0xA681, 0xA681, /* CYRILLIC SMALL LETTER DWE */
  0xA683, 0xA683, /* CYRILLIC SMALL LETTER DZWE */
  0xA685, 0xA685, /* CYRILLIC SMALL LETTER ZHWE */
  0xA687, 0xA687, /* CYRILLIC SMALL LETTER CCHE */
  0xA689, 0xA689, /* CYRILLIC SMALL LETTER DZZE */
  0xA68B, 0xA68B, /* CYRILLIC SMALL LETTER TE WITH MIDDLE HOOK */
  0xA68D, 0xA68D, /* CYRILLIC SMALL LETTER TWE */
  0xA68F, 0xA68F, /* CYRILLIC SMALL LETTER TSWE */
  0xA691, 0xA691, /* CYRILLIC SMALL LETTER TSSE */
  0xA693, 0xA693, /* CYRILLIC SMALL LETTER TCHE */
  0xA695, 0xA695, /* CYRILLIC SMALL LETTER HWE */
  0xA697, 0xA697, /* CYRILLIC SMALL LETTER SHWE */
  0xA699, 0xA699, /* CYRILLIC SMALL LETTER DOUBLE O */
  0xA69B, 0xA69B, /* CYRILLIC SMALL LETTER CROSSED O */
  0xA723, 0xA723, /* LATIN SMALL LETTER EGYPTOLOGICAL ALEF */
  0xA725, 0xA725, /* LATIN SMALL LETTER EGYPTOLOGICAL AIN */
  0xA727, 0xA727, /* LATIN SMALL LETTER HENG */
  0xA729, 0xA729, /* LATIN SMALL LETTER TZ */
  0xA72B, 0xA72B, /* LATIN SMALL LETTER TRESILLO */
  0xA72D, 0xA72D, /* LATIN SMALL LETTER CUATRILLO */
  0xA72F, 0xA731, /* LATIN SMALL LETTER CUATRILLO WITH COMMA */
  0xA733, 0xA733, /* LATIN SMALL LETTER AA */
  0xA735, 0xA735, /* LATIN SMALL LETTER AO */
  0xA737, 0xA737, /* LATIN SMALL LETTER AU */
  0xA739, 0xA739, /* LATIN SMALL LETTER AV */
  0xA73B, 0xA73B, /* LATIN SMALL LETTER AV WITH HORIZONTAL BAR */
  0xA73D, 0xA73D, /* LATIN SMALL LETTER AY */
  0xA73F, 0xA73F, /* LATIN SMALL LETTER REVERSED C WITH DOT */
  0xA741, 0xA741, /* LATIN SMALL LETTER K WITH STROKE */
  0xA743, 0xA743, /* LATIN SMALL LETTER K WITH DIAGONAL STROKE */
  0xA745, 0xA745, /* LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE */
  0xA747, 0xA747, /* LATIN SMALL LETTER BROKEN L */
  0xA749, 0xA749, /* LATIN SMALL LETTER L WITH HIGH STROKE */
  0xA74B, 0xA74B, /* LATIN SMALL LETTER O WITH LONG STROKE OVERLAY */
  0xA74D, 0xA74D, /* LATIN SMALL LETTER O WITH LOOP */
  0xA74F, 0xA74F, /* LATIN SMALL LETTER OO */
  0xA751, 0xA751, /* LATIN SMALL LETTER P WITH STROKE THROUGH DESCENDER */
  0xA753, 0xA753, /* LATIN SMALL LETTER P WITH FLOURISH */
  0xA755, 0xA755, /* LATIN SMALL LETTER P WITH SQUIRREL TAIL */
  0xA757, 0xA757, /* LATIN SMALL LETTER Q WITH STROKE THROUGH DESCENDER */
  0xA759, 0xA759, /* LATIN SMALL LETTER Q WITH DIAGONAL STROKE */
  0xA75B, 0xA75B, /* LATIN SMALL LETTER R ROTUNDA */
  0xA75D, 0xA75D, /* LATIN SMALL LETTER RUM ROTUNDA */
  0xA75F, 0xA75F, /* LATIN SMALL LETTER V WITH DIAGONAL STROKE */
  0xA761, 0xA761, /* LATIN SMALL LETTER VY */
  0xA763, 0xA763, /* LATIN SMALL LETTER VISIGOTHIC Z */
  0xA765, 0xA765, /* LATIN SMALL LETTER THORN WITH STROKE */
  0xA767, 0xA767, /* LATIN SMALL LETTER THORN WITH STROKE THROUGH DESCENDER */
  0xA769, 0xA769, /* LATIN SMALL LETTER VEND */
  0xA76B, 0xA76B, /* LATIN SMALL LETTER ET */
  0xA76D, 0xA76D, /* LATIN SMALL LETTER IS */
  0xA76F, 0xA76F, /* LATIN SMALL LETTER CON */
  0xA771, 0xA778, /* LATIN SMALL LETTER DUM */
  0xA77A, 0xA77A, /* LATIN SMALL LETTER INSULAR D */
  0xA77C, 0xA77C, /* LATIN SMALL LETTER INSULAR F */
  0xA77F, 0xA77F, /* LATIN SMALL LETTER TURNED INSULAR G */
  0xA781, 0xA781, /* LATIN SMALL LETTER TURNED L */
  0xA783, 0xA783, /* LATIN SMALL LETTER INSULAR R */
  0xA785, 0xA785, /* LATIN SMALL LETTER INSULAR S */
  0xA787, 0xA787, /* LATIN SMALL LETTER INSULAR T */
  0xA78C, 0xA78C, /* LATIN SMALL LETTER SALTILLO */
  0xA78E, 0xA78E, /* LATIN SMALL LETTER L WITH RETROFLEX HOOK AND BELT */
  0xA791, 0xA791, /* LATIN SMALL LETTER N WITH DESCENDER */
  0xA793, 0xA795, /* LATIN SMALL LETTER C WITH BAR */
  0xA797, 0xA797, /* LATIN SMALL LETTER B WITH FLOURISH */
  0xA799, 0xA799, /* LATIN SMALL LETTER F WITH STROKE */
  0xA79B, 0xA79B, /* LATIN SMALL LETTER VOLAPUK AE */
  0xA79D, 0xA79D, /* LATIN SMALL LETTER VOLAPUK OE */
  0xA79F, 0xA79F, /* LATIN SMALL LETTER VOLAPUK UE */
  0xA7A1, 0xA7A1, /* LATIN SMALL LETTER G WITH OBLIQUE STROKE */
  0xA7A3, 0xA7A3, /* LATIN SMALL LETTER K WITH OBLIQUE STROKE */
  0xA7A5, 0xA7A5, /* LATIN SMALL LETTER N WITH OBLIQUE STROKE */
  0xA7A7, 0xA7A7, /* LATIN SMALL LETTER R WITH OBLIQUE STROKE */
  0xA7A9, 0xA7A9, /* LATIN SMALL LETTER S WITH OBLIQUE STROKE */
  0xA7B5, 0xA7B5, /* LATIN SMALL LETTER BETA */
  0xA7B7, 0xA7B7, /* LATIN SMALL LETTER OMEGA */
  0xA7FA, 0xA7FA, /* LATIN LETTER SMALL CAPITAL TURNED M */
  0xAB30, 0xAB5A, /* LATIN SMALL LETTER BARRED ALPHA */
  0xAB60, 0xABBF, /* LATIN SMALL LETTER SAKHA YAT */
  0xFB00, 0xFB17, /* LATIN SMALL LIGATURE FF */
  0xFF41, 0xFF5A, /* FULLWIDTH LATIN SMALL LETTER A */
  0x10428, 0x1044F, /* DESERET SMALL LETTER LONG I */
  0x10CC0, 0x10CF2, /* OLD HUNGARIAN SMALL LETTER A */
  0x118C0, 0x118DF, /* WARANG CITI SMALL LETTER NGAA */
  0x1D41A, 0x1D433, /* MATHEMATICAL BOLD SMALL A */
  0x1D44E, 0x1D467, /* MATHEMATICAL ITALIC SMALL A */
  0x1D482, 0x1D49B, /* MATHEMATICAL BOLD ITALIC SMALL A */
  0x1D4B6, 0x1D4CF, /* MATHEMATICAL SCRIPT SMALL A */
  0x1D4EA, 0x1D503, /* MATHEMATICAL BOLD SCRIPT SMALL A */
  0x1D51E, 0x1D537, /* MATHEMATICAL FRAKTUR SMALL A */
  0x1D552, 0x1D56B, /* MATHEMATICAL DOUBLE-STRUCK SMALL A */
  0x1D586, 0x1D59F, /* MATHEMATICAL BOLD FRAKTUR SMALL A */
  0x1D5BA, 0x1D5D3, /* MATHEMATICAL SANS-SERIF SMALL A */
  0x1D5EE, 0x1D607, /* MATHEMATICAL SANS-SERIF BOLD SMALL A */
  0x1D622, 0x1D63B, /* MATHEMATICAL SANS-SERIF ITALIC SMALL A */
  0x1D656, 0x1D66F, /* MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL A */
  0x1D68A, 0x1D6A5, /* MATHEMATICAL MONOSPACE SMALL A */
  0x1D6C2, 0x1D6DA, /* MATHEMATICAL BOLD SMALL ALPHA */
  0x1D6DC, 0x1D6E1, /* MATHEMATICAL BOLD EPSILON SYMBOL */
  0x1D6FC, 0x1D714, /* MATHEMATICAL ITALIC SMALL ALPHA */
  0x1D716, 0x1D71B, /* MATHEMATICAL ITALIC EPSILON SYMBOL */
  0x1D736, 0x1D74E, /* MATHEMATICAL BOLD ITALIC SMALL ALPHA */
  0x1D750, 0x1D755, /* MATHEMATICAL BOLD ITALIC EPSILON SYMBOL */
  0x1D770, 0x1D788, /* MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA */
  0x1D78A, 0x1D78F, /* MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL */
  0x1D7AA, 0x1D7C2, /* MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA */
  0x1D7C4, 0x1D7C9, /* MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL */
  0x1D7CB, 0x1D7CB, /* MATHEMATICAL BOLD SMALL DIGAMMA */
  0x02B0, 0x02C1, /* MODIFIER LETTER SMALL H */
  0x02C6, 0x02D1, /* MODIFIER LETTER CIRCUMFLEX ACCENT */
  0x02E0, 0x02E4, /* MODIFIER LETTER SMALL GAMMA */
  0x02EC, 0x02EC, /* MODIFIER LETTER VOICING */
  0x02EE, 0x02EE, /* MODIFIER LETTER DOUBLE APOSTROPHE */
  0x0374, 0x0374, /* GREEK NUMERAL SIGN */
  0x037A, 0x037A, /* GREEK YPOGEGRAMMENI */
  0x0559, 0x0559, /* ARMENIAN MODIFIER LETTER LEFT HALF RING */
  0x0640, 0x0640, /* ARABIC TATWEEL */
  0x06E5, 0x06E6, /* ARABIC SMALL WAW */
  0x07F4, 0x07F5, /* NKO HIGH TONE APOSTROPHE */
  0x07FA, 0x07FA, /* NKO LAJANYALAN */
  0x081A, 0x081A, /* SAMARITAN MODIFIER LETTER EPENTHETIC YUT */
  0x0824, 0x0824, /* SAMARITAN MODIFIER LETTER SHORT A */
  0x0828, 0x0828, /* SAMARITAN MODIFIER LETTER I */
  0x0971, 0x0971, /* DEVANAGARI SIGN HIGH SPACING DOT */
  0x0E46, 0x0E46, /* THAI CHARACTER MAIYAMOK */
  0x0EC6, 0x0EC6, /* LAO KO LA */
  0x10FC, 0x10FC, /* MODIFIER LETTER GEORGIAN NAR */
  0x17D7, 0x17D7, /* KHMER SIGN LEK TOO */
  0x1843, 0x1843, /* MONGOLIAN LETTER TODO LONG VOWEL SIGN */
  0x1AA7, 0x1AA7, /* TAI THAM SIGN MAI YAMOK */
  0x1C78, 0x1C7D, /* OL CHIKI MU TTUDDAG */
  0x1D2C, 0x1D6A, /* MODIFIER LETTER CAPITAL A */
  0x1D78, 0x1D78, /* MODIFIER LETTER CYRILLIC EN */
  0x1D9B, 0x1DBF, /* MODIFIER LETTER SMALL TURNED ALPHA */
  0x2071, 0x2071, /* SUPERSCRIPT LATIN SMALL LETTER I */
  0x207F, 0x207F, /* SUPERSCRIPT LATIN SMALL LETTER N */
  0x2090, 0x209C, /* LATIN SUBSCRIPT SMALL LETTER A */
  0x2C7C, 0x2C7D, /* LATIN SUBSCRIPT SMALL LETTER J */
  0x2D6F, 0x2D6F, /* TIFINAGH MODIFIER LETTER LABIALIZATION MARK */
  0x2E2F, 0x2E2F, /* VERTICAL TILDE */
  0x3005, 0x3005, /* IDEOGRAPHIC ITERATION MARK */
  0x3031, 0x3035, /* VERTICAL KANA REPEAT MARK */
  0x303B, 0x303B, /* VERTICAL IDEOGRAPHIC ITERATION MARK */
  0x309D, 0x309E, /* HIRAGANA ITERATION MARK */
  0x30FC, 0x30FE, /* KATAKANA-HIRAGANA PROLONGED SOUND MARK */
  0xA015, 0xA015, /* YI SYLLABLE WU */
  0xA4F8, 0xA4FD, /* LISU LETTER TONE MYA TI */
  0xA60C, 0xA60C, /* VAI SYLLABLE LENGTHENER */
  0xA67F, 0xA67F, /* CYRILLIC PAYEROK */
  0xA69C, 0xA69D, /* MODIFIER LETTER CYRILLIC HARD SIGN */
  0xA717, 0xA71F, /* MODIFIER LETTER DOT VERTICAL BAR */
  0xA770, 0xA770, /* MODIFIER LETTER US */
  0xA788, 0xA788, /* MODIFIER LETTER LOW CIRCUMFLEX ACCENT */
  0xA7F8, 0xA7F9, /* MODIFIER LETTER CAPITAL H WITH STROKE */
  0xA9CF, 0xA9CF, /* JAVANESE PANGRANGKEP */
  0xA9E6, 0xA9E6, /* MYANMAR MODIFIER LETTER SHAN REDUPLICATION */
  0xAA70, 0xAA70, /* MYANMAR MODIFIER LETTER KHAMTI REDUPLICATION */
  0xAADD, 0xAADD, /* TAI VIET SYMBOL SAM */
  0xAAF3, 0xAAF4, /* MEETEI MAYEK SYLLABLE REPETITION MARK */
  0xAB5C, 0xAB5F, /* MODIFIER LETTER SMALL HENG */
  0xFF70, 0xFF70, /* HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK */
  0xFF9E, 0xFF9F, /* HALFWIDTH KATAKANA VOICED SOUND MARK */
  0x16B40, 0x16B43, /* PAHAWH HMONG SIGN VOS SEEV */
  0x16F93, 0x16F9F, /* MIAO LETTER TONE-2 */
  0x00AA, 0x00AA, /* FEMININE ORDINAL INDICATOR */
  0x00BA, 0x00BA, /* MASCULINE ORDINAL INDICATOR */
  0x01BB, 0x01BB, /* LATIN LETTER TWO WITH STROKE */
  0x01C0, 0x01C3, /* LATIN LETTER DENTAL CLICK */
  0x0294, 0x0294, /* LATIN LETTER GLOTTAL STOP */
  0x05D0, 0x05F2, /* HEBREW LETTER ALEF */
  0x0620, 0x063F, /* ARABIC LETTER KASHMIRI YEH */
  0x0641, 0x064A, /* ARABIC LETTER FEH */
  0x066E, 0x066F, /* ARABIC LETTER DOTLESS BEH */
  0x0671, 0x06D3, /* ARABIC LETTER ALEF WASLA */
  0x06D5, 0x06D5, /* ARABIC LETTER AE */
  0x06EE, 0x06EF, /* ARABIC LETTER DAL WITH INVERTED V */
  0x06FA, 0x06FC, /* ARABIC LETTER SHEEN WITH DOT BELOW */
  0x06FF, 0x06FF, /* ARABIC LETTER HEH WITH INVERTED V */
  0x0710, 0x0710, /* SYRIAC LETTER ALAPH */
  0x0712, 0x072F, /* SYRIAC LETTER BETH */
  0x074D, 0x07A5, /* SYRIAC LETTER SOGDIAN ZHAIN */
  0x07B1, 0x07B1, /* THAANA LETTER NAA */
  0x07CA, 0x07EA, /* NKO LETTER A */
  0x0800, 0x0815, /* SAMARITAN LETTER ALAF */
  0x0840, 0x0858, /* MANDAIC LETTER HALQA */
  0x08A0, 0x08B4, /* ARABIC LETTER BEH WITH SMALL V BELOW */
  0x0900, 0x0963, /* DEVANAGARI LETTER (CHECKED)*/
  0x0970, 0x097F, /* DEVANAGARI LETTER (CHECKED)*/
  0x0980, 0x09E5, /* BENGALI LETTER (CHECKED)*/
  0x09F0, 0x09FF, /* BENGALI LETTER (CHECKED)*/
  0x0A00, 0x0A65, /* GURMUKHI LETTER (CHECKED)*/
  0x0A70, 0x0A7F, /* GURMUKHI LETTER (CHECKED)*/
  0x0A80, 0x0AE5, /* GUJARATI LETTER (CHECKED)*/
  0x0AF0, 0x0AFF, /* GUJARATI LETTER (CHECKED)*/
  0x0B00, 0x0B65, /* ORIYA LETTER (CHECKED)*/
  0x0B70, 0x0B7F, /* ORIYA LETTER (CHECKED)*/
  0x0B80, 0x0BE5, /* TAMIL LETTER (CHECKED)*/
  0x0BF0, 0x0BFF, /* TAMIL LETTER (CHECKED)*/
  0x0C00, 0x0C65, /* TELUGU LETTER (CHECKED)*/
  0x0C70, 0x0C7F, /* TELUGU LETTER (CHECKED)*/
  0x0C80, 0x0CE5, /* KANNADA LETTER (CHECKED)*/
  0x0CF0, 0x0CFF, /* KANNADA LETTER (CHECKED)*/
  0x0D00, 0x0D65, /* MALAYALAM LETTER (CHECKED)*/
  0x0D70, 0x0D7F, /* MALAYALAM LETTER (CHECKED)*/
  0x0D85, 0x0DC6, /* SINHALA LETTER AYANNA */
  0x0E01, 0x0E30, /* THAI CHARACTER KO KAI */
  0x0E32, 0x0E33, /* THAI CHARACTER SARA AA */
  0x0E40, 0x0E45, /* THAI CHARACTER SARA E */
  0x0E81, 0x0EB0, /* LAO LETTER KO */
  0x0EB2, 0x0EB3, /* LAO VOWEL SIGN AA */
  0x0EBD, 0x0EC4, /* LAO SEMIVOWEL SIGN NYO */
  0x0EDC, 0x0F00, /* LAO HO NO */
  0x0F40, 0x0F6C, /* TIBETAN LETTER KA */
  0x0F88, 0x0F8C, /* TIBETAN SIGN LCE TSA CAN */
  0x1000, 0x102A, /* MYANMAR LETTER KA */
  0x103F, 0x103F, /* MYANMAR LETTER GREAT SA */
  0x1050, 0x1055, /* MYANMAR LETTER SHA */
  0x105A, 0x105D, /* MYANMAR LETTER MON NGA */
  0x1061, 0x1061, /* MYANMAR LETTER SGAW KAREN SHA */
  0x1065, 0x1066, /* MYANMAR LETTER WESTERN PWO KAREN THA */
  0x106E, 0x1070, /* MYANMAR LETTER EASTERN PWO KAREN NNA */
  0x1075, 0x1081, /* MYANMAR LETTER SHAN KA */
  0x108E, 0x108E, /* MYANMAR LETTER RUMAI PALAUNG FA */
  0x10D0, 0x10FA, /* GEORGIAN LETTER AN */
  0x10FD, 0x135A, /* GEORGIAN LETTER AEN */
  0x1380, 0x138F, /* ETHIOPIC SYLLABLE SEBATBEIT MWA */
  0x1401, 0x166C, /* CANADIAN SYLLABICS E */
  0x166F, 0x167F, /* CANADIAN SYLLABICS QAI */
  0x1681, 0x169A, /* OGHAM LETTER BEITH */
  0x16A0, 0x16EA, /* RUNIC LETTER FEHU FEOH FE F */
  0x16F1, 0x1711, /* RUNIC LETTER K */
  0x1720, 0x1731, /* HANUNOO LETTER A */
  0x1740, 0x1751, /* BUHID LETTER A */
  0x1760, 0x1770, /* TAGBANWA LETTER A */
  0x1780, 0x17B3, /* KHMER LETTER KA */
  0x17DC, 0x17DC, /* KHMER SIGN AVAKRAHASANYA */
  0x1820, 0x1842, /* MONGOLIAN LETTER A */
  0x1844, 0x18A8, /* MONGOLIAN LETTER TODO E */
  0x18AA, 0x191E, /* MONGOLIAN LETTER MANCHU ALI GALI LHA */
  0x1950, 0x19C9, /* TAI LE LETTER KA */
  0x1A00, 0x1A16, /* BUGINESE LETTER KA */
  0x1A20, 0x1A54, /* TAI THAM LETTER HIGH KA */
  0x1B05, 0x1B33, /* BALINESE LETTER AKARA */
  0x1B45, 0x1B4B, /* BALINESE LETTER KAF SASAK */
  0x1B83, 0x1BA0, /* SUNDANESE LETTER A */
  0x1BAE, 0x1BAF, /* SUNDANESE LETTER KHA */
  0x1BBA, 0x1BE5, /* SUNDANESE AVAGRAHA */
  0x1C00, 0x1C23, /* LEPCHA LETTER KA */
  0x1C4D, 0x1C4F, /* LEPCHA LETTER TTA */
  0x1C5A, 0x1C77, /* OL CHIKI LETTER LA */
  0x1CE9, 0x1CEC, /* VEDIC SIGN ANUSVARA ANTARGOMUKHA */
  0x1CEE, 0x1CF1, /* VEDIC SIGN HEXIFORM LONG ANUSVARA */
  0x1CF5, 0x1CF6, /* VEDIC SIGN JIHVAMULIYA */
  0x2135, 0x2138, /* ALEF SYMBOL */
  0x2D30, 0x2D67, /* TIFINAGH LETTER YA */
  0x2D80, 0x2DDE, /* ETHIOPIC SYLLABLE LOA */
  0x3006, 0x3006, /* IDEOGRAPHIC CLOSING MARK */
  0x303C, 0x303C, /* MASU MARK */
  0x3041, 0x3096, /* HIRAGANA LETTER SMALL A */
  0x309F, 0x309F, /* HIRAGANA DIGRAPH YORI */
  0x30A1, 0x30FA, /* KATAKANA LETTER SMALL A */
  0x30FF, 0x318E, /* KATAKANA DIGRAPH KOTO */
  0x31A0, 0x31BA, /* BOPOMOFO LETTER BU */
  0x31F0, 0x31FF, /* KATAKANA LETTER SMALL KU */
  0x3400, 0x4DB5, /* <CJK Ideograph Extension A, First> */
  0x4E00, 0xA014, /* <CJK Ideograph, First> */
  0xA016, 0xA48C, /* YI SYLLABLE BIT */
  0xA4D0, 0xA4F7, /* LISU LETTER BA */
  0xA500, 0xA60B, /* VAI SYLLABLE EE */
  0xA610, 0xA61F, /* VAI SYLLABLE NDOLE FA */
  0xA62A, 0xA62B, /* VAI SYLLABLE NDOLE MA */
  0xA66E, 0xA66E, /* CYRILLIC LETTER MULTIOCULAR O */
  0xA6A0, 0xA6E5, /* BAMUM LETTER A */
  0xA78F, 0xA78F, /* LATIN LETTER SINOLOGICAL DOT */
  0xA7F7, 0xA7F7, /* LATIN EPIGRAPHIC LETTER SIDEWAYS I */
  0xA7FB, 0xA801, /* LATIN EPIGRAPHIC LETTER REVERSED F */
  0xA803, 0xA805, /* SYLOTI NAGRI LETTER U */
  0xA807, 0xA80A, /* SYLOTI NAGRI LETTER KO */
  0xA80C, 0xA822, /* SYLOTI NAGRI LETTER CO */
  0xA840, 0xA873, /* PHAGS-PA LETTER KA */
  0xA882, 0xA8B3, /* SAURASHTRA LETTER A */
  0xA8F2, 0xA8F7, /* DEVANAGARI SIGN SPACING CANDRABINDU */
  0xA8FB, 0xA8FB, /* DEVANAGARI HEADSTROKE */
  0xA8FD, 0xA8FD, /* DEVANAGARI JAIN OM */
  0xA90A, 0xA925, /* KAYAH LI LETTER KA */
  0xA930, 0xA946, /* REJANG LETTER KA */
  0xA960, 0xA97C, /* HANGUL CHOSEONG TIKEUT-MIEUM */
  0xA984, 0xA9B2, /* JAVANESE LETTER A */
  0xA9E0, 0xA9E4, /* MYANMAR LETTER SHAN GHA */
  0xA9E7, 0xA9EF, /* MYANMAR LETTER TAI LAING NYA */
  0xA9FA, 0xAA28, /* MYANMAR LETTER TAI LAING LLA */
  0xAA40, 0xAA42, /* CHAM LETTER FINAL K */
  0xAA44, 0xAA4B, /* CHAM LETTER FINAL CH */
  0xAA60, 0xAA6F, /* MYANMAR LETTER KHAMTI GA */
  0xAA71, 0xAA76, /* MYANMAR LETTER KHAMTI XA */
  0xAA7A, 0xAA7A, /* MYANMAR LETTER AITON RA */
  0xAA7E, 0xAAAF, /* MYANMAR LETTER SHWE PALAUNG CHA */
  0xAAB1, 0xAAB1, /* TAI VIET VOWEL AA */
  0xAAB5, 0xAAB6, /* TAI VIET VOWEL E */
  0xAAB9, 0xAABD, /* TAI VIET VOWEL UEA */
  0xAAC0, 0xAAC0, /* TAI VIET TONE MAI NUENG */
  0xAAC2, 0xAADC, /* TAI VIET TONE MAI SONG */
  0xAAE0, 0xAAEA, /* MEETEI MAYEK LETTER E */
  0xAAF2, 0xAAF2, /* MEETEI MAYEK ANJI */
  0xAB01, 0xAB2E, /* ETHIOPIC SYLLABLE TTHU */
  0xABC0, 0xABE2, /* MEETEI MAYEK LETTER KOK */
  0xAC00, 0xD7FB, /* <Hangul Syllable, First> */
  0xF900, 0xFAD9, /* CJK COMPATIBILITY IDEOGRAPH-F900 */
  0xFB1D, 0xFB1D, /* HEBREW LETTER YOD WITH HIRIQ */
  0xFB1F, 0xFB28, /* HEBREW LIGATURE YIDDISH YOD YOD PATAH */
  0xFB2A, 0xFBB1, /* HEBREW LETTER SHIN WITH SHIN DOT */
  0xFBD3, 0xFD3D, /* ARABIC LETTER NG ISOLATED FORM */
  0xFD50, 0xFDFB, /* ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM */
  0xFE70, 0xFEFC, /* ARABIC FATHATAN ISOLATED FORM */
  0xFF66, 0xFF6F, /* HALFWIDTH KATAKANA LETTER WO */
  0xFF71, 0xFF9D, /* HALFWIDTH KATAKANA LETTER A */
  0xFFA0, 0xFFDC, /* HALFWIDTH HANGUL FILLER */
  0x10000, 0x100FA, /* LINEAR B SYLLABLE B008 A */
  0x10280, 0x102D0, /* LYCIAN LETTER A */
  0x10300, 0x1031F, /* OLD ITALIC LETTER A */
  0x10330, 0x10340, /* GOTHIC LETTER AHSA */
  0x10342, 0x10349, /* GOTHIC LETTER RAIDA */
  0x10350, 0x10375, /* OLD PERMIC LETTER AN */
  0x10380, 0x1039D, /* UGARITIC LETTER ALPA */
  0x103A0, 0x103CF, /* OLD PERSIAN SIGN A */
  0x10450, 0x1049D, /* SHAVIAN LETTER PEEP */
  0x10500, 0x10563, /* ELBASAN LETTER A */
  0x10600, 0x10855, /* LINEAR A SIGN AB001 */
  0x10860, 0x10876, /* PALMYRENE LETTER ALEPH */
  0x10880, 0x1089E, /* NABATAEAN LETTER FINAL ALEPH */
  0x108E0, 0x108F5, /* HATRAN LETTER ALEPH */
  0x10900, 0x10915, /* PHOENICIAN LETTER ALF */
  0x10920, 0x10939, /* LYDIAN LETTER A */
  0x10980, 0x109B7, /* MEROITIC HIEROGLYPHIC LETTER A */
  0x109BE, 0x109BF, /* MEROITIC CURSIVE LOGOGRAM RMT */
  0x10A00, 0x10A00, /* KHAROSHTHI LETTER A */
  0x10A10, 0x10A33, /* KHAROSHTHI LETTER KA */
  0x10A60, 0x10A7C, /* OLD SOUTH ARABIAN LETTER HE */
  0x10A80, 0x10A9C, /* OLD NORTH ARABIAN LETTER HEH */
  0x10AC0, 0x10AC7, /* MANICHAEAN LETTER ALEPH */
  0x10AC9, 0x10AE4, /* MANICHAEAN LETTER ZAYIN */
  0x10B00, 0x10B35, /* AVESTAN LETTER A */
  0x10B40, 0x10B55, /* INSCRIPTIONAL PARTHIAN LETTER ALEPH */
  0x10B60, 0x10B72, /* INSCRIPTIONAL PAHLAVI LETTER ALEPH */
  0x10B80, 0x10B91, /* PSALTER PAHLAVI LETTER ALEPH */
  0x10C00, 0x10C48, /* OLD TURKIC LETTER ORKHON A */
  0x11003, 0x11037, /* BRAHMI SIGN JIHVAMULIYA */
  0x11083, 0x110AF, /* KAITHI LETTER A */
  0x110D0, 0x110E8, /* SORA SOMPENG LETTER SAH */
  0x11103, 0x11126, /* CHAKMA LETTER AA */
  0x11150, 0x11172, /* MAHAJANI LETTER A */
  0x11176, 0x11176, /* MAHAJANI LIGATURE SHRI */
  0x11183, 0x111B2, /* SHARADA LETTER A */
  0x111C1, 0x111C4, /* SHARADA SIGN AVAGRAHA */
  0x111DA, 0x111DA, /* SHARADA EKAM */
  0x111DC, 0x111DC, /* SHARADA HEADSTROKE */
  0x11200, 0x1122B, /* KHOJKI LETTER A */
  0x11280, 0x112A8, /* MULTANI LETTER A */
  0x112B0, 0x112DE, /* KHUDAWADI LETTER A */
  0x11305, 0x11339, /* GRANTHA LETTER A */
  0x1133D, 0x1133D, /* GRANTHA SIGN AVAGRAHA */
  0x11350, 0x11350, /* GRANTHA OM */
  0x1135D, 0x11361, /* GRANTHA SIGN PLUTA */
  0x11480, 0x114AF, /* TIRHUTA ANJI */
  0x114C4, 0x114C5, /* TIRHUTA SIGN AVAGRAHA */
  0x114C7, 0x114C7, /* TIRHUTA OM */
  0x11580, 0x115AE, /* SIDDHAM LETTER A */
  0x115D8, 0x115DB, /* SIDDHAM LETTER THREE-CIRCLE ALTERNATE I */
  0x11600, 0x1162F, /* MODI LETTER A */
  0x11644, 0x11644, /* MODI SIGN HUVA */
  0x11680, 0x116AA, /* TAKRI LETTER A */
  0x11700, 0x11719, /* AHOM LETTER KA */
  0x118FF, 0x12399, /* WARANG CITI OM */
  0x12480, 0x16A5E, /* CUNEIFORM SIGN AB TIMES NUN TENU */
  0x16AD0, 0x16AED, /* BASSA VAH LETTER ENNI */
  0x16B00, 0x16B2F, /* PAHAWH HMONG VOWEL KEEB */
  0x16B63, 0x16F50, /* PAHAWH HMONG SIGN VOS LUB */
  0x1B000, 0x1BC99, /* KATAKANA LETTER ARCHAIC E */
  0x1E800, 0x1E8C4, /* MENDE KIKAKUI SYLLABLE M001 KI */
  0x1EE00, 0x1EEBB, /* ARABIC MATHEMATICAL ALEF */
  0x20000, 0x2FA1D, /* <CJK Ideograph Extension B, First> */
  0x01C5, 0x01C5, /* LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON */
  0x01C8, 0x01C8, /* LATIN CAPITAL LETTER L WITH SMALL LETTER J */
  0x01CB, 0x01CB, /* LATIN CAPITAL LETTER N WITH SMALL LETTER J */
  0x01F2, 0x01F2, /* LATIN CAPITAL LETTER D WITH SMALL LETTER Z */
  0x1F88, 0x1F8F, /* GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI */
  0x1F98, 0x1F9F, /* GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI */
  0x1FA8, 0x1FAF, /* GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI */
  0x1FBC, 0x1FBC, /* GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI */
  0x1FCC, 0x1FCC, /* GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI */
  0x1FFC, 0x1FFC, /* GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI */
  0x0041, 0x005A, /* LATIN CAPITAL LETTER A */
  0x00C0, 0x00D6, /* LATIN CAPITAL LETTER A WITH GRAVE */
  0x00D8, 0x00DE, /* LATIN CAPITAL LETTER O WITH STROKE */
  0x0100, 0x0100, /* LATIN CAPITAL LETTER A WITH MACRON */
  0x0102, 0x0102, /* LATIN CAPITAL LETTER A WITH BREVE */
  0x0104, 0x0104, /* LATIN CAPITAL LETTER A WITH OGONEK */
  0x0106, 0x0106, /* LATIN CAPITAL LETTER C WITH ACUTE */
  0x0108, 0x0108, /* LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
  0x010A, 0x010A, /* LATIN CAPITAL LETTER C WITH DOT ABOVE */
  0x010C, 0x010C, /* LATIN CAPITAL LETTER C WITH CARON */
  0x010E, 0x010E, /* LATIN CAPITAL LETTER D WITH CARON */
  0x0110, 0x0110, /* LATIN CAPITAL LETTER D WITH STROKE */
  0x0112, 0x0112, /* LATIN CAPITAL LETTER E WITH MACRON */
  0x0114, 0x0114, /* LATIN CAPITAL LETTER E WITH BREVE */
  0x0116, 0x0116, /* LATIN CAPITAL LETTER E WITH DOT ABOVE */
  0x0118, 0x0118, /* LATIN CAPITAL LETTER E WITH OGONEK */
  0x011A, 0x011A, /* LATIN CAPITAL LETTER E WITH CARON */
  0x011C, 0x011C, /* LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
  0x011E, 0x011E, /* LATIN CAPITAL LETTER G WITH BREVE */
  0x0120, 0x0120, /* LATIN CAPITAL LETTER G WITH DOT ABOVE */
  0x0122, 0x0122, /* LATIN CAPITAL LETTER G WITH CEDILLA */
  0x0124, 0x0124, /* LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
  0x0126, 0x0126, /* LATIN CAPITAL LETTER H WITH STROKE */
  0x0128, 0x0128, /* LATIN CAPITAL LETTER I WITH TILDE */
  0x012A, 0x012A, /* LATIN CAPITAL LETTER I WITH MACRON */
  0x012C, 0x012C, /* LATIN CAPITAL LETTER I WITH BREVE */
  0x012E, 0x012E, /* LATIN CAPITAL LETTER I WITH OGONEK */
  0x0130, 0x0130, /* LATIN CAPITAL LETTER I WITH DOT ABOVE */
  0x0132, 0x0132, /* LATIN CAPITAL LIGATURE IJ */
  0x0134, 0x0134, /* LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
  0x0136, 0x0136, /* LATIN CAPITAL LETTER K WITH CEDILLA */
  0x0139, 0x0139, /* LATIN CAPITAL LETTER L WITH ACUTE */
  0x013B, 0x013B, /* LATIN CAPITAL LETTER L WITH CEDILLA */
  0x013D, 0x013D, /* LATIN CAPITAL LETTER L WITH CARON */
  0x013F, 0x013F, /* LATIN CAPITAL LETTER L WITH MIDDLE DOT */
  0x0141, 0x0141, /* LATIN CAPITAL LETTER L WITH STROKE */
  0x0143, 0x0143, /* LATIN CAPITAL LETTER N WITH ACUTE */
  0x0145, 0x0145, /* LATIN CAPITAL LETTER N WITH CEDILLA */
  0x0147, 0x0147, /* LATIN CAPITAL LETTER N WITH CARON */
  0x014A, 0x014A, /* LATIN CAPITAL LETTER ENG */
  0x014C, 0x014C, /* LATIN CAPITAL LETTER O WITH MACRON */
  0x014E, 0x014E, /* LATIN CAPITAL LETTER O WITH BREVE */
  0x0150, 0x0150, /* LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
  0x0152, 0x0152, /* LATIN CAPITAL LIGATURE OE */
  0x0154, 0x0154, /* LATIN CAPITAL LETTER R WITH ACUTE */
  0x0156, 0x0156, /* LATIN CAPITAL LETTER R WITH CEDILLA */
  0x0158, 0x0158, /* LATIN CAPITAL LETTER R WITH CARON */
  0x015A, 0x015A, /* LATIN CAPITAL LETTER S WITH ACUTE */
  0x015C, 0x015C, /* LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
  0x015E, 0x015E, /* LATIN CAPITAL LETTER S WITH CEDILLA */
  0x0160, 0x0160, /* LATIN CAPITAL LETTER S WITH CARON */
  0x0162, 0x0162, /* LATIN CAPITAL LETTER T WITH CEDILLA */
  0x0164, 0x0164, /* LATIN CAPITAL LETTER T WITH CARON */
  0x0166, 0x0166, /* LATIN CAPITAL LETTER T WITH STROKE */
  0x0168, 0x0168, /* LATIN CAPITAL LETTER U WITH TILDE */
  0x016A, 0x016A, /* LATIN CAPITAL LETTER U WITH MACRON */
  0x016C, 0x016C, /* LATIN CAPITAL LETTER U WITH BREVE */
  0x016E, 0x016E, /* LATIN CAPITAL LETTER U WITH RING ABOVE */
  0x0170, 0x0170, /* LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
  0x0172, 0x0172, /* LATIN CAPITAL LETTER U WITH OGONEK */
  0x0174, 0x0174, /* LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
  0x0176, 0x0176, /* LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
  0x0178, 0x0179, /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
  0x017B, 0x017B, /* LATIN CAPITAL LETTER Z WITH DOT ABOVE */
  0x017D, 0x017D, /* LATIN CAPITAL LETTER Z WITH CARON */
  0x0181, 0x0182, /* LATIN CAPITAL LETTER B WITH HOOK */
  0x0184, 0x0184, /* LATIN CAPITAL LETTER TONE SIX */
  0x0186, 0x0187, /* LATIN CAPITAL LETTER OPEN O */
  0x0189, 0x018B, /* LATIN CAPITAL LETTER AFRICAN D */
  0x018E, 0x0191, /* LATIN CAPITAL LETTER REVERSED E */
  0x0193, 0x0194, /* LATIN CAPITAL LETTER G WITH HOOK */
  0x0196, 0x0198, /* LATIN CAPITAL LETTER IOTA */
  0x019C, 0x019D, /* LATIN CAPITAL LETTER TURNED M */
  0x019F, 0x01A0, /* LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
  0x01A2, 0x01A2, /* LATIN CAPITAL LETTER OI */
  0x01A4, 0x01A4, /* LATIN CAPITAL LETTER P WITH HOOK */
  0x01A6, 0x01A7, /* LATIN LETTER YR */
  0x01A9, 0x01A9, /* LATIN CAPITAL LETTER ESH */
  0x01AC, 0x01AC, /* LATIN CAPITAL LETTER T WITH HOOK */
  0x01AE, 0x01AF, /* LATIN CAPITAL LETTER T WITH RETROFLEX HOOK */
  0x01B1, 0x01B3, /* LATIN CAPITAL LETTER UPSILON */
  0x01B5, 0x01B5, /* LATIN CAPITAL LETTER Z WITH STROKE */
  0x01B7, 0x01B8, /* LATIN CAPITAL LETTER EZH */
  0x01BC, 0x01BC, /* LATIN CAPITAL LETTER TONE FIVE */
  0x01C4, 0x01C4, /* LATIN CAPITAL LETTER DZ WITH CARON */
  0x01C7, 0x01C7, /* LATIN CAPITAL LETTER LJ */
  0x01CA, 0x01CA, /* LATIN CAPITAL LETTER NJ */
  0x01CD, 0x01CD, /* LATIN CAPITAL LETTER A WITH CARON */
  0x01CF, 0x01CF, /* LATIN CAPITAL LETTER I WITH CARON */
  0x01D1, 0x01D1, /* LATIN CAPITAL LETTER O WITH CARON */
  0x01D3, 0x01D3, /* LATIN CAPITAL LETTER U WITH CARON */
  0x01D5, 0x01D5, /* LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON */
  0x01D7, 0x01D7, /* LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE */
  0x01D9, 0x01D9, /* LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON */
  0x01DB, 0x01DB, /* LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE */
  0x01DE, 0x01DE, /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */
  0x01E0, 0x01E0, /* LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON */
  0x01E2, 0x01E2, /* LATIN CAPITAL LETTER AE WITH MACRON */
  0x01E4, 0x01E4, /* LATIN CAPITAL LETTER G WITH STROKE */
  0x01E6, 0x01E6, /* LATIN CAPITAL LETTER G WITH CARON */
  0x01E8, 0x01E8, /* LATIN CAPITAL LETTER K WITH CARON */
  0x01EA, 0x01EA, /* LATIN CAPITAL LETTER O WITH OGONEK */
  0x01EC, 0x01EC, /* LATIN CAPITAL LETTER O WITH OGONEK AND MACRON */
  0x01EE, 0x01EE, /* LATIN CAPITAL LETTER EZH WITH CARON */
  0x01F1, 0x01F1, /* LATIN CAPITAL LETTER DZ */
  0x01F4, 0x01F4, /* LATIN CAPITAL LETTER G WITH ACUTE */
  0x01F6, 0x01F8, /* LATIN CAPITAL LETTER HWAIR */
  0x01FA, 0x01FA, /* LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE */
  0x01FC, 0x01FC, /* LATIN CAPITAL LETTER AE WITH ACUTE */
  0x01FE, 0x01FE, /* LATIN CAPITAL LETTER O WITH STROKE AND ACUTE */
  0x0200, 0x0200, /* LATIN CAPITAL LETTER A WITH DOUBLE GRAVE */
  0x0202, 0x0202, /* LATIN CAPITAL LETTER A WITH INVERTED BREVE */
  0x0204, 0x0204, /* LATIN CAPITAL LETTER E WITH DOUBLE GRAVE */
  0x0206, 0x0206, /* LATIN CAPITAL LETTER E WITH INVERTED BREVE */
  0x0208, 0x0208, /* LATIN CAPITAL LETTER I WITH DOUBLE GRAVE */
  0x020A, 0x020A, /* LATIN CAPITAL LETTER I WITH INVERTED BREVE */
  0x020C, 0x020C, /* LATIN CAPITAL LETTER O WITH DOUBLE GRAVE */
  0x020E, 0x020E, /* LATIN CAPITAL LETTER O WITH INVERTED BREVE */
  0x0210, 0x0210, /* LATIN CAPITAL LETTER R WITH DOUBLE GRAVE */
  0x0212, 0x0212, /* LATIN CAPITAL LETTER R WITH INVERTED BREVE */
  0x0214, 0x0214, /* LATIN CAPITAL LETTER U WITH DOUBLE GRAVE */
  0x0216, 0x0216, /* LATIN CAPITAL LETTER U WITH INVERTED BREVE */
  0x0218, 0x0218, /* LATIN CAPITAL LETTER S WITH COMMA BELOW */
  0x021A, 0x021A, /* LATIN CAPITAL LETTER T WITH COMMA BELOW */
  0x021C, 0x021C, /* LATIN CAPITAL LETTER YOGH */
  0x021E, 0x021E, /* LATIN CAPITAL LETTER H WITH CARON */
  0x0220, 0x0220, /* LATIN CAPITAL LETTER N WITH LONG RIGHT LEG */
  0x0222, 0x0222, /* LATIN CAPITAL LETTER OU */
  0x0224, 0x0224, /* LATIN CAPITAL LETTER Z WITH HOOK */
  0x0226, 0x0226, /* LATIN CAPITAL LETTER A WITH DOT ABOVE */
  0x0228, 0x0228, /* LATIN CAPITAL LETTER E WITH CEDILLA */
  0x022A, 0x022A, /* LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON */
  0x022C, 0x022C, /* LATIN CAPITAL LETTER O WITH TILDE AND MACRON */
  0x022E, 0x022E, /* LATIN CAPITAL LETTER O WITH DOT ABOVE */
  0x0230, 0x0230, /* LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON */
  0x0232, 0x0232, /* LATIN CAPITAL LETTER Y WITH MACRON */
  0x023A, 0x023B, /* LATIN CAPITAL LETTER A WITH STROKE */
  0x023D, 0x023E, /* LATIN CAPITAL LETTER L WITH BAR */
  0x0241, 0x0241, /* LATIN CAPITAL LETTER GLOTTAL STOP */
  0x0243, 0x0246, /* LATIN CAPITAL LETTER B WITH STROKE */
  0x0248, 0x0248, /* LATIN CAPITAL LETTER J WITH STROKE */
  0x024A, 0x024A, /* LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL */
  0x024C, 0x024C, /* LATIN CAPITAL LETTER R WITH STROKE */
  0x024E, 0x024E, /* LATIN CAPITAL LETTER Y WITH STROKE */
  0x0370, 0x0370, /* GREEK CAPITAL LETTER HETA */
  0x0372, 0x0372, /* GREEK CAPITAL LETTER ARCHAIC SAMPI */
  0x0376, 0x0376, /* GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA */
  0x037F, 0x037F, /* GREEK CAPITAL LETTER YOT */
  0x0386, 0x0386, /* GREEK CAPITAL LETTER ALPHA WITH TONOS */
  0x0388, 0x038F, /* GREEK CAPITAL LETTER EPSILON WITH TONOS */
  0x0391, 0x03AB, /* GREEK CAPITAL LETTER ALPHA */
  0x03CF, 0x03CF, /* GREEK CAPITAL KAI SYMBOL */
  0x03D2, 0x03D4, /* GREEK UPSILON WITH HOOK SYMBOL */
  0x03D8, 0x03D8, /* GREEK LETTER ARCHAIC KOPPA */
  0x03DA, 0x03DA, /* GREEK LETTER STIGMA */
  0x03DC, 0x03DC, /* GREEK LETTER DIGAMMA */
  0x03DE, 0x03DE, /* GREEK LETTER KOPPA */
  0x03E0, 0x03E0, /* GREEK LETTER SAMPI */
  0x03E2, 0x03E2, /* COPTIC CAPITAL LETTER SHEI */
  0x03E4, 0x03E4, /* COPTIC CAPITAL LETTER FEI */
  0x03E6, 0x03E6, /* COPTIC CAPITAL LETTER KHEI */
  0x03E8, 0x03E8, /* COPTIC CAPITAL LETTER HORI */
  0x03EA, 0x03EA, /* COPTIC CAPITAL LETTER GANGIA */
  0x03EC, 0x03EC, /* COPTIC CAPITAL LETTER SHIMA */
  0x03EE, 0x03EE, /* COPTIC CAPITAL LETTER DEI */
  0x03F4, 0x03F4, /* GREEK CAPITAL THETA SYMBOL */
  0x03F7, 0x03F7, /* GREEK CAPITAL LETTER SHO */
  0x03F9, 0x03FA, /* GREEK CAPITAL LUNATE SIGMA SYMBOL */
  0x03FD, 0x042F, /* GREEK CAPITAL REVERSED LUNATE SIGMA SYMBOL */
  0x0460, 0x0460, /* CYRILLIC CAPITAL LETTER OMEGA */
  0x0462, 0x0462, /* CYRILLIC CAPITAL LETTER YAT */
  0x0464, 0x0464, /* CYRILLIC CAPITAL LETTER IOTIFIED E */
  0x0466, 0x0466, /* CYRILLIC CAPITAL LETTER LITTLE YUS */
  0x0468, 0x0468, /* CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS */
  0x046A, 0x046A, /* CYRILLIC CAPITAL LETTER BIG YUS */
  0x046C, 0x046C, /* CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS */
  0x046E, 0x046E, /* CYRILLIC CAPITAL LETTER KSI */
  0x0470, 0x0470, /* CYRILLIC CAPITAL LETTER PSI */
  0x0472, 0x0472, /* CYRILLIC CAPITAL LETTER FITA */
  0x0474, 0x0474, /* CYRILLIC CAPITAL LETTER IZHITSA */
  0x0476, 0x0476, /* CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT */
  0x0478, 0x0478, /* CYRILLIC CAPITAL LETTER UK */
  0x047A, 0x047A, /* CYRILLIC CAPITAL LETTER ROUND OMEGA */
  0x047C, 0x047C, /* CYRILLIC CAPITAL LETTER OMEGA WITH TITLO */
  0x047E, 0x047E, /* CYRILLIC CAPITAL LETTER OT */
  0x0480, 0x0480, /* CYRILLIC CAPITAL LETTER KOPPA */
  0x048A, 0x048A, /* CYRILLIC CAPITAL LETTER SHORT I WITH TAIL */
  0x048C, 0x048C, /* CYRILLIC CAPITAL LETTER SEMISOFT SIGN */
  0x048E, 0x048E, /* CYRILLIC CAPITAL LETTER ER WITH TICK */
  0x0490, 0x0490, /* CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
  0x0492, 0x0492, /* CYRILLIC CAPITAL LETTER GHE WITH STROKE */
  0x0494, 0x0494, /* CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK */
  0x0496, 0x0496, /* CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
  0x0498, 0x0498, /* CYRILLIC CAPITAL LETTER ZE WITH DESCENDER */
  0x049A, 0x049A, /* CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
  0x049C, 0x049C, /* CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
  0x049E, 0x049E, /* CYRILLIC CAPITAL LETTER KA WITH STROKE */
  0x04A0, 0x04A0, /* CYRILLIC CAPITAL LETTER BASHKIR KA */
  0x04A2, 0x04A2, /* CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
  0x04A4, 0x04A4, /* CYRILLIC CAPITAL LIGATURE EN GHE */
  0x04A6, 0x04A6, /* CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK */
  0x04A8, 0x04A8, /* CYRILLIC CAPITAL LETTER ABKHASIAN HA */
  0x04AA, 0x04AA, /* CYRILLIC CAPITAL LETTER ES WITH DESCENDER */
  0x04AC, 0x04AC, /* CYRILLIC CAPITAL LETTER TE WITH DESCENDER */
  0x04AE, 0x04AE, /* CYRILLIC CAPITAL LETTER STRAIGHT U */
  0x04B0, 0x04B0, /* CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
  0x04B2, 0x04B2, /* CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
  0x04B4, 0x04B4, /* CYRILLIC CAPITAL LIGATURE TE TSE */
  0x04B6, 0x04B6, /* CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
  0x04B8, 0x04B8, /* CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
  0x04BA, 0x04BA, /* CYRILLIC CAPITAL LETTER SHHA */
  0x04BC, 0x04BC, /* CYRILLIC CAPITAL LETTER ABKHASIAN CHE */
  0x04BE, 0x04BE, /* CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER */
  0x04C0, 0x04C1, /* CYRILLIC LETTER PALOCHKA */
  0x04C3, 0x04C3, /* CYRILLIC CAPITAL LETTER KA WITH HOOK */
  0x04C5, 0x04C5, /* CYRILLIC CAPITAL LETTER EL WITH TAIL */
  0x04C7, 0x04C7, /* CYRILLIC CAPITAL LETTER EN WITH HOOK */
  0x04C9, 0x04C9, /* CYRILLIC CAPITAL LETTER EN WITH TAIL */
  0x04CB, 0x04CB, /* CYRILLIC CAPITAL LETTER KHAKASSIAN CHE */
  0x04CD, 0x04CD, /* CYRILLIC CAPITAL LETTER EM WITH TAIL */
  0x04D0, 0x04D0, /* CYRILLIC CAPITAL LETTER A WITH BREVE */
  0x04D2, 0x04D2, /* CYRILLIC CAPITAL LETTER A WITH DIAERESIS */
  0x04D4, 0x04D4, /* CYRILLIC CAPITAL LIGATURE A IE */
  0x04D6, 0x04D6, /* CYRILLIC CAPITAL LETTER IE WITH BREVE */
  0x04D8, 0x04D8, /* CYRILLIC CAPITAL LETTER SCHWA */
  0x04DA, 0x04DA, /* CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS */
  0x04DC, 0x04DC, /* CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS */
  0x04DE, 0x04DE, /* CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS */
  0x04E0, 0x04E0, /* CYRILLIC CAPITAL LETTER ABKHASIAN DZE */
  0x04E2, 0x04E2, /* CYRILLIC CAPITAL LETTER I WITH MACRON */
  0x04E4, 0x04E4, /* CYRILLIC CAPITAL LETTER I WITH DIAERESIS */
  0x04E6, 0x04E6, /* CYRILLIC CAPITAL LETTER O WITH DIAERESIS */
  0x04E8, 0x04E8, /* CYRILLIC CAPITAL LETTER BARRED O */
  0x04EA, 0x04EA, /* CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS */
  0x04EC, 0x04EC, /* CYRILLIC CAPITAL LETTER E WITH DIAERESIS */
  0x04EE, 0x04EE, /* CYRILLIC CAPITAL LETTER U WITH MACRON */
  0x04F0, 0x04F0, /* CYRILLIC CAPITAL LETTER U WITH DIAERESIS */
  0x04F2, 0x04F2, /* CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE */
  0x04F4, 0x04F4, /* CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS */
  0x04F6, 0x04F6, /* CYRILLIC CAPITAL LETTER GHE WITH DESCENDER */
  0x04F8, 0x04F8, /* CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS */
  0x04FA, 0x04FA, /* CYRILLIC CAPITAL LETTER GHE WITH STROKE AND HOOK */
  0x04FC, 0x04FC, /* CYRILLIC CAPITAL LETTER HA WITH HOOK */
  0x04FE, 0x04FE, /* CYRILLIC CAPITAL LETTER HA WITH STROKE */
  0x0500, 0x0500, /* CYRILLIC CAPITAL LETTER KOMI DE */
  0x0502, 0x0502, /* CYRILLIC CAPITAL LETTER KOMI DJE */
  0x0504, 0x0504, /* CYRILLIC CAPITAL LETTER KOMI ZJE */
  0x0506, 0x0506, /* CYRILLIC CAPITAL LETTER KOMI DZJE */
  0x0508, 0x0508, /* CYRILLIC CAPITAL LETTER KOMI LJE */
  0x050A, 0x050A, /* CYRILLIC CAPITAL LETTER KOMI NJE */
  0x050C, 0x050C, /* CYRILLIC CAPITAL LETTER KOMI SJE */
  0x050E, 0x050E, /* CYRILLIC CAPITAL LETTER KOMI TJE */
  0x0510, 0x0510, /* CYRILLIC CAPITAL LETTER REVERSED ZE */
  0x0512, 0x0512, /* CYRILLIC CAPITAL LETTER EL WITH HOOK */
  0x0514, 0x0514, /* CYRILLIC CAPITAL LETTER LHA */
  0x0516, 0x0516, /* CYRILLIC CAPITAL LETTER RHA */
  0x0518, 0x0518, /* CYRILLIC CAPITAL LETTER YAE */
  0x051A, 0x051A, /* CYRILLIC CAPITAL LETTER QA */
  0x051C, 0x051C, /* CYRILLIC CAPITAL LETTER WE */
  0x051E, 0x051E, /* CYRILLIC CAPITAL LETTER ALEUT KA */
  0x0520, 0x0520, /* CYRILLIC CAPITAL LETTER EL WITH MIDDLE HOOK */
  0x0522, 0x0522, /* CYRILLIC CAPITAL LETTER EN WITH MIDDLE HOOK */
  0x0524, 0x0524, /* CYRILLIC CAPITAL LETTER PE WITH DESCENDER */
  0x0526, 0x0526, /* CYRILLIC CAPITAL LETTER SHHA WITH DESCENDER */
  0x0528, 0x0528, /* CYRILLIC CAPITAL LETTER EN WITH LEFT HOOK */
  0x052A, 0x052A, /* CYRILLIC CAPITAL LETTER DZZHE */
  0x052C, 0x052C, /* CYRILLIC CAPITAL LETTER DCHE */
  0x052E, 0x052E, /* CYRILLIC CAPITAL LETTER EL WITH DESCENDER */
  0x0531, 0x0556, /* ARMENIAN CAPITAL LETTER AYB */
  0x10A0, 0x10CD, /* GEORGIAN CAPITAL LETTER AN */
  0x13A0, 0x13F5, /* CHEROKEE LETTER A */
  0x1E00, 0x1E00, /* LATIN CAPITAL LETTER A WITH RING BELOW */
  0x1E02, 0x1E02, /* LATIN CAPITAL LETTER B WITH DOT ABOVE */
  0x1E04, 0x1E04, /* LATIN CAPITAL LETTER B WITH DOT BELOW */
  0x1E06, 0x1E06, /* LATIN CAPITAL LETTER B WITH LINE BELOW */
  0x1E08, 0x1E08, /* LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE */
  0x1E0A, 0x1E0A, /* LATIN CAPITAL LETTER D WITH DOT ABOVE */
  0x1E0C, 0x1E0C, /* LATIN CAPITAL LETTER D WITH DOT BELOW */
  0x1E0E, 0x1E0E, /* LATIN CAPITAL LETTER D WITH LINE BELOW */
  0x1E10, 0x1E10, /* LATIN CAPITAL LETTER D WITH CEDILLA */
  0x1E12, 0x1E12, /* LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW */
  0x1E14, 0x1E14, /* LATIN CAPITAL LETTER E WITH MACRON AND GRAVE */
  0x1E16, 0x1E16, /* LATIN CAPITAL LETTER E WITH MACRON AND ACUTE */
  0x1E18, 0x1E18, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW */
  0x1E1A, 0x1E1A, /* LATIN CAPITAL LETTER E WITH TILDE BELOW */
  0x1E1C, 0x1E1C, /* LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE */
  0x1E1E, 0x1E1E, /* LATIN CAPITAL LETTER F WITH DOT ABOVE */
  0x1E20, 0x1E20, /* LATIN CAPITAL LETTER G WITH MACRON */
  0x1E22, 0x1E22, /* LATIN CAPITAL LETTER H WITH DOT ABOVE */
  0x1E24, 0x1E24, /* LATIN CAPITAL LETTER H WITH DOT BELOW */
  0x1E26, 0x1E26, /* LATIN CAPITAL LETTER H WITH DIAERESIS */
  0x1E28, 0x1E28, /* LATIN CAPITAL LETTER H WITH CEDILLA */
  0x1E2A, 0x1E2A, /* LATIN CAPITAL LETTER H WITH BREVE BELOW */
  0x1E2C, 0x1E2C, /* LATIN CAPITAL LETTER I WITH TILDE BELOW */
  0x1E2E, 0x1E2E, /* LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE */
  0x1E30, 0x1E30, /* LATIN CAPITAL LETTER K WITH ACUTE */
  0x1E32, 0x1E32, /* LATIN CAPITAL LETTER K WITH DOT BELOW */
  0x1E34, 0x1E34, /* LATIN CAPITAL LETTER K WITH LINE BELOW */
  0x1E36, 0x1E36, /* LATIN CAPITAL LETTER L WITH DOT BELOW */
  0x1E38, 0x1E38, /* LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON */
  0x1E3A, 0x1E3A, /* LATIN CAPITAL LETTER L WITH LINE BELOW */
  0x1E3C, 0x1E3C, /* LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW */
  0x1E3E, 0x1E3E, /* LATIN CAPITAL LETTER M WITH ACUTE */
  0x1E40, 0x1E40, /* LATIN CAPITAL LETTER M WITH DOT ABOVE */
  0x1E42, 0x1E42, /* LATIN CAPITAL LETTER M WITH DOT BELOW */
  0x1E44, 0x1E44, /* LATIN CAPITAL LETTER N WITH DOT ABOVE */
  0x1E46, 0x1E46, /* LATIN CAPITAL LETTER N WITH DOT BELOW */
  0x1E48, 0x1E48, /* LATIN CAPITAL LETTER N WITH LINE BELOW */
  0x1E4A, 0x1E4A, /* LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW */
  0x1E4C, 0x1E4C, /* LATIN CAPITAL LETTER O WITH TILDE AND ACUTE */
  0x1E4E, 0x1E4E, /* LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS */
  0x1E50, 0x1E50, /* LATIN CAPITAL LETTER O WITH MACRON AND GRAVE */
  0x1E52, 0x1E52, /* LATIN CAPITAL LETTER O WITH MACRON AND ACUTE */
  0x1E54, 0x1E54, /* LATIN CAPITAL LETTER P WITH ACUTE */
  0x1E56, 0x1E56, /* LATIN CAPITAL LETTER P WITH DOT ABOVE */
  0x1E58, 0x1E58, /* LATIN CAPITAL LETTER R WITH DOT ABOVE */
  0x1E5A, 0x1E5A, /* LATIN CAPITAL LETTER R WITH DOT BELOW */
  0x1E5C, 0x1E5C, /* LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON */
  0x1E5E, 0x1E5E, /* LATIN CAPITAL LETTER R WITH LINE BELOW */
  0x1E60, 0x1E60, /* LATIN CAPITAL LETTER S WITH DOT ABOVE */
  0x1E62, 0x1E62, /* LATIN CAPITAL LETTER S WITH DOT BELOW */
  0x1E64, 0x1E64, /* LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE */
  0x1E66, 0x1E66, /* LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE */
  0x1E68, 0x1E68, /* LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE */
  0x1E6A, 0x1E6A, /* LATIN CAPITAL LETTER T WITH DOT ABOVE */
  0x1E6C, 0x1E6C, /* LATIN CAPITAL LETTER T WITH DOT BELOW */
  0x1E6E, 0x1E6E, /* LATIN CAPITAL LETTER T WITH LINE BELOW */
  0x1E70, 0x1E70, /* LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW */
  0x1E72, 0x1E72, /* LATIN CAPITAL LETTER U WITH DIAERESIS BELOW */
  0x1E74, 0x1E74, /* LATIN CAPITAL LETTER U WITH TILDE BELOW */
  0x1E76, 0x1E76, /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW */
  0x1E78, 0x1E78, /* LATIN CAPITAL LETTER U WITH TILDE AND ACUTE */
  0x1E7A, 0x1E7A, /* LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS */
  0x1E7C, 0x1E7C, /* LATIN CAPITAL LETTER V WITH TILDE */
  0x1E7E, 0x1E7E, /* LATIN CAPITAL LETTER V WITH DOT BELOW */
  0x1E80, 0x1E80, /* LATIN CAPITAL LETTER W WITH GRAVE */
  0x1E82, 0x1E82, /* LATIN CAPITAL LETTER W WITH ACUTE */
  0x1E84, 0x1E84, /* LATIN CAPITAL LETTER W WITH DIAERESIS */
  0x1E86, 0x1E86, /* LATIN CAPITAL LETTER W WITH DOT ABOVE */
  0x1E88, 0x1E88, /* LATIN CAPITAL LETTER W WITH DOT BELOW */
  0x1E8A, 0x1E8A, /* LATIN CAPITAL LETTER X WITH DOT ABOVE */
  0x1E8C, 0x1E8C, /* LATIN CAPITAL LETTER X WITH DIAERESIS */
  0x1E8E, 0x1E8E, /* LATIN CAPITAL LETTER Y WITH DOT ABOVE */
  0x1E90, 0x1E90, /* LATIN CAPITAL LETTER Z WITH CIRCUMFLEX */
  0x1E92, 0x1E92, /* LATIN CAPITAL LETTER Z WITH DOT BELOW */
  0x1E94, 0x1E94, /* LATIN CAPITAL LETTER Z WITH LINE BELOW */
  0x1E9E, 0x1E9E, /* LATIN CAPITAL LETTER SHARP S */
  0x1EA0, 0x1EA0, /* LATIN CAPITAL LETTER A WITH DOT BELOW */
  0x1EA2, 0x1EA2, /* LATIN CAPITAL LETTER A WITH HOOK ABOVE */
  0x1EA4, 0x1EA4, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
  0x1EA6, 0x1EA6, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
  0x1EA8, 0x1EA8, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1EAA, 0x1EAA, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
  0x1EAC, 0x1EAC, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
  0x1EAE, 0x1EAE, /* LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
  0x1EB0, 0x1EB0, /* LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
  0x1EB2, 0x1EB2, /* LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
  0x1EB4, 0x1EB4, /* LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
  0x1EB6, 0x1EB6, /* LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
  0x1EB8, 0x1EB8, /* LATIN CAPITAL LETTER E WITH DOT BELOW */
  0x1EBA, 0x1EBA, /* LATIN CAPITAL LETTER E WITH HOOK ABOVE */
  0x1EBC, 0x1EBC, /* LATIN CAPITAL LETTER E WITH TILDE */
  0x1EBE, 0x1EBE, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
  0x1EC0, 0x1EC0, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
  0x1EC2, 0x1EC2, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1EC4, 0x1EC4, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
  0x1EC6, 0x1EC6, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
  0x1EC8, 0x1EC8, /* LATIN CAPITAL LETTER I WITH HOOK ABOVE */
  0x1ECA, 0x1ECA, /* LATIN CAPITAL LETTER I WITH DOT BELOW */
  0x1ECC, 0x1ECC, /* LATIN CAPITAL LETTER O WITH DOT BELOW */
  0x1ECE, 0x1ECE, /* LATIN CAPITAL LETTER O WITH HOOK ABOVE */
  0x1ED0, 0x1ED0, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
  0x1ED2, 0x1ED2, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
  0x1ED4, 0x1ED4, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
  0x1ED6, 0x1ED6, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
  0x1ED8, 0x1ED8, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
  0x1EDA, 0x1EDA, /* LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
  0x1EDC, 0x1EDC, /* LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
  0x1EDE, 0x1EDE, /* LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
  0x1EE0, 0x1EE0, /* LATIN CAPITAL LETTER O WITH HORN AND TILDE */
  0x1EE2, 0x1EE2, /* LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
  0x1EE4, 0x1EE4, /* LATIN CAPITAL LETTER U WITH DOT BELOW */
  0x1EE6, 0x1EE6, /* LATIN CAPITAL LETTER U WITH HOOK ABOVE */
  0x1EE8, 0x1EE8, /* LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
  0x1EEA, 0x1EEA, /* LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
  0x1EEC, 0x1EEC, /* LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
  0x1EEE, 0x1EEE, /* LATIN CAPITAL LETTER U WITH HORN AND TILDE */
  0x1EF0, 0x1EF0, /* LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
  0x1EF2, 0x1EF2, /* LATIN CAPITAL LETTER Y WITH GRAVE */
  0x1EF4, 0x1EF4, /* LATIN CAPITAL LETTER Y WITH DOT BELOW */
  0x1EF6, 0x1EF6, /* LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
  0x1EF8, 0x1EF8, /* LATIN CAPITAL LETTER Y WITH TILDE */
  0x1EFA, 0x1EFA, /* LATIN CAPITAL LETTER MIDDLE-WELSH LL */
  0x1EFC, 0x1EFC, /* LATIN CAPITAL LETTER MIDDLE-WELSH V */
  0x1EFE, 0x1EFE, /* LATIN CAPITAL LETTER Y WITH LOOP */
  0x1F08, 0x1F0F, /* GREEK CAPITAL LETTER ALPHA WITH PSILI */
  0x1F18, 0x1F1D, /* GREEK CAPITAL LETTER EPSILON WITH PSILI */
  0x1F28, 0x1F2F, /* GREEK CAPITAL LETTER ETA WITH PSILI */
  0x1F38, 0x1F3F, /* GREEK CAPITAL LETTER IOTA WITH PSILI */
  0x1F48, 0x1F4D, /* GREEK CAPITAL LETTER OMICRON WITH PSILI */
  0x1F59, 0x1F5F, /* GREEK CAPITAL LETTER UPSILON WITH DASIA */
  0x1F68, 0x1F6F, /* GREEK CAPITAL LETTER OMEGA WITH PSILI */
  0x1FB8, 0x1FBB, /* GREEK CAPITAL LETTER ALPHA WITH VRACHY */
  0x1FC8, 0x1FCB, /* GREEK CAPITAL LETTER EPSILON WITH VARIA */
  0x1FD8, 0x1FDB, /* GREEK CAPITAL LETTER IOTA WITH VRACHY */
  0x1FE8, 0x1FEC, /* GREEK CAPITAL LETTER UPSILON WITH VRACHY */
  0x1FF8, 0x1FFB, /* GREEK CAPITAL LETTER OMICRON WITH VARIA */
  0x2102, 0x2102, /* DOUBLE-STRUCK CAPITAL C */
  0x2107, 0x2107, /* EULER CONSTANT */
  0x210B, 0x210D, /* SCRIPT CAPITAL H */
  0x2110, 0x2112, /* SCRIPT CAPITAL I */
  0x2115, 0x2115, /* DOUBLE-STRUCK CAPITAL N */
  0x2119, 0x211D, /* DOUBLE-STRUCK CAPITAL P */
  0x2124, 0x2124, /* DOUBLE-STRUCK CAPITAL Z */
  0x2126, 0x2126, /* OHM SIGN */
  0x2128, 0x2128, /* BLACK-LETTER CAPITAL Z */
  0x212A, 0x212D, /* KELVIN SIGN */
  0x2130, 0x2133, /* SCRIPT CAPITAL E */
  0x213E, 0x213F, /* DOUBLE-STRUCK CAPITAL GAMMA */
  0x2145, 0x2145, /* DOUBLE-STRUCK ITALIC CAPITAL D */
  0x2183, 0x2183, /* ROMAN NUMERAL REVERSED ONE HUNDRED */
  0x2C00, 0x2C2E, /* GLAGOLITIC CAPITAL LETTER AZU */
  0x2C60, 0x2C60, /* LATIN CAPITAL LETTER L WITH DOUBLE BAR */
  0x2C62, 0x2C64, /* LATIN CAPITAL LETTER L WITH MIDDLE TILDE */
  0x2C67, 0x2C67, /* LATIN CAPITAL LETTER H WITH DESCENDER */
  0x2C69, 0x2C69, /* LATIN CAPITAL LETTER K WITH DESCENDER */
  0x2C6B, 0x2C6B, /* LATIN CAPITAL LETTER Z WITH DESCENDER */
  0x2C6D, 0x2C70, /* LATIN CAPITAL LETTER ALPHA */
  0x2C72, 0x2C72, /* LATIN CAPITAL LETTER W WITH HOOK */
  0x2C75, 0x2C75, /* LATIN CAPITAL LETTER HALF H */
  0x2C7E, 0x2C80, /* LATIN CAPITAL LETTER S WITH SWASH TAIL */
  0x2C82, 0x2C82, /* COPTIC CAPITAL LETTER VIDA */
  0x2C84, 0x2C84, /* COPTIC CAPITAL LETTER GAMMA */
  0x2C86, 0x2C86, /* COPTIC CAPITAL LETTER DALDA */
  0x2C88, 0x2C88, /* COPTIC CAPITAL LETTER EIE */
  0x2C8A, 0x2C8A, /* COPTIC CAPITAL LETTER SOU */
  0x2C8C, 0x2C8C, /* COPTIC CAPITAL LETTER ZATA */
  0x2C8E, 0x2C8E, /* COPTIC CAPITAL LETTER HATE */
  0x2C90, 0x2C90, /* COPTIC CAPITAL LETTER THETHE */
  0x2C92, 0x2C92, /* COPTIC CAPITAL LETTER IAUDA */
  0x2C94, 0x2C94, /* COPTIC CAPITAL LETTER KAPA */
  0x2C96, 0x2C96, /* COPTIC CAPITAL LETTER LAULA */
  0x2C98, 0x2C98, /* COPTIC CAPITAL LETTER MI */
  0x2C9A, 0x2C9A, /* COPTIC CAPITAL LETTER NI */
  0x2C9C, 0x2C9C, /* COPTIC CAPITAL LETTER KSI */
  0x2C9E, 0x2C9E, /* COPTIC CAPITAL LETTER O */
  0x2CA0, 0x2CA0, /* COPTIC CAPITAL LETTER PI */
  0x2CA2, 0x2CA2, /* COPTIC CAPITAL LETTER RO */
  0x2CA4, 0x2CA4, /* COPTIC CAPITAL LETTER SIMA */
  0x2CA6, 0x2CA6, /* COPTIC CAPITAL LETTER TAU */
  0x2CA8, 0x2CA8, /* COPTIC CAPITAL LETTER UA */
  0x2CAA, 0x2CAA, /* COPTIC CAPITAL LETTER FI */
  0x2CAC, 0x2CAC, /* COPTIC CAPITAL LETTER KHI */
  0x2CAE, 0x2CAE, /* COPTIC CAPITAL LETTER PSI */
  0x2CB0, 0x2CB0, /* COPTIC CAPITAL LETTER OOU */
  0x2CB2, 0x2CB2, /* COPTIC CAPITAL LETTER DIALECT-P ALEF */
  0x2CB4, 0x2CB4, /* COPTIC CAPITAL LETTER OLD COPTIC AIN */
  0x2CB6, 0x2CB6, /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC EIE */
  0x2CB8, 0x2CB8, /* COPTIC CAPITAL LETTER DIALECT-P KAPA */
  0x2CBA, 0x2CBA, /* COPTIC CAPITAL LETTER DIALECT-P NI */
  0x2CBC, 0x2CBC, /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC NI */
  0x2CBE, 0x2CBE, /* COPTIC CAPITAL LETTER OLD COPTIC OOU */
  0x2CC0, 0x2CC0, /* COPTIC CAPITAL LETTER SAMPI */
  0x2CC2, 0x2CC2, /* COPTIC CAPITAL LETTER CROSSED SHEI */
  0x2CC4, 0x2CC4, /* COPTIC CAPITAL LETTER OLD COPTIC SHEI */
  0x2CC6, 0x2CC6, /* COPTIC CAPITAL LETTER OLD COPTIC ESH */
  0x2CC8, 0x2CC8, /* COPTIC CAPITAL LETTER AKHMIMIC KHEI */
  0x2CCA, 0x2CCA, /* COPTIC CAPITAL LETTER DIALECT-P HORI */
  0x2CCC, 0x2CCC, /* COPTIC CAPITAL LETTER OLD COPTIC HORI */
  0x2CCE, 0x2CCE, /* COPTIC CAPITAL LETTER OLD COPTIC HA */
  0x2CD0, 0x2CD0, /* COPTIC CAPITAL LETTER L-SHAPED HA */
  0x2CD2, 0x2CD2, /* COPTIC CAPITAL LETTER OLD COPTIC HEI */
  0x2CD4, 0x2CD4, /* COPTIC CAPITAL LETTER OLD COPTIC HAT */
  0x2CD6, 0x2CD6, /* COPTIC CAPITAL LETTER OLD COPTIC GANGIA */
  0x2CD8, 0x2CD8, /* COPTIC CAPITAL LETTER OLD COPTIC DJA */
  0x2CDA, 0x2CDA, /* COPTIC CAPITAL LETTER OLD COPTIC SHIMA */
  0x2CDC, 0x2CDC, /* COPTIC CAPITAL LETTER OLD NUBIAN SHIMA */
  0x2CDE, 0x2CDE, /* COPTIC CAPITAL LETTER OLD NUBIAN NGI */
  0x2CE0, 0x2CE0, /* COPTIC CAPITAL LETTER OLD NUBIAN NYI */
  0x2CE2, 0x2CE2, /* COPTIC CAPITAL LETTER OLD NUBIAN WAU */
  0x2CEB, 0x2CEB, /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC SHEI */
  0x2CED, 0x2CED, /* COPTIC CAPITAL LETTER CRYPTOGRAMMIC GANGIA */
  0x2CF2, 0x2CF2, /* COPTIC CAPITAL LETTER BOHAIRIC KHEI */
  0xA640, 0xA640, /* CYRILLIC CAPITAL LETTER ZEMLYA */
  0xA642, 0xA642, /* CYRILLIC CAPITAL LETTER DZELO */
  0xA644, 0xA644, /* CYRILLIC CAPITAL LETTER REVERSED DZE */
  0xA646, 0xA646, /* CYRILLIC CAPITAL LETTER IOTA */
  0xA648, 0xA648, /* CYRILLIC CAPITAL LETTER DJERV */
  0xA64A, 0xA64A, /* CYRILLIC CAPITAL LETTER MONOGRAPH UK */
  0xA64C, 0xA64C, /* CYRILLIC CAPITAL LETTER BROAD OMEGA */
  0xA64E, 0xA64E, /* CYRILLIC CAPITAL LETTER NEUTRAL YER */
  0xA650, 0xA650, /* CYRILLIC CAPITAL LETTER YERU WITH BACK YER */
  0xA652, 0xA652, /* CYRILLIC CAPITAL LETTER IOTIFIED YAT */
  0xA654, 0xA654, /* CYRILLIC CAPITAL LETTER REVERSED YU */
  0xA656, 0xA656, /* CYRILLIC CAPITAL LETTER IOTIFIED A */
  0xA658, 0xA658, /* CYRILLIC CAPITAL LETTER CLOSED LITTLE YUS */
  0xA65A, 0xA65A, /* CYRILLIC CAPITAL LETTER BLENDED YUS */
  0xA65C, 0xA65C, /* CYRILLIC CAPITAL LETTER IOTIFIED CLOSED LITTLE YUS */
  0xA65E, 0xA65E, /* CYRILLIC CAPITAL LETTER YN */
  0xA660, 0xA660, /* CYRILLIC CAPITAL LETTER REVERSED TSE */
  0xA662, 0xA662, /* CYRILLIC CAPITAL LETTER SOFT DE */
  0xA664, 0xA664, /* CYRILLIC CAPITAL LETTER SOFT EL */
  0xA666, 0xA666, /* CYRILLIC CAPITAL LETTER SOFT EM */
  0xA668, 0xA668, /* CYRILLIC CAPITAL LETTER MONOCULAR O */
  0xA66A, 0xA66A, /* CYRILLIC CAPITAL LETTER BINOCULAR O */
  0xA66C, 0xA66C, /* CYRILLIC CAPITAL LETTER DOUBLE MONOCULAR O */
  0xA680, 0xA680, /* CYRILLIC CAPITAL LETTER DWE */
  0xA682, 0xA682, /* CYRILLIC CAPITAL LETTER DZWE */
  0xA684, 0xA684, /* CYRILLIC CAPITAL LETTER ZHWE */
  0xA686, 0xA686, /* CYRILLIC CAPITAL LETTER CCHE */
  0xA688, 0xA688, /* CYRILLIC CAPITAL LETTER DZZE */
  0xA68A, 0xA68A, /* CYRILLIC CAPITAL LETTER TE WITH MIDDLE HOOK */
  0xA68C, 0xA68C, /* CYRILLIC CAPITAL LETTER TWE */
  0xA68E, 0xA68E, /* CYRILLIC CAPITAL LETTER TSWE */
  0xA690, 0xA690, /* CYRILLIC CAPITAL LETTER TSSE */
  0xA692, 0xA692, /* CYRILLIC CAPITAL LETTER TCHE */
  0xA694, 0xA694, /* CYRILLIC CAPITAL LETTER HWE */
  0xA696, 0xA696, /* CYRILLIC CAPITAL LETTER SHWE */
  0xA698, 0xA698, /* CYRILLIC CAPITAL LETTER DOUBLE O */
  0xA69A, 0xA69A, /* CYRILLIC CAPITAL LETTER CROSSED O */
  0xA722, 0xA722, /* LATIN CAPITAL LETTER EGYPTOLOGICAL ALEF */
  0xA724, 0xA724, /* LATIN CAPITAL LETTER EGYPTOLOGICAL AIN */
  0xA726, 0xA726, /* LATIN CAPITAL LETTER HENG */
  0xA728, 0xA728, /* LATIN CAPITAL LETTER TZ */
  0xA72A, 0xA72A, /* LATIN CAPITAL LETTER TRESILLO */
  0xA72C, 0xA72C, /* LATIN CAPITAL LETTER CUATRILLO */
  0xA72E, 0xA72E, /* LATIN CAPITAL LETTER CUATRILLO WITH COMMA */
  0xA732, 0xA732, /* LATIN CAPITAL LETTER AA */
  0xA734, 0xA734, /* LATIN CAPITAL LETTER AO */
  0xA736, 0xA736, /* LATIN CAPITAL LETTER AU */
  0xA738, 0xA738, /* LATIN CAPITAL LETTER AV */
  0xA73A, 0xA73A, /* LATIN CAPITAL LETTER AV WITH HORIZONTAL BAR */
  0xA73C, 0xA73C, /* LATIN CAPITAL LETTER AY */
  0xA73E, 0xA73E, /* LATIN CAPITAL LETTER REVERSED C WITH DOT */
  0xA740, 0xA740, /* LATIN CAPITAL LETTER K WITH STROKE */
  0xA742, 0xA742, /* LATIN CAPITAL LETTER K WITH DIAGONAL STROKE */
  0xA744, 0xA744, /* LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE */
  0xA746, 0xA746, /* LATIN CAPITAL LETTER BROKEN L */
  0xA748, 0xA748, /* LATIN CAPITAL LETTER L WITH HIGH STROKE */
  0xA74A, 0xA74A, /* LATIN CAPITAL LETTER O WITH LONG STROKE OVERLAY */
  0xA74C, 0xA74C, /* LATIN CAPITAL LETTER O WITH LOOP */
  0xA74E, 0xA74E, /* LATIN CAPITAL LETTER OO */
  0xA750, 0xA750, /* LATIN CAPITAL LETTER P WITH STROKE THROUGH DESCENDER */
  0xA752, 0xA752, /* LATIN CAPITAL LETTER P WITH FLOURISH */
  0xA754, 0xA754, /* LATIN CAPITAL LETTER P WITH SQUIRREL TAIL */
  0xA756, 0xA756, /* LATIN CAPITAL LETTER Q WITH STROKE THROUGH DESCENDER */
  0xA758, 0xA758, /* LATIN CAPITAL LETTER Q WITH DIAGONAL STROKE */
  0xA75A, 0xA75A, /* LATIN CAPITAL LETTER R ROTUNDA */
  0xA75C, 0xA75C, /* LATIN CAPITAL LETTER RUM ROTUNDA */
  0xA75E, 0xA75E, /* LATIN CAPITAL LETTER V WITH DIAGONAL STROKE */
  0xA760, 0xA760, /* LATIN CAPITAL LETTER VY */
  0xA762, 0xA762, /* LATIN CAPITAL LETTER VISIGOTHIC Z */
  0xA764, 0xA764, /* LATIN CAPITAL LETTER THORN WITH STROKE */
  0xA766, 0xA766, /* LATIN CAPITAL LETTER THORN WITH STROKE THROUGH DESCENDER */
  0xA768, 0xA768, /* LATIN CAPITAL LETTER VEND */
  0xA76A, 0xA76A, /* LATIN CAPITAL LETTER ET */
  0xA76C, 0xA76C, /* LATIN CAPITAL LETTER IS */
  0xA76E, 0xA76E, /* LATIN CAPITAL LETTER CON */
  0xA779, 0xA779, /* LATIN CAPITAL LETTER INSULAR D */
  0xA77B, 0xA77B, /* LATIN CAPITAL LETTER INSULAR F */
  0xA77D, 0xA77E, /* LATIN CAPITAL LETTER INSULAR G */
  0xA780, 0xA780, /* LATIN CAPITAL LETTER TURNED L */
  0xA782, 0xA782, /* LATIN CAPITAL LETTER INSULAR R */
  0xA784, 0xA784, /* LATIN CAPITAL LETTER INSULAR S */
  0xA786, 0xA786, /* LATIN CAPITAL LETTER INSULAR T */
  0xA78B, 0xA78B, /* LATIN CAPITAL LETTER SALTILLO */
  0xA78D, 0xA78D, /* LATIN CAPITAL LETTER TURNED H */
  0xA790, 0xA790, /* LATIN CAPITAL LETTER N WITH DESCENDER */
  0xA792, 0xA792, /* LATIN CAPITAL LETTER C WITH BAR */
  0xA796, 0xA796, /* LATIN CAPITAL LETTER B WITH FLOURISH */
  0xA798, 0xA798, /* LATIN CAPITAL LETTER F WITH STROKE */
  0xA79A, 0xA79A, /* LATIN CAPITAL LETTER VOLAPUK AE */
  0xA79C, 0xA79C, /* LATIN CAPITAL LETTER VOLAPUK OE */
  0xA79E, 0xA79E, /* LATIN CAPITAL LETTER VOLAPUK UE */
  0xA7A0, 0xA7A0, /* LATIN CAPITAL LETTER G WITH OBLIQUE STROKE */
  0xA7A2, 0xA7A2, /* LATIN CAPITAL LETTER K WITH OBLIQUE STROKE */
  0xA7A4, 0xA7A4, /* LATIN CAPITAL LETTER N WITH OBLIQUE STROKE */
  0xA7A6, 0xA7A6, /* LATIN CAPITAL LETTER R WITH OBLIQUE STROKE */
  0xA7A8, 0xA7A8, /* LATIN CAPITAL LETTER S WITH OBLIQUE STROKE */
  0xA7AA, 0xA7B4, /* LATIN CAPITAL LETTER H WITH HOOK */
  0xA7B6, 0xA7B6, /* LATIN CAPITAL LETTER OMEGA */
  0xFF21, 0xFF3A, /* FULLWIDTH LATIN CAPITAL LETTER A */
  0x10400, 0x10427, /* DESERET CAPITAL LETTER LONG I */
  0x10C80, 0x10CB2, /* OLD HUNGARIAN CAPITAL LETTER A */
  0x118A0, 0x118BF, /* WARANG CITI CAPITAL LETTER NGAA */
  0x1D400, 0x1D419, /* MATHEMATICAL BOLD CAPITAL A */
  0x1D434, 0x1D44D, /* MATHEMATICAL ITALIC CAPITAL A */
  0x1D468, 0x1D481, /* MATHEMATICAL BOLD ITALIC CAPITAL A */
  0x1D49C, 0x1D4B5, /* MATHEMATICAL SCRIPT CAPITAL A */
  0x1D4D0, 0x1D4E9, /* MATHEMATICAL BOLD SCRIPT CAPITAL A */
  0x1D504, 0x1D51C, /* MATHEMATICAL FRAKTUR CAPITAL A */
  0x1D538, 0x1D550, /* MATHEMATICAL DOUBLE-STRUCK CAPITAL A */
  0x1D56C, 0x1D585, /* MATHEMATICAL BOLD FRAKTUR CAPITAL A */
  0x1D5A0, 0x1D5B9, /* MATHEMATICAL SANS-SERIF CAPITAL A */
  0x1D5D4, 0x1D5ED, /* MATHEMATICAL SANS-SERIF BOLD CAPITAL A */
  0x1D608, 0x1D621, /* MATHEMATICAL SANS-SERIF ITALIC CAPITAL A */
  0x1D63C, 0x1D655, /* MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL A */
  0x1D670, 0x1D689, /* MATHEMATICAL MONOSPACE CAPITAL A */
  0x1D6A8, 0x1D6C0, /* MATHEMATICAL BOLD CAPITAL ALPHA */
  0x1D6E2, 0x1D6FA, /* MATHEMATICAL ITALIC CAPITAL ALPHA */
  0x1D71C, 0x1D734, /* MATHEMATICAL BOLD ITALIC CAPITAL ALPHA */
  0x1D756, 0x1D76E, /* MATHEMATICAL SANS-SERIF BOLD CAPITAL ALPHA */
  0x1D790, 0x1D7A8, /* MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL ALPHA */
  0x1D7CA, 0x1D7CA, /* MATHEMATICAL BOLD CAPITAL DIGAMMA */
  0, 'd',
  0x0030, 0x0039, /* DIGIT ZERO */  0x0660, 0x0669, /* ARABIC-INDIC DIGIT ZERO */
  0x06F0, 0x06F9, /* EXTENDED ARABIC-INDIC DIGIT ZERO */
  0x07C0, 0x07C9, /* NKO DIGIT ZERO */
  0x0966, 0x096F, /* DEVANAGARI DIGIT ZERO */
  0x09E6, 0x09EF, /* BENGALI DIGIT ZERO */
  0x0A66, 0x0A6F, /* GURMUKHI DIGIT ZERO */
  0x0AE6, 0x0AEF, /* GUJARATI DIGIT ZERO */
  0x0B66, 0x0B6F, /* ORIYA DIGIT ZERO */
  0x0BE6, 0x0BEF, /* TAMIL DIGIT ZERO */
  0x0C66, 0x0C6F, /* TELUGU DIGIT ZERO */
  0x0CE6, 0x0CEF, /* KANNADA DIGIT ZERO */
  0x0D66, 0x0D6F, /* MALAYALAM DIGIT ZERO */
  0x0DE6, 0x0DEF, /* SINHALA LITH DIGIT ZERO */
  0x0E50, 0x0E59, /* THAI DIGIT ZERO */
  0x0ED0, 0x0ED9, /* LAO DIGIT ZERO */
  0x0F20, 0x0F29, /* TIBETAN DIGIT ZERO */
  0x1040, 0x1049, /* MYANMAR DIGIT ZERO */
  0x1090, 0x1099, /* MYANMAR SHAN DIGIT ZERO */
  0x17E0, 0x17E9, /* KHMER DIGIT ZERO */
  0x1810, 0x1819, /* MONGOLIAN DIGIT ZERO */
  0x1946, 0x194F, /* LIMBU DIGIT ZERO */
  0x19D0, 0x19D9, /* NEW TAI LUE DIGIT ZERO */
  0x1A80, 0x1A99, /* TAI THAM HORA DIGIT ZERO */
  0x1B50, 0x1B59, /* BALINESE DIGIT ZERO */
  0x1BB0, 0x1BB9, /* SUNDANESE DIGIT ZERO */
  0x1C40, 0x1C49, /* LEPCHA DIGIT ZERO */
  0x1C50, 0x1C59, /* OL CHIKI DIGIT ZERO */
  0xA620, 0xA629, /* VAI DIGIT ZERO */
  0xA8D0, 0xA8D9, /* SAURASHTRA DIGIT ZERO */
  0xA900, 0xA909, /* KAYAH LI DIGIT ZERO */
  0xA9D0, 0xA9D9, /* JAVANESE DIGIT ZERO */
  0xA9F0, 0xA9F9, /* MYANMAR TAI LAING DIGIT ZERO */
  0xAA50, 0xAA59, /* CHAM DIGIT ZERO */
  0xABF0, 0xABF9, /* MEETEI MAYEK DIGIT ZERO */
  0xFF10, 0xFF19, /* FULLWIDTH DIGIT ZERO */
  0x104A0, 0x104A9, /* OSMANYA DIGIT ZERO */
  0x11066, 0x1106F, /* BRAHMI DIGIT ZERO */
  0x110F0, 0x110F9, /* SORA SOMPENG DIGIT ZERO */
  0x11136, 0x1113F, /* CHAKMA DIGIT ZERO */
  0x111D0, 0x111D9, /* SHARADA DIGIT ZERO */
  0x112F0, 0x112F9, /* KHUDAWADI DIGIT ZERO */
  0x114D0, 0x114D9, /* TIRHUTA DIGIT ZERO */
  0x11650, 0x11659, /* MODI DIGIT ZERO */
  0x116C0, 0x116C9, /* TAKRI DIGIT ZERO */
  0x11730, 0x11739, /* AHOM DIGIT ZERO */
  0x118E0, 0x118E9, /* WARANG CITI DIGIT ZERO */
  0x16A60, 0x16A69, /* MRO DIGIT ZERO */
  0x16B50, 0x16B59, /* PAHAWH HMONG DIGIT ZERO */
  0x1D7CE, 0x1D7FF, /* MATHEMATICAL BOLD DIGIT ZERO */
  0x16EE, 0x16F0, /* RUNIC ARLAUG SYMBOL */
  0x2160, 0x2182, /* ROMAN NUMERAL ONE */
  0x2185, 0x2188, /* ROMAN NUMERAL SIX LATE FORM */
  0x3007, 0x3007, /* IDEOGRAPHIC NUMBER ZERO */
  0x3021, 0x3029, /* HANGZHOU NUMERAL ONE */
  0x3038, 0x303A, /* HANGZHOU NUMERAL TEN */
  0xA6E6, 0xA6EF, /* BAMUM LETTER MO */
  0x10140, 0x10174, /* GREEK ACROPHONIC ATTIC ONE QUARTER */
  0x10341, 0x10341, /* GOTHIC LETTER NINETY */
  0x1034A, 0x1034A, /* GOTHIC LETTER NINE HUNDRED */
  0x103D1, 0x103D5, /* OLD PERSIAN NUMBER ONE */
  0x12400, 0x1246E, /* CUNEIFORM NUMERIC SIGN TWO ASH */
  0x00B2, 0x00B3, /* SUPERSCRIPT TWO */
  0x00B9, 0x00B9, /* SUPERSCRIPT ONE */
  0x00BC, 0x00BE, /* VULGAR FRACTION ONE QUARTER */
  0x09F4, 0x09F9, /* BENGALI CURRENCY NUMERATOR ONE */
  0x0B72, 0x0B77, /* ORIYA FRACTION ONE QUARTER */
  0x0BF0, 0x0BF2, /* TAMIL NUMBER TEN */
  0x0C78, 0x0C7E, /* TELUGU FRACTION DIGIT ZERO FOR ODD POWERS OF FOUR */
  0x0D70, 0x0D75, /* MALAYALAM NUMBER TEN */
  0x0F2A, 0x0F33, /* TIBETAN DIGIT HALF ONE */
  0x1369, 0x137C, /* ETHIOPIC DIGIT ONE */
  0x17F0, 0x17F9, /* KHMER SYMBOL LEK ATTAK SON */
  0x19DA, 0x19DA, /* NEW TAI LUE THAM DIGIT ONE */
  0x2070, 0x2070, /* SUPERSCRIPT ZERO */
  0x2074, 0x2079, /* SUPERSCRIPT FOUR */
  0x2080, 0x2089, /* SUBSCRIPT ZERO */
  0x2150, 0x215F, /* VULGAR FRACTION ONE SEVENTH */
  0x2189, 0x2189, /* VULGAR FRACTION ZERO THIRDS */
  0x2460, 0x249B, /* CIRCLED DIGIT ONE */
  0x24EA, 0x24FF, /* CIRCLED DIGIT ZERO */
  0x2776, 0x2793, /* DINGBAT NEGATIVE CIRCLED DIGIT ONE */
  0x2CFD, 0x2CFD, /* COPTIC FRACTION ONE HALF */
  0x3192, 0x3195, /* IDEOGRAPHIC ANNOTATION ONE MARK */
  0x3220, 0x3229, /* PARENTHESIZED IDEOGRAPH ONE */
  0x3248, 0x324F, /* CIRCLED NUMBER TEN ON BLACK SQUARE */
  0x3251, 0x325F, /* CIRCLED NUMBER TWENTY ONE */
  0x3280, 0x3289, /* CIRCLED IDEOGRAPH ONE */
  0x32B1, 0x32BF, /* CIRCLED NUMBER THIRTY SIX */
  0xA830, 0xA835, /* NORTH INDIC FRACTION ONE QUARTER */
  0x10107, 0x10133, /* AEGEAN NUMBER ONE */
  0x10175, 0x10178, /* GREEK ONE HALF SIGN */
  0x1018A, 0x1018B, /* GREEK ZERO SIGN */
  0x102E1, 0x102FB, /* COPTIC EPACT DIGIT ONE */
  0x10320, 0x10323, /* OLD ITALIC NUMERAL ONE */
  0x10858, 0x1085F, /* IMPERIAL ARAMAIC NUMBER ONE */
  0x10879, 0x1087F, /* PALMYRENE NUMBER ONE */
  0x108A7, 0x108AF, /* NABATAEAN NUMBER ONE */
  0x108FB, 0x108FF, /* HATRAN NUMBER ONE */
  0x10916, 0x1091B, /* PHOENICIAN NUMBER ONE */
  0x109BC, 0x109BD, /* MEROITIC CURSIVE FRACTION ELEVEN TWELFTHS */
  0x109C0, 0x109FF, /* MEROITIC CURSIVE NUMBER ONE */
  0x10A40, 0x10A47, /* KHAROSHTHI DIGIT ONE */
  0x10A7D, 0x10A7E, /* OLD SOUTH ARABIAN NUMBER ONE */
  0x10A9D, 0x10A9F, /* OLD NORTH ARABIAN NUMBER ONE */
  0x10AEB, 0x10AEF, /* MANICHAEAN NUMBER ONE */
  0x10B58, 0x10B5F, /* INSCRIPTIONAL PARTHIAN NUMBER ONE */
  0x10B78, 0x10B7F, /* INSCRIPTIONAL PAHLAVI NUMBER ONE */
  0x10BA9, 0x10BAF, /* PSALTER PAHLAVI NUMBER ONE */
  0x10CFA, 0x10E7E, /* OLD HUNGARIAN NUMBER ONE */
  0x11052, 0x11065, /* BRAHMI NUMBER ONE */
  0x111E1, 0x111F4, /* SINHALA ARCHAIC DIGIT ONE */
  0x1173A, 0x1173B, /* AHOM NUMBER TEN */
  0x118EA, 0x118F2, /* WARANG CITI NUMBER TEN */
  0x16B5B, 0x16B61, /* PAHAWH HMONG NUMBER TENS */
  0x1D360, 0x1D371, /* COUNTING ROD UNIT DIGIT ONE */
  0x1E8C7, 0x1E8CF, /* MENDE KIKAKUI DIGIT ONE */
  0x1F100, 0x1F10C, /* DIGIT ZERO FULL STOP */
  0, 's',
  '\t', '\t',
  0x0020, 0x0020, /* SPACE */  0x00A0, 0x00A0, /* NO-BREAK SPACE */
  0x1680, 0x1680, /* OGHAM SPACE MARK */
  0x2000, 0x200A, /* EN QUAD */
  0x202F, 0x202F, /* NARROW NO-BREAK SPACE */
  0x205F, 0x205F, /* MEDIUM MATHEMATICAL SPACE */
  0x3000, 0x3000, /* IDEOGRAPHIC SPACE */
  0, 'e',
  '!', '!',
  '?', '?',
  '.', '.',
  0x0964, 0x0965, /* DANDA, - DOUBLE-DANDA (CHECKED)*/
   0,0
  /* end code generated by cvt.py */
};

struct LxScanner{
  const char *p;
  int ch;
  int offset;
};

struct LxMode{
  const char *name;
  struct LxState *init_state; /* Pointer to root state in this mode */
  int is_nesting;             /* 1 if this mode is recursive */
  struct LxMode *next_mode;
};

enum LxAstNodeType{
  CHAR_NODE,
  CLASS_NODE,
  NCLASS_NODE,
  STAR_NODE,
  PLUS_NODE,
  OPT_NODE,
  OR_NODE,
  AND_NODE,
};

enum LxTransitionType{
  REGULAR_TX = 0,
  NOT_TX = 1,
  INIT_TX = 2,
  DROP_TX = 3,
  LOOP_TX = 4,
};

struct LxAstNode{
  int node_type;
  struct LxAstNode *lhs;
  struct LxAstNode *rhs;
  int ch0;
  int ch1;
};

struct LxTransition{
  int ch0;
  int ch1;
  int tx_type;
  int is_drop;
  int is_capturing;
  int is_loop_set; /* when setting loop_enter, use this to group outgoing tx's from shadow state */
  struct LxState *next_state;
  struct LxTransition* next_transition;
};

struct LxState{
  int state_id;
  int is_leaf;
  int is_loop_head;
  int is_loop_enter;
  int is_loop_return;
  int is_processed;
  struct symbol* matchedsym;
  struct LxMode *init_mode;
  const char *next_mode;
  const char *code;
  struct LxState *star_state;
  struct LxState *drop_state;
  struct LxState *goto_state;
  struct LxTransition* not_transition;
  struct LxTransition* dot_transition;
  struct LxTransition* head_transition;
  struct LxState *next_state;
};
#endif /* LEMONEX */

/* Each production rule in the grammar is stored in the following
** structure.  */
struct rule {
  struct symbol *lhs;      /* Left-hand side of the rule */
  const char *lhsalias;    /* Alias for the LHS (NULL if none) */
  int lhsStart;            /* True if left-hand side is the start symbol */
  int ruleline;            /* Line number for the rule */
  int nrhs;                /* Number of RHS symbols */
  struct symbol **rhs;     /* The RHS symbols */
  const char **rhsalias;   /* An alias for each RHS symbol (NULL if none) */
  int line;                /* Line number at which code begins */
  const char *code;        /* The code executed when this rule is reduced */
  struct symbol *precsym;  /* Precedence symbol for this rule */
  int index;               /* An index number for this rule */
  Boolean canReduce;       /* True if this rule is ever reduced */
  struct rule *nextlhs;    /* Next rule with the same LHS */
  struct rule *next;       /* Next rule in the global list */
};

/* A configuration is a production rule of the grammar together with
** a mark (dot) showing how much of that rule has been processed so far.
** Configurations also contain a follow-set which is a list of terminal
** symbols which are allowed to immediately follow the end of the rule.
** Every configuration is recorded as an instance of the following: */
enum cfgstatus {
  COMPLETE,
  INCOMPLETE
};
struct config {
  struct rule *rp;         /* The rule upon which the configuration is based */
  int dot;                 /* The parse point */
  char *fws;               /* Follow-set for this configuration only */
  struct plink *fplp;      /* Follow-set forward propagation links */
  struct plink *bplp;      /* Follow-set backwards propagation links */
  struct state *stp;       /* Pointer to state which contains this */
  enum cfgstatus status;   /* used during followset and shift computations */
  struct config *next;     /* Next configuration in the state */
  struct config *bp;       /* The next basis configuration */
};

enum e_action {
  SHIFT,
  ACCEPT,
  REDUCE,
  ERROR,
  SSCONFLICT,              /* A shift/shift conflict */
  SRCONFLICT,              /* Was a reduce, but part of a conflict */
  RRCONFLICT,              /* Was a reduce, but part of a conflict */
  SH_RESOLVED,             /* Was a shift.  Precedence resolved conflict */
  RD_RESOLVED,             /* Was reduce.  Precedence resolved conflict */
  NOT_USED,                /* Deleted by compression */
  SHIFTREDUCE              /* Shift first, then reduce */
};

/* Every shift or reduce operation is stored as one of the following */
struct action {
  struct symbol *sp;       /* The look-ahead symbol */
  enum e_action type;
  union {
    struct state *stp;     /* The new state, if a shift */
    struct rule *rp;       /* The rule, if a reduce */
  } x;
  struct action *next;     /* Next action for this state */
  struct action *collide;  /* Next action with the same hash */
};

/* Each state of the generated parser's finite state machine
** is encoded as an instance of the following structure. */
struct state {
  struct config *bp;       /* The basis configurations for this state */
  struct config *cfp;      /* All configurations in this set */
  int statenum;            /* Sequential number for this state */
  struct action *ap;       /* Array of actions for this state */
  int nTknAct, nNtAct;     /* Number of actions on terminals and nonterminals */
  int iTknOfst, iNtOfst;   /* yy_action[] offset for terminals and nonterms */
  int iDfltReduce;         /* Default action is to REDUCE by this rule */
  struct rule *pDfltReduce;/* The default REDUCE rule. */
  int autoReduce;          /* True if this is an auto-reduce state */
};
#define NO_OFFSET (-2147483647)

/* A followset propagation link indicates that the contents of one
** configuration followset should be propagated to another whenever
** the first changes. */
struct plink {
  struct config *cfp;      /* The configuration to which linked */
  struct plink *next;      /* The next propagate link */
};

/* The state vector for the entire parser generator is recorded as
** follows.  (LEMON uses no global variables and makes little use of
** static variables.  Fields in the following structure can be thought
** of as begin global variables in the program.) */
struct lemon {
  struct state **sorted;   /* Table of states sorted by state number */
  struct rule *rule;       /* List of all rules */
  int nstate;              /* Number of states */
  int nxstate;             /* nstate with tail degenerate states removed */
  int nrule;               /* Number of rules */
  int nsymbol;             /* Number of terminal and nonterminal symbols */
  int nterminal;           /* Number of terminal symbols */
  struct symbol **symbols; /* Sorted array of pointers to symbols */
  int errorcnt;            /* Number of errors */
  struct symbol *errsym;   /* The error symbol */
  struct symbol *wildcard; /* Token that matches anything */
  char *name;              /* Name of the generated parser */
  char *arg;               /* Declaration of the 3th argument to parser */
  char *tokentype;         /* Type of terminal symbols in the parser stack */
  char *vartype;           /* The default type of non-terminal symbols */
  char *start;             /* Name of the start symbol for the grammar */
  char *stacksize;         /* Size of the parser stack */
  char *include;           /* Code to put at the start of the C file */
  char *error;             /* Code to execute when an error is seen */
  char *overflow;          /* Code to execute on a stack overflow */
  char *failure;           /* Code to execute on parser failure */
  char *accept;            /* Code to execute when the parser excepts */
  char *extracode;         /* Code appended to the generated file */
  char *tokendest;         /* Code to execute to destroy token data */
  char *vardest;           /* Code for the default non-terminal destructor */
  char *filename;          /* Name of the input file */
  char *outname;           /* Name of the current output file */
  char *tokenprefix;       /* A prefix added to token names in the .h file */
  int nconflict;           /* Number of parsing conflicts */
  int nactiontab;          /* Number of entries in the yy_action[] table */
  int tablesize;           /* Total table size of all tables in bytes */
  int basisflag;           /* Print only basis configurations */
  int has_fallback;        /* True if any %fallback is seen in the grammar */
  int nolinenosflag;       /* True if #line statements should not be printed */
  char *argv0;             /* Name of the program */
#ifdef LEMONEX
  int lxintegration;          /* TRUE if lexer is integrated into parser */
  int lxnestingdepth;         /* nesting depth of lexer */
  int lxdebuglevel;           /* error level of lexer */
  const char *lxencoding;     /* lexer encoding */
  char *lexercode;            /* Lexer code appended to the generated file */
  char *tokenctor;            /* Code to execute to create token data */
  struct LxMode *headmode;    /* List of all lexer modes */
  struct LxState *headstate;  /* List of all lexer states */
  const int *lxclasslist;    /* lexer class list */
#endif
};

#define MemoryCheck(X) if((X)==0){ \
  extern void memory_error(); \
  memory_error(); \
}

/**************** From the file "table.h" *********************************/
/*
** All code in this file has been automatically generated
** from a specification in the file
**              "table.q"
** by the associative array code building program "aagen".
** Do not edit this file!  Instead, edit the specification
** file, then rerun aagen.
*/
/*
** Code for processing tables in the LEMON parser generator.
*/
/* Routines for handling a strings */

const char *Strsafe(const char *);

void Strsafe_init(void);
int Strsafe_insert(const char *);
const char *Strsafe_find(const char *);

/* Routines for handling symbols of the grammar */

struct symbol *Symbol_new(const char *);
int Symbolcmpp(const void *, const void *);
void Symbol_init(void);
int Symbol_insert(struct symbol *, const char *);
struct symbol *Symbol_find(const char *);
struct symbol *Symbol_Nth(int);
int Symbol_count(void);
struct symbol **Symbol_arrayof(void);

/* Routines to manage the state table */

int Configcmp(const char *, const char *);
struct state *State_new(void);
void State_init(void);
int State_insert(struct state *, struct config *);
struct state *State_find(struct config *);
struct state **State_arrayof(/*  */);

/* Routines used for efficiency in Configlist_add */

void Configtable_init(void);
int Configtable_insert(struct config *);
struct config *Configtable_find(struct config *);
void Configtable_clear(int(*)(struct config *));

/****************** From the file "action.c" *******************************/
/*
** Routines processing parser actions in the LEMON parser generator.
*/

/* Allocate a new parser action */
static struct action *Action_new(void){
  static struct action *freelist = 0;
  struct action *newaction;

  if( freelist==0 ){
    int i;
    int amt = 100;
    freelist = (struct action *)calloc(amt, sizeof(struct action));
    if( freelist==0 ){
      fprintf(stderr,"Unable to allocate memory for a new parser action.");
      exit(1);
    }
    for(i=0; i<amt-1; i++) freelist[i].next = &freelist[i+1];
    freelist[amt-1].next = 0;
  }
  newaction = freelist;
  freelist = freelist->next;
  return newaction;
}

/* Compare two actions for sorting purposes.  Return negative, zero, or
** positive if the first action is less than, equal to, or greater than
** the first
*/
static int actioncmp(
  struct action *ap1,
  struct action *ap2
){
  int rc;
  rc = ap1->sp->index - ap2->sp->index;
  if( rc==0 ){
    rc = (int)ap1->type - (int)ap2->type;
  }
  if( rc==0 && (ap1->type==REDUCE || ap1->type==SHIFTREDUCE) ){
    rc = ap1->x.rp->index - ap2->x.rp->index;
  }
  if( rc==0 ){
    rc = (int) (ap2 - ap1);
  }
  return rc;
}

/* Sort parser actions */
static struct action *Action_sort(
  struct action *ap
){
  ap = (struct action *)msort((char *)ap,(char **)&ap->next,
                              (int(*)(const char*,const char*))actioncmp);
  return ap;
}

void Action_add(
  struct action **app,
  enum e_action type,
  struct symbol *sp,
  char *arg
){
  struct action *newaction;
  newaction = Action_new();
  newaction->next = *app;
  *app = newaction;
  newaction->type = type;
  newaction->sp = sp;
  if( type==SHIFT ){
    newaction->x.stp = (struct state *)arg;
  }else{
    newaction->x.rp = (struct rule *)arg;
  }
}
/********************** New code to implement the "acttab" module ***********/
/*
** This module implements routines use to construct the yy_action[] table.
*/

/*
** The state of the yy_action table under construction is an instance of
** the following structure.
**
** The yy_action table maps the pair (state_number, lookahead) into an
** action_number.  The table is an array of integers pairs.  The state_number
** determines an initial offset into the yy_action array.  The lookahead
** value is then added to this initial offset to get an index X into the
** yy_action array. If the aAction[X].lookahead equals the value of the
** of the lookahead input, then the value of the action_number output is
** aAction[X].action.  If the lookaheads do not match then the
** default action for the state_number is returned.
**
** All actions associated with a single state_number are first entered
** into aLookahead[] using multiple calls to acttab_action().  Then the
** actions for that single state_number are placed into the aAction[]
** array with a single call to acttab_insert().  The acttab_insert() call
** also resets the aLookahead[] array in preparation for the next
** state number.
*/
struct lookahead_action {
  int lookahead;             /* Value of the lookahead token */
  int action;                /* Action to take on the given lookahead */
};
typedef struct acttab acttab;
struct acttab {
  int nAction;                 /* Number of used slots in aAction[] */
  int nActionAlloc;            /* Slots allocated for aAction[] */
  struct lookahead_action
    *aAction,                  /* The yy_action[] table under construction */
    *aLookahead;               /* A single new transaction set */
  int mnLookahead;             /* Minimum aLookahead[].lookahead */
  int mnAction;                /* Action associated with mnLookahead */
  int mxLookahead;             /* Maximum aLookahead[].lookahead */
  int nLookahead;              /* Used slots in aLookahead[] */
  int nLookaheadAlloc;         /* Slots allocated in aLookahead[] */
};

/* Return the number of entries in the yy_action table */
#define acttab_size(X) ((X)->nAction)

/* The value for the N-th entry in yy_action */
#define acttab_yyaction(X,N)  ((X)->aAction[N].action)

/* The value for the N-th entry in yy_lookahead */
#define acttab_yylookahead(X,N)  ((X)->aAction[N].lookahead)

/* Free all memory associated with the given acttab */
void acttab_free(acttab *p){
  free( p->aAction );
  free( p->aLookahead );
  free( p );
}

/* Allocate a new acttab structure */
acttab *acttab_alloc(void){
  acttab *p = (acttab *) calloc( 1, sizeof(*p) );
  if( p==0 ){
    fprintf(stderr,"Unable to allocate memory for a new acttab.");
    exit(1);
  }
  memset(p, 0, sizeof(*p));
  return p;
}

/* Add a new action to the current transaction set.
**
** This routine is called once for each lookahead for a particular
** state.
*/
void acttab_action(acttab *p, int lookahead, int action){
  if( p->nLookahead>=p->nLookaheadAlloc ){
    p->nLookaheadAlloc += 25;
    p->aLookahead = (struct lookahead_action *) realloc( p->aLookahead,
                             sizeof(p->aLookahead[0])*p->nLookaheadAlloc );
    if( p->aLookahead==0 ){
      fprintf(stderr,"malloc failed\n");
      exit(1);
    }
  }
  if( p->nLookahead==0 ){
    p->mxLookahead = lookahead;
    p->mnLookahead = lookahead;
    p->mnAction = action;
  }else{
    if( p->mxLookahead<lookahead ) p->mxLookahead = lookahead;
    if( p->mnLookahead>lookahead ){
      p->mnLookahead = lookahead;
      p->mnAction = action;
    }
  }
  p->aLookahead[p->nLookahead].lookahead = lookahead;
  p->aLookahead[p->nLookahead].action = action;
  p->nLookahead++;
}

/*
** Add the transaction set built up with prior calls to acttab_action()
** into the current action table.  Then reset the transaction set back
** to an empty set in preparation for a new round of acttab_action() calls.
**
** Return the offset into the action table of the new transaction.
*/
int acttab_insert(acttab *p){
  int i, j, k, n;
  assert( p->nLookahead>0 );

  /* Make sure we have enough space to hold the expanded action table
  ** in the worst case.  The worst case occurs if the transaction set
  ** must be appended to the current action table
  */
  n = p->mxLookahead + 1;
  if( p->nAction + n >= p->nActionAlloc ){
    int oldAlloc = p->nActionAlloc;
    p->nActionAlloc = p->nAction + n + p->nActionAlloc + 20;
    p->aAction = (struct lookahead_action *) realloc( p->aAction,
                          sizeof(p->aAction[0])*p->nActionAlloc);
    if( p->aAction==0 ){
      fprintf(stderr,"malloc failed\n");
      exit(1);
    }
    for(i=oldAlloc; i<p->nActionAlloc; i++){
      p->aAction[i].lookahead = -1;
      p->aAction[i].action = -1;
    }
  }

  /* Scan the existing action table looking for an offset that is a
  ** duplicate of the current transaction set.  Fall out of the loop
  ** if and when the duplicate is found.
  **
  ** i is the index in p->aAction[] where p->mnLookahead is inserted.
  */
  for(i=p->nAction-1; i>=0; i--){
    if( p->aAction[i].lookahead==p->mnLookahead ){
      /* All lookaheads and actions in the aLookahead[] transaction
      ** must match against the candidate aAction[i] entry. */
      if( p->aAction[i].action!=p->mnAction ) continue;
      for(j=0; j<p->nLookahead; j++){
        k = p->aLookahead[j].lookahead - p->mnLookahead + i;
        if( k<0 || k>=p->nAction ) break;
        if( p->aLookahead[j].lookahead!=p->aAction[k].lookahead ) break;
        if( p->aLookahead[j].action!=p->aAction[k].action ) break;
      }
      if( j<p->nLookahead ) continue;

      /* No possible lookahead value that is not in the aLookahead[]
      ** transaction is allowed to match aAction[i] */
      n = 0;
      for(j=0; j<p->nAction; j++){
        if( p->aAction[j].lookahead<0 ) continue;
        if( p->aAction[j].lookahead==j+p->mnLookahead-i ) n++;
      }
      if( n==p->nLookahead ){
        break;  /* An exact match is found at offset i */
      }
    }
  }

  /* If no existing offsets exactly match the current transaction, find an
  ** an empty offset in the aAction[] table in which we can add the
  ** aLookahead[] transaction.
  */
  if( i<0 ){
    /* Look for holes in the aAction[] table that fit the current
    ** aLookahead[] transaction.  Leave i set to the offset of the hole.
    ** If no holes are found, i is left at p->nAction, which means the
    ** transaction will be appended. */
    for(i=0; i<p->nActionAlloc - p->mxLookahead; i++){
      if( p->aAction[i].lookahead<0 ){
        for(j=0; j<p->nLookahead; j++){
          k = p->aLookahead[j].lookahead - p->mnLookahead + i;
          if( k<0 ) break;
          if( p->aAction[k].lookahead>=0 ) break;
        }
        if( j<p->nLookahead ) continue;
        for(j=0; j<p->nAction; j++){
          if( p->aAction[j].lookahead==j+p->mnLookahead-i ) break;
        }
        if( j==p->nAction ){
          break;  /* Fits in empty slots */
        }
      }
    }
  }
  /* Insert transaction set at index i. */
  for(j=0; j<p->nLookahead; j++){
    k = p->aLookahead[j].lookahead - p->mnLookahead + i;
    p->aAction[k] = p->aLookahead[j];
    if( k>=p->nAction ) p->nAction = k+1;
  }
  p->nLookahead = 0;

  /* Return the offset that is added to the lookahead in order to get the
  ** index into yy_action of the action */
  return i - p->mnLookahead;
}

/********************** From the file "build.c" *****************************/
/*
** Routines to construction the finite state machine for the LEMON
** parser generator.
*/

/* Find a precedence symbol of every rule in the grammar.
**
** Those rules which have a precedence symbol coded in the input
** grammar using the "[symbol]" construct will already have the
** rp->precsym field filled.  Other rules take as their precedence
** symbol the first RHS symbol with a defined precedence.  If there
** are not RHS symbols with a defined precedence, the precedence
** symbol field is left blank.
*/
void FindRulePrecedences(struct lemon *xp)
{
  struct rule *rp;
  for(rp=xp->rule; rp; rp=rp->next){
    if( rp->precsym==0 ){
      int i, j;
      for(i=0; i<rp->nrhs && rp->precsym==0; i++){
        struct symbol *sp = rp->rhs[i];
        if( sp->type==MULTITERMINAL ){
          for(j=0; j<sp->nsubsym; j++){
            if( sp->subsym[j]->prec>=0 ){
              rp->precsym = sp->subsym[j];
              break;
            }
          }
        }else if( sp->prec>=0 ){
          rp->precsym = rp->rhs[i];
        }
      }
    }
  }
  return;
}

/* Find all nonterminals which will generate the empty string.
** Then go back and compute the first sets of every nonterminal.
** The first set is the set of all terminal symbols which can begin
** a string generated by that nonterminal.
*/
void FindFirstSets(struct lemon *lemp)
{
  int i, j;
  struct rule *rp;
  int progress;

  for(i=0; i<lemp->nsymbol; i++){
    lemp->symbols[i]->lambda = LEMON_FALSE;
  }
  for(i=lemp->nterminal; i<lemp->nsymbol; i++){
    lemp->symbols[i]->firstset = SetNew();
  }

  /* First compute all lambdas */
  do{
    progress = 0;
    for(rp=lemp->rule; rp; rp=rp->next){
      if( rp->lhs->lambda ) continue;
      for(i=0; i<rp->nrhs; i++){
        struct symbol *sp = rp->rhs[i];
        assert( sp->type==NONTERMINAL || sp->lambda==LEMON_FALSE );
        if( sp->lambda==LEMON_FALSE ) break;
      }
      if( i==rp->nrhs ){
        rp->lhs->lambda = LEMON_TRUE;
        progress = 1;
      }
    }
  }while( progress );

  /* Now compute all first sets */
  do{
    struct symbol *s1, *s2;
    progress = 0;
    for(rp=lemp->rule; rp; rp=rp->next){
      s1 = rp->lhs;
      for(i=0; i<rp->nrhs; i++){
        s2 = rp->rhs[i];
        if( s2->type==TERMINAL ){
          progress += SetAdd(s1->firstset,s2->index);
          break;
        }else if( s2->type==MULTITERMINAL ){
          for(j=0; j<s2->nsubsym; j++){
            progress += SetAdd(s1->firstset,s2->subsym[j]->index);
          }
          break;
        }else if( s1==s2 ){
          if( s1->lambda==LEMON_FALSE ) break;
        }else{
          progress += SetUnion(s1->firstset,s2->firstset);
          if( s2->lambda==LEMON_FALSE ) break;
        }
      }
    }
  }while( progress );
  return;
}

/* Compute all LR(0) states for the grammar.  Links
** are added to between some states so that the LR(1) follow sets
** can be computed later.
*/
PRIVATE struct state *getstate(struct lemon *);  /* forward reference */
void FindStates(struct lemon *lemp)
{
  struct symbol *sp;
  struct rule *rp;

  Configlist_init();

  /* Find the start symbol */
  if( lemp->start ){
    sp = Symbol_find(lemp->start);
    if( sp==0 ){
      ErrorMsg(lemp->filename,0,
"The specified start symbol \"%s\" is not \
in a nonterminal of the grammar.  \"%s\" will be used as the start \
symbol instead.",lemp->start,lemp->rule->lhs->name);
      lemp->errorcnt++;
      sp = lemp->rule->lhs;
    }
  }else{
    sp = lemp->rule->lhs;
  }

  /* Make sure the start symbol doesn't occur on the right-hand side of
  ** any rule.  Report an error if it does.  (YACC would generate a new
  ** start symbol in this case.) */
  for(rp=lemp->rule; rp; rp=rp->next){
    int i;
    for(i=0; i<rp->nrhs; i++){
      if( rp->rhs[i]==sp ){   /* FIX ME:  Deal with multiterminals */
        ErrorMsg(lemp->filename,0,
"The start symbol \"%s\" occurs on the \
right-hand side of a rule. This will result in a parser which \
does not work properly.",sp->name);
        lemp->errorcnt++;
      }
    }
  }

  /* The basis configuration set for the first state
  ** is all rules which have the start symbol as their
  ** left-hand side */
  for(rp=sp->rule; rp; rp=rp->nextlhs){
    struct config *newcfp;
    rp->lhsStart = 1;
    newcfp = Configlist_addbasis(rp,0);
    SetAdd(newcfp->fws,0);
  }

  /* Compute the first state.  All other states will be
  ** computed automatically during the computation of the first one.
  ** The returned pointer to the first state is not used. */
  (void)getstate(lemp);
  return;
}

/* Return a pointer to a state which is described by the configuration
** list which has been built from calls to Configlist_add.
*/
PRIVATE void buildshifts(struct lemon *, struct state *); /* Forwd ref */
PRIVATE struct state *getstate(struct lemon *lemp)
{
  struct config *cfp, *bp;
  struct state *stp;

  /* Extract the sorted basis of the new state.  The basis was constructed
  ** by prior calls to "Configlist_addbasis()". */
  Configlist_sortbasis();
  bp = Configlist_basis();

  /* Get a state with the same basis */
  stp = State_find(bp);
  if( stp ){
    /* A state with the same basis already exists!  Copy all the follow-set
    ** propagation links from the state under construction into the
    ** preexisting state, then return a pointer to the preexisting state */
    struct config *x, *y;
    for(x=bp, y=stp->bp; x && y; x=x->bp, y=y->bp){
      Plink_copy(&y->bplp,x->bplp);
      Plink_delete(x->fplp);
      x->fplp = x->bplp = 0;
    }
    cfp = Configlist_return();
    Configlist_eat(cfp);
  }else{
    /* This really is a new state.  Construct all the details */
    Configlist_closure(lemp);    /* Compute the configuration closure */
    Configlist_sort();           /* Sort the configuration closure */
    cfp = Configlist_return();   /* Get a pointer to the config list */
    stp = State_new();           /* A new state structure */
    MemoryCheck(stp);
    stp->bp = bp;                /* Remember the configuration basis */
    stp->cfp = cfp;              /* Remember the configuration closure */
    stp->statenum = lemp->nstate++; /* Every state gets a sequence number */
    stp->ap = 0;                 /* No actions, yet. */
    State_insert(stp,stp->bp);   /* Add to the state table */
    buildshifts(lemp,stp);       /* Recursively compute successor states */
  }
  return stp;
}

/*
** Return true if two symbols are the same.
*/
int same_symbol(struct symbol *a, struct symbol *b)
{
  int i;
  if( a==b ) return 1;
  if( a->type!=MULTITERMINAL ) return 0;
  if( b->type!=MULTITERMINAL ) return 0;
  if( a->nsubsym!=b->nsubsym ) return 0;
  for(i=0; i<a->nsubsym; i++){
    if( a->subsym[i]!=b->subsym[i] ) return 0;
  }
  return 1;
}

/* Construct all successor states to the given state.  A "successor"
** state is any state which can be reached by a shift action.
*/
PRIVATE void buildshifts(struct lemon *lemp, struct state *stp)
{
  struct config *cfp;  /* For looping thru the config closure of "stp" */
  struct config *bcfp; /* For the inner loop on config closure of "stp" */
  struct config *newcfg;  /* */
  struct symbol *sp;   /* Symbol following the dot in configuration "cfp" */
  struct symbol *bsp;  /* Symbol following the dot in configuration "bcfp" */
  struct state *newstp; /* A pointer to a successor state */

  /* Each configuration becomes complete after it contibutes to a successor
  ** state.  Initially, all configurations are incomplete */
  for(cfp=stp->cfp; cfp; cfp=cfp->next) cfp->status = INCOMPLETE;

  /* Loop through all configurations of the state "stp" */
  for(cfp=stp->cfp; cfp; cfp=cfp->next){
    if( cfp->status==COMPLETE ) continue;    /* Already used by inner loop */
    if( cfp->dot>=cfp->rp->nrhs ) continue;  /* Can't shift this config */
    Configlist_reset();                      /* Reset the new config set */
    sp = cfp->rp->rhs[cfp->dot];             /* Symbol after the dot */

    /* For every configuration in the state "stp" which has the symbol "sp"
    ** following its dot, add the same configuration to the basis set under
    ** construction but with the dot shifted one symbol to the right. */
    for(bcfp=cfp; bcfp; bcfp=bcfp->next){
      if( bcfp->status==COMPLETE ) continue;    /* Already used */
      if( bcfp->dot>=bcfp->rp->nrhs ) continue; /* Can't shift this one */
      bsp = bcfp->rp->rhs[bcfp->dot];           /* Get symbol after dot */
      if( !same_symbol(bsp,sp) ) continue;      /* Must be same as for "cfp" */
      bcfp->status = COMPLETE;                  /* Mark this config as used */
      newcfg = Configlist_addbasis(bcfp->rp,bcfp->dot+1);
      Plink_add(&newcfg->bplp,bcfp);
    }

    /* Get a pointer to the state described by the basis configuration set
    ** constructed in the preceding loop */
    newstp = getstate(lemp);

    /* The state "newstp" is reached from the state "stp" by a shift action
    ** on the symbol "sp" */
    if( sp->type==MULTITERMINAL ){
      int i;
      for(i=0; i<sp->nsubsym; i++){
        Action_add(&stp->ap,SHIFT,sp->subsym[i],(char*)newstp);
      }
    }else{
      Action_add(&stp->ap,SHIFT,sp,(char *)newstp);
    }
  }
}

/*
** Construct the propagation links
*/
void FindLinks(struct lemon *lemp)
{
  int i;
  struct config *cfp, *other;
  struct state *stp;
  struct plink *plp;

  /* Housekeeping detail:
  ** Add to every propagate link a pointer back to the state to
  ** which the link is attached. */
  for(i=0; i<lemp->nstate; i++){
    stp = lemp->sorted[i];
    for(cfp=stp->cfp; cfp; cfp=cfp->next){
      cfp->stp = stp;
    }
  }

  /* Convert all backlinks into forward links.  Only the forward
  ** links are used in the follow-set computation. */
  for(i=0; i<lemp->nstate; i++){
    stp = lemp->sorted[i];
    for(cfp=stp->cfp; cfp; cfp=cfp->next){
      for(plp=cfp->bplp; plp; plp=plp->next){
        other = plp->cfp;
        Plink_add(&other->fplp,cfp);
      }
    }
  }
}

/* Compute all followsets.
**
** A followset is the set of all symbols which can come immediately
** after a configuration.
*/
void FindFollowSets(struct lemon *lemp)
{
  int i;
  struct config *cfp;
  struct plink *plp;
  int progress;
  int change;

  for(i=0; i<lemp->nstate; i++){
    for(cfp=lemp->sorted[i]->cfp; cfp; cfp=cfp->next){
      cfp->status = INCOMPLETE;
    }
  }

  do{
    progress = 0;
    for(i=0; i<lemp->nstate; i++){
      for(cfp=lemp->sorted[i]->cfp; cfp; cfp=cfp->next){
        if( cfp->status==COMPLETE ) continue;
        for(plp=cfp->fplp; plp; plp=plp->next){
          change = SetUnion(plp->cfp->fws,cfp->fws);
          if( change ){
            plp->cfp->status = INCOMPLETE;
            progress = 1;
          }
        }
        cfp->status = COMPLETE;
      }
    }
  }while( progress );
}

static int resolve_conflict(struct action *,struct action *);

/* Compute the reduce actions, and resolve conflicts.
*/
void FindActions(struct lemon *lemp)
{
  int i,j;
  struct config *cfp;
  struct state *stp;
  struct symbol *sp;
  struct rule *rp;

  /* Add all of the reduce actions
  ** A reduce action is added for each element of the followset of
  ** a configuration which has its dot at the extreme right.
  */
  for(i=0; i<lemp->nstate; i++){   /* Loop over all states */
    stp = lemp->sorted[i];
    for(cfp=stp->cfp; cfp; cfp=cfp->next){  /* Loop over all configurations */
      if( cfp->rp->nrhs==cfp->dot ){        /* Is dot at extreme right? */
        for(j=0; j<lemp->nterminal; j++){
          if( SetFind(cfp->fws,j) ){
            /* Add a reduce action to the state "stp" which will reduce by the
            ** rule "cfp->rp" if the lookahead symbol is "lemp->symbols[j]" */
            Action_add(&stp->ap,REDUCE,lemp->symbols[j],(char *)cfp->rp);
          }
        }
      }
    }
  }

  /* Add the accepting token */
  if( lemp->start ){
    sp = Symbol_find(lemp->start);
    if( sp==0 ) sp = lemp->rule->lhs;
  }else{
    sp = lemp->rule->lhs;
  }
  /* Add to the first state (which is always the starting state of the
  ** finite state machine) an action to ACCEPT if the lookahead is the
  ** start nonterminal.  */
  Action_add(&lemp->sorted[0]->ap,ACCEPT,sp,0);

  /* Resolve conflicts */
  for(i=0; i<lemp->nstate; i++){
    struct action *ap, *nap;
    stp = lemp->sorted[i];
    /* assert( stp->ap ); */
    stp->ap = Action_sort(stp->ap);
    for(ap=stp->ap; ap && ap->next; ap=ap->next){
      for(nap=ap->next; nap && nap->sp==ap->sp; nap=nap->next){
         /* The two actions "ap" and "nap" have the same lookahead.
         ** Figure out which one should be used */
         lemp->nconflict += resolve_conflict(ap,nap);
      }
    }
  }

  /* Report an error for each rule that can never be reduced. */
  for(rp=lemp->rule; rp; rp=rp->next) rp->canReduce = LEMON_FALSE;
  for(i=0; i<lemp->nstate; i++){
    struct action *ap;
    for(ap=lemp->sorted[i]->ap; ap; ap=ap->next){
      if( ap->type==REDUCE ) ap->x.rp->canReduce = LEMON_TRUE;
    }
  }
  for(rp=lemp->rule; rp; rp=rp->next){
    if( rp->canReduce ) continue;
    ErrorMsg(lemp->filename,rp->ruleline,"This rule can not be reduced.\n");
    lemp->errorcnt++;
  }
}

/* Resolve a conflict between the two given actions.  If the
** conflict can't be resolved, return non-zero.
**
** NO LONGER TRUE:
**   To resolve a conflict, first look to see if either action
**   is on an error rule.  In that case, take the action which
**   is not associated with the error rule.  If neither or both
**   actions are associated with an error rule, then try to
**   use precedence to resolve the conflict.
**
** If either action is a SHIFT, then it must be apx.  This
** function won't work if apx->type==REDUCE and apy->type==SHIFT.
*/
static int resolve_conflict(
  struct action *apx,
  struct action *apy
){
  struct symbol *spx, *spy;
  int errcnt = 0;
  assert( apx->sp==apy->sp );  /* Otherwise there would be no conflict */
  if( apx->type==SHIFT && apy->type==SHIFT ){
    apy->type = SSCONFLICT;
    errcnt++;
  }
  if( apx->type==SHIFT && apy->type==REDUCE ){
    spx = apx->sp;
    spy = apy->x.rp->precsym;
    if( spy==0 || spx->prec<0 || spy->prec<0 ){
      /* Not enough precedence information. */
      apy->type = SRCONFLICT;
      errcnt++;
    }else if( spx->prec>spy->prec ){    /* higher precedence wins */
      apy->type = RD_RESOLVED;
    }else if( spx->prec<spy->prec ){
      apx->type = SH_RESOLVED;
    }else if( spx->prec==spy->prec && spx->assoc==RIGHT ){ /* Use operator */
      apy->type = RD_RESOLVED;                             /* associativity */
    }else if( spx->prec==spy->prec && spx->assoc==LEFT ){  /* to break tie */
      apx->type = SH_RESOLVED;
    }else{
      assert( spx->prec==spy->prec && spx->assoc==NONE );
      apx->type = ERROR;
    }
  }else if( apx->type==REDUCE && apy->type==REDUCE ){
    spx = apx->x.rp->precsym;
    spy = apy->x.rp->precsym;
    if( spx==0 || spy==0 || spx->prec<0 ||
    spy->prec<0 || spx->prec==spy->prec ){
      apy->type = RRCONFLICT;
      errcnt++;
    }else if( spx->prec>spy->prec ){
      apy->type = RD_RESOLVED;
    }else if( spx->prec<spy->prec ){
      apx->type = RD_RESOLVED;
    }
  }else{
    assert(
      apx->type==SH_RESOLVED ||
      apx->type==RD_RESOLVED ||
      apx->type==SSCONFLICT ||
      apx->type==SRCONFLICT ||
      apx->type==RRCONFLICT ||
      apy->type==SH_RESOLVED ||
      apy->type==RD_RESOLVED ||
      apy->type==SSCONFLICT ||
      apy->type==SRCONFLICT ||
      apy->type==RRCONFLICT
    );
    /* The REDUCE/SHIFT case cannot happen because SHIFTs come before
    ** REDUCEs on the list.  If we reach this point it must be because
    ** the parser conflict had already been resolved. */
  }
  return errcnt;
}
/********************* From the file "configlist.c" *************************/
/*
** Routines to processing a configuration list and building a state
** in the LEMON parser generator.
*/

static struct config *freelist = 0;      /* List of free configurations */
static struct config *current = 0;       /* Top of list of configurations */
static struct config **currentend = 0;   /* Last on list of configs */
static struct config *basis = 0;         /* Top of list of basis configs */
static struct config **basisend = 0;     /* End of list of basis configs */

/* Return a pointer to a new configuration */
PRIVATE struct config *newconfig(){
  struct config *newcfg;
  if( freelist==0 ){
    int i;
    int amt = 3;
    freelist = (struct config *)calloc( amt, sizeof(struct config) );
    if( freelist==0 ){
      fprintf(stderr,"Unable to allocate memory for a new configuration.");
      exit(1);
    }
    for(i=0; i<amt-1; i++) freelist[i].next = &freelist[i+1];
    freelist[amt-1].next = 0;
  }
  newcfg = freelist;
  freelist = freelist->next;
  return newcfg;
}

/* The configuration "old" is no longer used */
PRIVATE void deleteconfig(struct config *old)
{
  old->next = freelist;
  freelist = old;
}

/* Initialized the configuration list builder */
void Configlist_init(){
  current = 0;
  currentend = &current;
  basis = 0;
  basisend = &basis;
  Configtable_init();
  return;
}

/* Initialized the configuration list builder */
void Configlist_reset(){
  current = 0;
  currentend = &current;
  basis = 0;
  basisend = &basis;
  Configtable_clear(0);
  return;
}

/* Add another configuration to the configuration list */
struct config *Configlist_add(
  struct rule *rp,    /* The rule */
  int dot             /* Index into the RHS of the rule where the dot goes */
){
  struct config *cfp, model;

  assert( currentend!=0 );
  model.rp = rp;
  model.dot = dot;
  cfp = Configtable_find(&model);
  if( cfp==0 ){
    cfp = newconfig();
    cfp->rp = rp;
    cfp->dot = dot;
    cfp->fws = SetNew();
    cfp->stp = 0;
    cfp->fplp = cfp->bplp = 0;
    cfp->next = 0;
    cfp->bp = 0;
    *currentend = cfp;
    currentend = &cfp->next;
    Configtable_insert(cfp);
  }
  return cfp;
}

/* Add a basis configuration to the configuration list */
struct config *Configlist_addbasis(struct rule *rp, int dot)
{
  struct config *cfp, model;

  assert( basisend!=0 );
  assert( currentend!=0 );
  model.rp = rp;
  model.dot = dot;
  cfp = Configtable_find(&model);
  if( cfp==0 ){
    cfp = newconfig();
    cfp->rp = rp;
    cfp->dot = dot;
    cfp->fws = SetNew();
    cfp->stp = 0;
    cfp->fplp = cfp->bplp = 0;
    cfp->next = 0;
    cfp->bp = 0;
    *currentend = cfp;
    currentend = &cfp->next;
    *basisend = cfp;
    basisend = &cfp->bp;
    Configtable_insert(cfp);
  }
  return cfp;
}

/* Compute the closure of the configuration list */
void Configlist_closure(struct lemon *lemp)
{
  struct config *cfp, *newcfp;
  struct rule *rp, *newrp;
  struct symbol *sp, *xsp;
  int i, dot;

  assert( currentend!=0 );
  for(cfp=current; cfp; cfp=cfp->next){
    rp = cfp->rp;
    dot = cfp->dot;
    if( dot>=rp->nrhs ) continue;
    sp = rp->rhs[dot];
    if( sp->type==NONTERMINAL ){
      if( sp->rule==0 && sp!=lemp->errsym ){
        ErrorMsg(lemp->filename,rp->line,"Nonterminal \"%s\" has no rules.",
          sp->name);
        lemp->errorcnt++;
      }
      for(newrp=sp->rule; newrp; newrp=newrp->nextlhs){
        newcfp = Configlist_add(newrp,0);
        for(i=dot+1; i<rp->nrhs; i++){
          xsp = rp->rhs[i];
          if( xsp->type==TERMINAL ){
            SetAdd(newcfp->fws,xsp->index);
            break;
          }else if( xsp->type==MULTITERMINAL ){
            int k;
            for(k=0; k<xsp->nsubsym; k++){
              SetAdd(newcfp->fws, xsp->subsym[k]->index);
            }
            break;
          }else{
            SetUnion(newcfp->fws,xsp->firstset);
            if( xsp->lambda==LEMON_FALSE ) break;
          }
        }
        if( i==rp->nrhs ) Plink_add(&cfp->fplp,newcfp);
      }
    }
  }
  return;
}

/* Sort the configuration list */
void Configlist_sort(){
  current = (struct config*)msort((char*)current,(char**)&(current->next),
                                  Configcmp);
  currentend = 0;
  return;
}

/* Sort the basis configuration list */
void Configlist_sortbasis(){
  basis = (struct config*)msort((char*)current,(char**)&(current->bp),
                                Configcmp);
  basisend = 0;
  return;
}

/* Return a pointer to the head of the configuration list and
** reset the list */
struct config *Configlist_return(){
  struct config *old;
  old = current;
  current = 0;
  currentend = 0;
  return old;
}

/* Return a pointer to the head of the configuration list and
** reset the list */
struct config *Configlist_basis(){
  struct config *old;
  old = basis;
  basis = 0;
  basisend = 0;
  return old;
}

/* Free all elements of the given configuration list */
void Configlist_eat(struct config *cfp)
{
  struct config *nextcfp;
  for(; cfp; cfp=nextcfp){
    nextcfp = cfp->next;
    assert( cfp->fplp==0 );
    assert( cfp->bplp==0 );
    if( cfp->fws ) SetFree(cfp->fws);
    deleteconfig(cfp);
  }
  return;
}
/***************** From the file "error.c" *********************************/
/*
** Code for printing error message.
*/

void ErrorMsg(const char *filename, int lineno, const char *format, ...){
  va_list ap;
  fprintf(stderr, "%s:%d: ", filename, lineno);
  va_start(ap, format);
  vfprintf(stderr,format,ap);
  va_end(ap);
  fprintf(stderr, "\n");
}
/**************** From the file "main.c" ************************************/
/*
** Main program file for the LEMON parser generator.
*/

/* Report an out-of-memory condition and abort.  This function
** is used mostly by the "MemoryCheck" macro in struct.h
*/
void memory_error(){
  fprintf(stderr,"Out of memory.  Aborting...\n");
  exit(1);
}

static int nDefine = 0;      /* Number of -D options on the command line */
static char **azDefine = 0;  /* Name of the -D macros */

/* This routine is called with the argument to each -D command-line option.
** Add the macro defined to the azDefine array.
*/
static void handle_D_option(char *z){
  char **paz;
  nDefine++;
  azDefine = (char **) realloc(azDefine, sizeof(azDefine[0])*nDefine);
  if( azDefine==0 ){
    fprintf(stderr,"out of memory\n");
    exit(1);
  }
  paz = &azDefine[nDefine-1];
  *paz = (char *) malloc( lemonStrlen(z)+1 );
  if( *paz==0 ){
    fprintf(stderr,"out of memory\n");
    exit(1);
  }
  lemon_strcpy(*paz, z);
  for(z=*paz; *z && *z!='='; z++){}
  *z = 0;
}

static char *user_templatename = NULL;
static void handle_T_option(char *z){
  user_templatename = (char *) malloc( lemonStrlen(z)+1 );
  if( user_templatename==0 ){
    memory_error();
  }
  lemon_strcpy(user_templatename, z);
}

/* forward reference */
static const char *minimum_size_type(int lwr, int upr, int *pnByte);

/* Print a single line of the "Parser Stats" output
*/
static void stats_line(const char *zLabel, int iValue){
  int nLabel = lemonStrlen(zLabel);
  printf("  %s%.*s %5d\n", zLabel,
         35-nLabel, "................................",
         iValue);
}

#ifdef LEMONEX
#define OFILE_LEN 256
static char ofileext[OFILE_LEN];
static char ofiledir[OFILE_LEN];

static void handle_e_option(char *z){
    strncpy(ofileext, z, OFILE_LEN);
}

static void handle_d_option(char *z){
#if defined(_WIN32)
    int rv = _mkdir(z);
#else
    int rv = mkdir(z, S_IRWXU | S_IRGRP | S_IROTH);
#endif
    if((rv == -1) && (errno != EEXIST)) {
      printf("Error creating directory(%d):%s\n", rv, z);
      exit(1);
    }
    strncpy(ofiledir, z, OFILE_LEN);
}
#endif

/* The main program.  Parse the command line and do it... */
int main(int argc, char **argv)
{
  static int version = 0;
  static int rpflag = 0;
  static int basisflag = 0;
  static int compress = 0;
  static int quiet = 0;
  static int statistics = 0;
  static int mhflag = 0;
  static int nolinenosflag = 0;
  static int noResort = 0;
  static struct s_options options[] = {
    {OPT_FLAG, "b", (char*)&basisflag, "Print only the basis in report."},
    {OPT_FLAG, "c", (char*)&compress, "Don't compress the action table."},
    {OPT_FSTR, "D", (char*)handle_D_option, "Define an %ifdef macro."},
    {OPT_FSTR, "f", 0, "Ignored.  (Placeholder for -f compiler options.)"},
    {OPT_FLAG, "g", (char*)&rpflag, "Print grammar without actions."},
    {OPT_FSTR, "I", 0, "Ignored.  (Placeholder for '-I' compiler options.)"},
    {OPT_FLAG, "m", (char*)&mhflag, "Output a makeheaders compatible file."},
    {OPT_FLAG, "l", (char*)&nolinenosflag, "Do not print #line statements."},
    {OPT_FSTR, "O", 0, "Ignored.  (Placeholder for '-O' compiler options.)"},
    {OPT_FLAG, "p", (char*)&showPrecedenceConflict,
                    "Show conflicts resolved by precedence rules"},
    {OPT_FLAG, "q", (char*)&quiet, "(Quiet) Don't print the report file."},
    {OPT_FLAG, "r", (char*)&noResort, "Do not sort or renumber states"},
    {OPT_FLAG, "s", (char*)&statistics,
                                   "Print parser stats to standard output."},
    {OPT_FLAG, "x", (char*)&version, "Print the version number."},
    {OPT_FSTR, "T", (char*)handle_T_option, "Specify a template file."},
    {OPT_FSTR, "W", 0, "Ignored.  (Placeholder for '-W' compiler options.)"},
#ifdef LEMONEX
    {OPT_FSTR, "e", (char*)handle_e_option, "Output file extension."},
    {OPT_FSTR, "d", (char*)handle_d_option, "Output directory."},
#endif
    {OPT_FLAG,0,0,0}
  };
  int i;
  int exitcode;
  struct lemon lem;

#ifdef LEMONEX
  strncpy(ofileext, ".c", OFILE_LEN);
  if (handle_d_option) strcpy(ofiledir,"./");
#endif

  OptInit(argv,options,stderr);
  if( version ){
     printf("Lemon version 1.0\n");
     exit(0);
  }
  if( OptNArgs()!=1 ){
    fprintf(stderr,"Exactly one filename argument is required.\n");
    exit(1);
  }
  memset(&lem, 0, sizeof(lem));
  lem.errorcnt = 0;

  /* Initialize the machine */
  Strsafe_init();
  Symbol_init();
  State_init();
  lem.argv0 = argv[0];
  lem.filename = OptArg(0);
  lem.basisflag = basisflag;
  lem.nolinenosflag = nolinenosflag;
  Symbol_new("$");
  lem.errsym = Symbol_new("error");
  lem.errsym->useCnt = 0;
#ifdef LEMONEX
  lem.lxintegration = 1;
  lem.lxnestingdepth = 32;
  lem.lxdebuglevel = 0;
  lem.lxencoding = 0;
  lem.headmode = 0;
  lem.headstate = 0;
  lem.tokenctor = 0;
  lem.lxclasslist = s_lxclasslist;
#endif

  /* Parse the input file */
  Parse(&lem);
  if( lem.errorcnt ) exit(lem.errorcnt);
  if( lem.nrule==0 ){
    fprintf(stderr,"Empty grammar.\n");
    exit(1);
  }

  /* Count and index the symbols of the grammar */
  Symbol_new("{default}");
  lem.nsymbol = Symbol_count();
  lem.symbols = Symbol_arrayof();
  for(i=0; i<lem.nsymbol; i++) lem.symbols[i]->index = i;
  qsort(lem.symbols,lem.nsymbol,sizeof(struct symbol*), Symbolcmpp);
  for(i=0; i<lem.nsymbol; i++) lem.symbols[i]->index = i;
  while( lem.symbols[i-1]->type==MULTITERMINAL ){ i--; }
  assert( strcmp(lem.symbols[i-1]->name,"{default}")==0 );
  lem.nsymbol = i - 1;
  for(i=1; isupper(lem.symbols[i]->name[0]); i++);
  lem.nterminal = i;

  /* Generate a reprint of the grammar, if requested on the command line */
  if( rpflag ){
    Reprint(&lem);
  }else{
    /* Initialize the size for all follow and first sets */
    SetSize(lem.nterminal+1);

    /* Find the precedence for every production rule (that has one) */
    FindRulePrecedences(&lem);

    /* Compute the lambda-nonterminals and the first-sets for every
    ** nonterminal */
    FindFirstSets(&lem);

    /* Compute all LR(0) states.  Also record follow-set propagation
    ** links so that the follow-set can be computed later */
    lem.nstate = 0;
    FindStates(&lem);
    lem.sorted = State_arrayof();

    /* Tie up loose ends on the propagation links */
    FindLinks(&lem);

    /* Compute the follow set of every reducible configuration */
    FindFollowSets(&lem);

    /* Compute the action tables */
    FindActions(&lem);

    /* Compress the action tables */
    if( compress==0 ) CompressTables(&lem);

    /* Reorder and renumber the states so that states with fewer choices
    ** occur at the end.  This is an optimization that helps make the
    ** generated parser tables smaller. */
    if( noResort==0 ) ResortStates(&lem);

    /* Generate a report of the parser generated.  (the "y.output" file) */
    if( !quiet ) ReportOutput(&lem);

    /* Generate the source code for the parser */
    ReportTable(&lem, mhflag);

#ifndef LEMONEX
    /* Produce a header file for use by the scanner.  (This step is
    ** omitted if the "-m" option is used because makeheaders will
    ** generate the file for us.) */
    /* this is not done in LEMONEX mode since the .c file is self-contained */
    if( !mhflag ) ReportHeader(&lem);
#endif
  }
  if( statistics ){
    printf("Parser statistics:\n");
    stats_line("terminal symbols", lem.nterminal);
    stats_line("non-terminal symbols", lem.nsymbol - lem.nterminal);
    stats_line("total symbols", lem.nsymbol);
    stats_line("rules", lem.nrule);
    stats_line("states", lem.nxstate);
    stats_line("conflicts", lem.nconflict);
    stats_line("action table entries", lem.nactiontab);
    stats_line("total table size (bytes)", lem.tablesize);
  }
  if( lem.nconflict > 0 ){
    fprintf(stderr,"%d parsing conflicts.\n",lem.nconflict);
  }

  /* return 0 on success, 1 on failure. */
  exitcode = ((lem.errorcnt > 0) || (lem.nconflict > 0)) ? 1 : 0;
  exit(exitcode);
  return (exitcode);
}
/******************** From the file "msort.c" *******************************/
/*
** A generic merge-sort program.
**
** USAGE:
** Let "ptr" be a pointer to some structure which is at the head of
** a null-terminated list.  Then to sort the list call:
**
**     ptr = msort(ptr,&(ptr->next),cmpfnc);
**
** In the above, "cmpfnc" is a pointer to a function which compares
** two instances of the structure and returns an integer, as in
** strcmp.  The second argument is a pointer to the pointer to the
** second element of the linked list.  This address is used to compute
** the offset to the "next" field within the structure.  The offset to
** the "next" field must be constant for all structures in the list.
**
** The function returns a new pointer which is the head of the list
** after sorting.
**
** ALGORITHM:
** Merge-sort.
*/

/*
** Return a pointer to the next structure in the linked list.
*/
#define NEXT(A) (*(char**)(((char*)A)+offset))

/*
** Inputs:
**   a:       A sorted, null-terminated linked list.  (May be null).
**   b:       A sorted, null-terminated linked list.  (May be null).
**   cmp:     A pointer to the comparison function.
**   offset:  Offset in the structure to the "next" field.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   of both a and b.
**
** Side effects:
**   The "next" pointers for elements in the lists a and b are
**   changed.
*/
static char *merge(
  char *a,
  char *b,
  int (*cmp)(const char*,const char*),
  int offset
){
  char *ptr, *head;

  if( a==0 ){
    head = b;
  }else if( b==0 ){
    head = a;
  }else{
    if( (*cmp)(a,b)<=0 ){
      ptr = a;
      a = NEXT(a);
    }else{
      ptr = b;
      b = NEXT(b);
    }
    head = ptr;
    while( a && b ){
      if( (*cmp)(a,b)<=0 ){
        NEXT(ptr) = a;
        ptr = a;
        a = NEXT(a);
      }else{
        NEXT(ptr) = b;
        ptr = b;
        b = NEXT(b);
      }
    }
    if( a ) NEXT(ptr) = a;
    else    NEXT(ptr) = b;
  }
  return head;
}

/*
** Inputs:
**   list:      Pointer to a singly-linked list of structures.
**   next:      Pointer to pointer to the second element of the list.
**   cmp:       A comparison function.
**
** Return Value:
**   A pointer to the head of a sorted list containing the elements
**   orginally in list.
**
** Side effects:
**   The "next" pointers for elements in list are changed.
*/
#define LISTSIZE 30
static char *msort(
  char *list,
  char **next,
  int (*cmp)(const char*,const char*)
){
  unsigned long offset;
  char *ep;
  char *set[LISTSIZE];
  int i;
  offset = (unsigned long)((char*)next - (char*)list);
  for(i=0; i<LISTSIZE; i++) set[i] = 0;
  while( list ){
    ep = list;
    list = NEXT(list);
    NEXT(ep) = 0;
    for(i=0; i<LISTSIZE-1 && set[i]!=0; i++){
      ep = merge(ep,set[i],cmp,offset);
      set[i] = 0;
    }
    set[i] = ep;
  }
  ep = 0;
  for(i=0; i<LISTSIZE; i++) if( set[i] ) ep = merge(set[i],ep,cmp,offset);
  return ep;
}
/************************ From the file "option.c" **************************/
static char **argv;
static struct s_options *op;
static FILE *errstream;

#define ISOPT(X) ((X)[0]=='-'||(X)[0]=='+'||strchr((X),'=')!=0)

/*
** Print the command line with a carrot pointing to the k-th character
** of the n-th field.
*/
static void errline(int n, int k, FILE *err)
{
  int spcnt, i;
  if( argv[0] ) fprintf(err,"%s",argv[0]);
  spcnt = lemonStrlen(argv[0]) + 1;
  for(i=1; i<n && argv[i]; i++){
    fprintf(err," %s",argv[i]);
    spcnt += lemonStrlen(argv[i])+1;
  }
  spcnt += k;
  for(; argv[i]; i++) fprintf(err," %s",argv[i]);
  if( spcnt<20 ){
    fprintf(err,"\n%*s^-- here\n",spcnt,"");
  }else{
    fprintf(err,"\n%*shere --^\n",spcnt-7,"");
  }
}

/*
** Return the index of the N-th non-switch argument.  Return -1
** if N is out of range.
*/
static int argindex(int n)
{
  int i;
  int dashdash = 0;
  if( argv!=0 && *argv!=0 ){
    for(i=1; argv[i]; i++){
      if( dashdash || !ISOPT(argv[i]) ){
        if( n==0 ) return i;
        n--;
      }
      if( strcmp(argv[i],"--")==0 ) dashdash = 1;
    }
  }
  return -1;
}

static char emsg[] = "Command line syntax error: ";

/*
** Process a flag command line argument.
*/
static int handleflags(int i, FILE *err)
{
  int v;
  int errcnt = 0;
  int j;
  for(j=0; op[j].label; j++){
    if( strncmp(&argv[i][1],op[j].label,lemonStrlen(op[j].label))==0 ) break;
  }
  v = argv[i][0]=='-' ? 1 : 0;
  if( op[j].label==0 ){
    if( err ){
      fprintf(err,"%sundefined option.\n",emsg);
      errline(i,1,err);
    }
    errcnt++;
  }else if( op[j].arg==0 ){
    /* Ignore this option */
  }else if( op[j].type==OPT_FLAG ){
    *((int*)op[j].arg) = v;
  }else if( op[j].type==OPT_FFLAG ){
    (*(void(*)(int))(op[j].arg))(v);
  }else if( op[j].type==OPT_FSTR ){
    (*(void(*)(char *))(op[j].arg))(&argv[i][2]);
  }else{
    if( err ){
      fprintf(err,"%smissing argument on switch.\n",emsg);
      errline(i,1,err);
    }
    errcnt++;
  }
  return errcnt;
}

/*
** Process a command line switch which has an argument.
*/
static int handleswitch(int i, FILE *err)
{
  int lv = 0;
  double dv = 0.0;
  char *sv = 0, *end;
  char *cp;
  int j;
  int errcnt = 0;
  cp = strchr(argv[i],'=');
  assert( cp!=0 );
  *cp = 0;
  for(j=0; op[j].label; j++){
    if( strcmp(argv[i],op[j].label)==0 ) break;
  }
  *cp = '=';
  if( op[j].label==0 ){
    if( err ){
      fprintf(err,"%sundefined option.\n",emsg);
      errline(i,0,err);
    }
    errcnt++;
  }else{
    cp++;
    switch( op[j].type ){
      case OPT_FLAG:
      case OPT_FFLAG:
        if( err ){
          fprintf(err,"%soption requires an argument.\n",emsg);
          errline(i,0,err);
        }
        errcnt++;
        break;
      case OPT_DBL:
      case OPT_FDBL:
        dv = strtod(cp,&end);
        if( *end ){
          if( err ){
            fprintf(err,
               "%sillegal character in floating-point argument.\n",emsg);
            errline(i,(int)((char*)end-(char*)argv[i]),err);
          }
          errcnt++;
        }
        break;
      case OPT_INT:
      case OPT_FINT:
        lv = strtol(cp,&end,0);
        if( *end ){
          if( err ){
            fprintf(err,"%sillegal character in integer argument.\n",emsg);
            errline(i,(int)((char*)end-(char*)argv[i]),err);
          }
          errcnt++;
        }
        break;
      case OPT_STR:
      case OPT_FSTR:
        sv = cp;
        break;
    }
    switch( op[j].type ){
      case OPT_FLAG:
      case OPT_FFLAG:
        break;
      case OPT_DBL:
        *(double*)(op[j].arg) = dv;
        break;
      case OPT_FDBL:
        (*(void(*)(double))(op[j].arg))(dv);
        break;
      case OPT_INT:
        *(int*)(op[j].arg) = lv;
        break;
      case OPT_FINT:
        (*(void(*)(int))(op[j].arg))((int)lv);
        break;
      case OPT_STR:
        *(char**)(op[j].arg) = sv;
        break;
      case OPT_FSTR:
        (*(void(*)(char *))(op[j].arg))(sv);
        break;
    }
  }
  return errcnt;
}

int OptInit(char **a, struct s_options *o, FILE *err)
{
  int errcnt = 0;
  argv = a;
  op = o;
  errstream = err;
  if( argv && *argv && op ){
    int i;
    for(i=1; argv[i]; i++){
      if( argv[i][0]=='+' || argv[i][0]=='-' ){
        errcnt += handleflags(i,err);
      }else if( strchr(argv[i],'=') ){
        errcnt += handleswitch(i,err);
      }
    }
  }
  if( errcnt>0 ){
    fprintf(err,"Valid command line options for \"%s\" are:\n",*a);
    OptPrint();
    exit(1);
  }
  return 0;
}

int OptNArgs(){
  int cnt = 0;
  int dashdash = 0;
  int i;
  if( argv!=0 && argv[0]!=0 ){
    for(i=1; argv[i]; i++){
      if( dashdash || !ISOPT(argv[i]) ) cnt++;
      if( strcmp(argv[i],"--")==0 ) dashdash = 1;
    }
  }
  return cnt;
}

char *OptArg(int n)
{
  int i;
  i = argindex(n);
  return i>=0 ? argv[i] : 0;
}

void OptErr(int n)
{
  int i;
  i = argindex(n);
  if( i>=0 ) errline(i,0,errstream);
}

void OptPrint(){
  int i;
  int max, len;
  max = 0;
  for(i=0; op[i].label; i++){
    len = lemonStrlen(op[i].label) + 1;
    switch( op[i].type ){
      case OPT_FLAG:
      case OPT_FFLAG:
        break;
      case OPT_INT:
      case OPT_FINT:
        len += 9;       /* length of "<integer>" */
        break;
      case OPT_DBL:
      case OPT_FDBL:
        len += 6;       /* length of "<real>" */
        break;
      case OPT_STR:
      case OPT_FSTR:
        len += 8;       /* length of "<string>" */
        break;
    }
    if( len>max ) max = len;
  }
  for(i=0; op[i].label; i++){
    switch( op[i].type ){
      case OPT_FLAG:
      case OPT_FFLAG:
        fprintf(errstream,"  -%-*s  %s\n",max,op[i].label,op[i].message);
        break;
      case OPT_INT:
      case OPT_FINT:
        fprintf(errstream,"  -%s<integer>%*s  %s\n",op[i].label,
          (int)(max-lemonStrlen(op[i].label)-9),"",op[i].message);
        break;
      case OPT_DBL:
      case OPT_FDBL:
        fprintf(errstream,"  -%s<real>%*s  %s\n",op[i].label,
          (int)(max-lemonStrlen(op[i].label)-6),"",op[i].message);
        break;
      case OPT_STR:
      case OPT_FSTR:
        fprintf(errstream,"  -%s<string>%*s  %s\n",op[i].label,
          (int)(max-lemonStrlen(op[i].label)-8),"",op[i].message);
        break;
    }
  }
}
/*********************** From the file "parse.c" ****************************/
/*
** Input file parser for the LEMON parser generator.
*/

/* The state of the parser */
enum e_state {
  INITIALIZE,
  WAITING_FOR_DECL_OR_RULE,
  WAITING_FOR_DECL_KEYWORD,
  WAITING_FOR_DECL_ARG,
  WAITING_FOR_PRECEDENCE_SYMBOL,
  WAITING_FOR_ARROW,
  IN_RHS,
  LHS_ALIAS_1,
  LHS_ALIAS_2,
  LHS_ALIAS_3,
  RHS_ALIAS_1,
  RHS_ALIAS_2,
  PRECEDENCE_MARK_1,
  PRECEDENCE_MARK_2,
  RESYNC_AFTER_RULE_ERROR,
  RESYNC_AFTER_DECL_ERROR,
  WAITING_FOR_DESTRUCTOR_SYMBOL,
  WAITING_FOR_DATATYPE_SYMBOL,
  WAITING_FOR_FALLBACK_ID,
  WAITING_FOR_WILDCARD_ID,
  WAITING_FOR_CLASS_ID,
  WAITING_FOR_CLASS_TOKEN
#ifdef LEMONEX
  ,
  WAITING_FOR_INTEGRATIONMODE_1,
  WAITING_FOR_INTEGRATIONMODE_2,
  WAITING_FOR_NESTINGDEPTH_1,
  WAITING_FOR_NESTINGDEPTH_2,
  WAITING_FOR_ENCODING_ID_1,
  WAITING_FOR_ENCODING_ID_2,
  WAITING_FOR_ARROW_LEX,
  IN_REGEX,
  IN_NEXTMODE,
  NEXT_MODE_1,
  WAITING_FOR_MODE_ID_1,
  WAITING_FOR_MODE_ID_2,
  WAITING_FOR_DEBUG_LEVEL_1,
  WAITING_FOR_DEBUG_LEVEL_2,
#endif
};
struct pstate {
  char *filename;       /* Name of the input file */
  int tokenlineno;      /* Linenumber at which current token starts */
  int errorcnt;         /* Number of errors so far */
  char *tokenstart;     /* Text of current token */
  struct lemon *gp;     /* Global state vector */
  enum e_state state;        /* The state of the parser */
  struct symbol *fallback;   /* The fallback token */
  struct symbol *tkclass;    /* Token class symbol */
  struct symbol *lhs;        /* Left-hand side of current rule */
  const char *lhsalias;      /* Alias for the LHS */
  int nrhs;                  /* Number of right-hand side symbols seen */
  struct symbol *rhs[MAXRHS];  /* RHS symbols */
  const char *alias[MAXRHS]; /* Aliases for each RHS symbol (or NULL) */
  struct rule *prevrule;     /* Previous rule parsed */
  const char *declkeyword;   /* Keyword of a declaration */
  char **declargslot;        /* Where the declaration argument should be put */
  int insertLineMacro;       /* Add #line before declaration insert */
  int *decllinenoslot;       /* Where to write declaration line number */
  enum e_assoc declassoc;    /* Assign this association to decl arguments */
  int preccounter;           /* Assign this precedence to decl arguments */
  struct rule *firstrule;    /* Pointer to first rule in the grammar */
  struct rule *lastrule;     /* Pointer to the most recently parsed rule */
#ifdef LEMONEX
  int is_defininglx;          /* 1 if currently defining a lexer token */
  int next_lxstate_id;        /* next available lexer state number */
  struct LxMode *first_mode;  /* Pointer to first mode in the lexer */
  struct LxMode *last_mode;   /* Pointer to last mode in the lexer */
  struct LxState *first_state;/* Pointer to first state in parser */
  struct LxState *last_state; /* Pointer to last state in last mode */
  struct LxState *curr_state; /* Pointer to last state in current regex */
  struct symbol *lastlxsym;   /* Pointer to current lexer symbol being defined */
  int nstarcount;             /* count of regex parts that are not root-level star regexes */
  int is_capturing;           /* 1 if current regex is capturing */
#endif
};

#ifdef LEMONEX
#define LXCLASS_LETTER 1
#define LXCLASS_DIGIT 2
#define LXCLASS_WORD 3
#define LXCLASS_SPACE 4
#define LXCLASS_DOT 5
#define LXCLASS_LAST (LXCLASS_DOT)

#define MASKBITS   0x3F
#define MASK1BYTES 0x80
#define MASK2BYTES 0xC0
#define MASK3BYTES 0xE0
#define MASK4BYTES 0xF0
#define MASK5BYTES 0xF8
#define MASK6BYTES 0xFC

/* read one utf8 char */
int lxUtf8_nextchar(const char *p, int *offset) {
  int ch = 0;
  *offset = 0;

  if(*p == 0) {
    // error
  } else if((*p & MASK6BYTES) == MASK6BYTES) {
    // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
    ch = ((*p & 0x01) << 30) | ( (*(p+1) & MASKBITS) << 24) | ( (*(p+2) & MASKBITS) << 18) | ( (*(p+3) & MASKBITS) << 12) | ( (*(p+4) & MASKBITS) << 6) | (*(p+5) & MASKBITS);
    *offset = 6;
  } else if((*p & MASK5BYTES) == MASK5BYTES) {
    // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
    ch = ((*p & 0x03) << 24) | ( (*(p+1) & MASKBITS) << 18) | ( (*(p+2) & MASKBITS) << 12) | ( (*(p+3) & MASKBITS) << 6) | (*(p+4) & MASKBITS);
    *offset = 5;
  } else if((*p & MASK4BYTES) == MASK4BYTES) {
    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    ch = ((*p & 0x07) << 18) | ( (*(p+1) & MASKBITS) << 12) | ( (*(p+2) & MASKBITS) << 6) | (*(p+3) & MASKBITS);
    *offset = 4;
  } else if((*p & MASK3BYTES) == MASK3BYTES) {
    // 1110xxxx 10xxxxxx 10xxxxxx
    ch = ((*p & 0x0F) << 12) | ( (*(p+1) & MASKBITS) << 6) | (*(p+2) & MASKBITS);
    *offset = 3;
  } else if((*p & MASK2BYTES) == MASK2BYTES) {
    // 110xxxxx 10xxxxxx
    ch = ((*p & 0x1F) << 6) | (*(p+1) & MASKBITS);
    *offset = 2;
  } else {
    // 0xxxxxxx
    ch = (*p & 0xff);
    *offset = 1;
  }

  return ch;
}

/* convert unicode to utf8 */
int lxUtf8_str(int ch, int display_mode, char *p) {
  // 0b1xxxxx
  if((display_mode == 1) && (ch < 0x20)) {
    *(p++) = '0';
    *(p++) = 'x';
    char c1;
    c1 = (ch >> 4) & 0x0f;
    if(c1 >= 10) {
      c1 += ('a' - 10);
    }else{
      c1 += '0';
    }
    *(p++) = c1;
    c1 = ch & 0x0f;
    if(c1 >= 10) {
      c1 += ('a' - 10);
    }else{
      c1 += '0';
    }
    *(p++) = c1;
    return 4;
  }
  // 0xxxxxxx
  else if(ch < 0x80) {
    *(p++) = (char)(ch);
    return 1;
  }
  // 110xxxxx 10xxxxxx
  else if(ch < 0x800) {
    *(p++) = (char)(MASK2BYTES | (ch >> 6));
    *(p++) = (char)(MASK1BYTES | (ch & MASKBITS));
    return 2;
  }
  // 1110xxxx 10xxxxxx 10xxxxxx
  else if(ch < 0x10000) {
    *(p++) = (char)(MASK3BYTES | (ch >> 12));
    *(p++) = (char)(MASK1BYTES | (ch >> 6 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch & MASKBITS));
    return 3;
  }
  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
  else if(ch < 0x200000) {
    *(p++) = (char)(MASK4BYTES | (ch >> 18));
    *(p++) = (char)(MASK1BYTES | (ch >> 12 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch >> 6 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch & MASKBITS));
    return 4;
  }
  // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
  else if(ch < 0x4000000) {
    *(p++) = (char)(MASK5BYTES | (ch >> 24));
    *(p++) = (char)(MASK1BYTES | (ch >> 18 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch >> 12 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch >> 6 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch & MASKBITS));
    return 5;
  }
  // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
  else if(ch < 0x8000000) {
    *(p++) = (char)(MASK6BYTES | (ch >> 30));
    *(p++) = (char)(MASK1BYTES | (ch >> 18 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch >> 12 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch >> 6 & MASKBITS));
    *(p++) = (char)(MASK1BYTES | (ch & MASKBITS));
    return 6;
  }
  printf("INTERNAL ERROR: Malformed unicode character: %d\n", ch);
  exit(1);
}

int lx_lookahead(struct LxScanner *s){
//  printf("LA:%d(%c)\n", *(s->p), *(s->p));
  if(s->ch == 0){
    s->ch = lxUtf8_nextchar(s->p, &(s->offset));
  }
  return s->ch;
}

void lx_advance(struct LxScanner *s){
//  printf("CONSUME: %d(%c)\n", **p, **p);
  (s->p) += s->offset;
  s->ch = 0;
  s->offset = 0;
}

/* search for existing lexer mode */
struct LxMode *LxMode_find(struct lemon *lemp, const char *mode_name){
  struct LxMode *new_mode = 0;

  new_mode = lemp->headmode;
  while(new_mode != 0){
    if((new_mode->name == 0) && (mode_name == 0)){
      return new_mode;
    }
    if(strcmp(new_mode->name, mode_name) == 0){
      return new_mode;
    }
    new_mode = new_mode->next_mode;
  }

  return 0;
}

/* add new lexer mode */
struct LxState *LxState_create(struct pstate *psp){
  struct LxState *new_state = (struct LxState *)malloc(sizeof(struct LxState));
  new_state->state_id = ++(psp->next_lxstate_id);
  new_state->is_leaf = 0;
  new_state->is_loop_head = 0;
  new_state->is_loop_enter = 0;
  new_state->is_loop_return = 0;
  new_state->is_processed = 0;
  new_state->matchedsym = 0;
  new_state->init_mode = 0;
  new_state->next_mode = 0;
  new_state->code = 0;
  new_state->star_state = 0;
  new_state->drop_state = 0;
  new_state->goto_state = 0;
  new_state->not_transition = 0;
  new_state->dot_transition = 0;
  new_state->head_transition = 0;
  new_state->next_state = 0;
  if(psp->last_state == 0){
    psp->first_state = new_state;
  }else{
    psp->last_state->next_state = new_state;
  }
  psp->last_state = new_state;
  return new_state;
}

struct LxTransition *LxTransition_create(struct pstate *psp, int ch0, int ch1, int tx_type, int is_capturing, struct LxState *next_state){
  struct LxTransition *new_transition = (struct LxTransition *)malloc(sizeof(struct LxTransition));
  new_transition->ch0 = ch0;
  new_transition->ch1 = ch1;
  new_transition->tx_type = tx_type;
  new_transition->is_drop = 0;
  new_transition->is_capturing = is_capturing;
  new_transition->is_loop_set = 0;
  new_transition->next_state = next_state;
  new_transition->next_transition = 0;
  return new_transition;
}

struct LxMode *LxMode_new(struct pstate *psp, const char *mode_name){
  struct LxMode *new_mode = LxMode_find(psp->gp, mode_name);
  if(new_mode != 0){
    return new_mode;
  }

  /* if not found, create new mode */
  new_mode = (struct LxMode*)calloc(1, sizeof(struct LxMode) );
  if(new_mode == 0){
    ErrorMsg(psp->filename,psp->tokenlineno,
      "Out of memory allocating new lexer transition.");
    psp->errorcnt++;
    return 0;
  }
  MemoryCheck(new_mode);
  new_mode->name = mode_name;
  new_mode->init_state = LxState_create(psp);
  new_mode->is_nesting = 0;
  new_mode->next_mode = 0;

  /* add it to mode list */
  if(psp->first_mode == 0){
    psp->first_mode = new_mode;
    psp->last_mode = new_mode;
  }else{
    psp->last_mode->next_mode = new_mode;
    psp->last_mode = new_mode;
  }
  return new_mode;
}

struct LxAstNode *LxNode_create(int node_type, struct LxAstNode *lhs, struct LxAstNode *rhs, int ch0, int ch1){
  struct LxAstNode *node = (struct LxAstNode *)malloc(sizeof(struct LxAstNode));
  node->node_type = node_type;
  node->lhs = lhs;
  node->rhs = rhs;
  node->ch0 = ch0;
  node->ch1 = ch1;
  return node;
}

#if LEMONEX_DBG>=1
static void lx_print_state(FILE* out, struct LxState *curr_state){
  fprintf(out, "  /* is_leaf:%d, code:%p, is_loop_head:%d, is_loop_enter:%d, is_loop_return:%d, star_state:%d, goto_state:%d, drop_state:%d, not_transition:%d, dot_transition:%d, init_state:%d */\n"
    ,curr_state->is_leaf
    ,curr_state->code
    ,curr_state->is_loop_head
    ,curr_state->is_loop_enter
    ,curr_state->is_loop_return
    ,(curr_state->star_state)?curr_state->star_state->state_id:0
    ,(curr_state->goto_state)?curr_state->goto_state->state_id:0
    ,(curr_state->drop_state)?curr_state->drop_state->state_id:0
    ,(curr_state->not_transition)?curr_state->not_transition->next_state->state_id:0
    ,(curr_state->dot_transition)?curr_state->dot_transition->next_state->state_id:0
    ,(curr_state->init_mode)?curr_state->init_mode->init_state->state_id:0
  );
}

static void lx_print_transition(FILE* out, struct LxState *curr_state, struct LxTransition *tx){
  fprintf(out, "  /*%d[%d(%c)-%d(%c)]->%d:tx_type:%d, is_cap:%d*/"
    , curr_state->state_id
    , tx->ch0, ((tx->ch0 >= 32) && (tx->ch0 <= 127))?tx->ch0:' '
    , tx->ch1, ((tx->ch1 >= 32) && (tx->ch1 <= 127))?tx->ch1:' '
    , tx->next_state->state_id
    , tx->tx_type
    , tx->is_capturing
  );
}
#define LX_PRINT_STATE(out, curr_state) lx_print_state(out, curr_state)
#define LX_PRINT_TRANSITION(out, curr_state, tx) lx_print_transition(out, curr_state, tx)
#else
#define LX_PRINT_STATE(out, curr_state)
#define LX_PRINT_TRANSITION(out, curr_state, tx)
#endif

static int LxTransition_cmp(int lch0, int lch1, int ltx_type, int rch0, int rch1, int rtx_type){
  /* all DOT transitions are always at the tail of the transition list */
  if((lch0 == 0) && (lch1 == LXCLASS_DOT) && ((rch0 == 0) && (rch1 == LXCLASS_DOT))){
    return 0;
  }

  if((lch0 == 0) && (lch1 == LXCLASS_DOT)){
    return 1;
  }

  if((rch0 == 0) && (rch1 == LXCLASS_DOT)){
    return -1;
  }

  if(ltx_type < rtx_type){
    return -1;
  }
  if(ltx_type > rtx_type){
    return 1;
  }
  assert(ltx_type == rtx_type);

  /* all loop transitions are always at the head of the transition list */
  if(((lch0 != 0) || (lch1 != 0)) && ((rch0 == 0) && (rch1 == 0))){
    return -1;
  }

  /* all loop transitions are always at the head of the transition list */
  if(((lch0 == 0) && (lch1 == 0)) && ((rch0 != 0) || (rch1 != 0))){
    return 1;
  }

  /* all loop transitions are always at the head of the transition list */
  if(((lch0 == 0) && (lch1 == 0)) && ((rch0 == 0) && (rch1 == 0))){
    return 1;
  }

  assert(((lch0 != 0) || (lch1 != 0)) && ((rch0 != 0) || (rch1 != 0)));

  /* char transition is less than special-range transition */
  if((lch0 != 0) && (rch0 == 0)){
    return -1;
  }

  /* special-range transition is greater than char transition */
  if((lch0 == 0) && (rch0 != 0)){
    return 1;
  }

  /* compare special-range transition to special-range transition */
  if((lch0 == 0) && (rch0 == 0)){
    if(lch1 < rch1){
      return -1;
    }
    if(lch1 > rch1){
      return 1;
    }
    assert(lch1 == rch1);
    return 0;
  }

  /* compare range or char transition to range or char transition */
  assert((lch0 != 0) && (rch0 != 0));
  if((lch1 == 0) && (rch1 != 0)){
    return -1;
  }
  if((lch1 != 0) && (rch1 == 0)){
    return 1;
  }

  /* compare range transition to range transition */
  if((lch1 != 0) && (rch1 != 0)){
    assert(lch0 <= lch1);
    assert(rch0 <= rch1);

    /* left range is disjoint and less than right range */
    if(lch1 < rch0){
      return -1;
    }

    /* left range is disjoint and greater than right range */
    if(lch0 > rch1){
      return 1;
    }

    assert(((lch0 <= rch0) && (lch1 >= rch1)) || ((lch0 >= rch0) && (lch1 <= rch1)));
    if((lch1 - lch0) < (rch1 - rch0)){
      return -1;
    }
    if((lch1 - lch0) > (rch1 - rch0)){
      return 1;
    }
    assert((lch1 - lch0) == (rch1 - rch0));
    // fall-thru
  }
  if(lch0 < rch0){
    return -1;
  }
  if(lch0 > rch0){
    return 1;
  }
  assert(lch0 == rch0);
  assert(lch1 == rch1);
  assert(ltx_type == rtx_type);
  return 0;
}

#if LEMONEX_DBG>=2
static int LxTransition_xcmp(int lch0, int lch1, int ltx_type, int rch0, int rch1, int rtx_type){
  int rv = LxTransition_cmp(lch0, lch1, ltx_type, rch0, rch1, rtx_type);
  printf("CMP:[%d-%d/%d]:[%d-%d/%d]:%d\n"
    ,lch0, lch1, ltx_type
    ,rch0, rch1, rtx_type
    ,rv
  );
  return rv;
}

#define LxTransition_cmp LxTransition_xcmp
#endif

static struct LxTransition *LxState_find_transition(struct LxState *curr_state, int ch0, int ch1, int tx_type){
  for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
    int cmp = LxTransition_cmp(tx->ch0, tx->ch1, tx->tx_type, ch0, ch1, tx_type);
    if(cmp == 0){
      return tx;
    }
  }
  return 0;
}

static void LxTransition_insert_at(struct LxState *curr_state, struct LxTransition *new_transition){
#if LEMONEX_DBG>=1
  printf("INSERT_TX:%d[%d(%c)-%d(%c)/%d]->%d\n"
    , curr_state->state_id
    , new_transition->ch0
    , new_transition->ch0
    , new_transition->ch1
    , new_transition->ch1
    , new_transition->tx_type
    , new_transition->next_state->state_id
  );
#endif
  assert(new_transition->next_state != curr_state);
  struct LxTransition* insert_tx_after = 0;
  for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
    int cmp = LxTransition_cmp(tx->ch0, tx->ch1, tx->tx_type, new_transition->ch0, new_transition->ch1, new_transition->tx_type);
    if(cmp == 0){
      printf("Internal error:inserting duplicate transition\n");
      exit(1);
    }
    if(cmp == -1){
      insert_tx_after = tx;
    }
  }

  if(insert_tx_after != 0){
    new_transition->next_transition = insert_tx_after->next_transition;
    insert_tx_after->next_transition = new_transition;
  }else{
    new_transition->next_transition = curr_state->head_transition;
    curr_state->head_transition = new_transition;
  }
}

struct LxTransition *LxTransition_insert(struct pstate *psp, struct LxAstNode *curr_node, int tx_type, struct LxState *curr_state, struct LxState *new_state){
  struct LxTransition *new_transition = LxTransition_create(psp, curr_node->ch0, curr_node->ch1, tx_type, psp->is_capturing, new_state);
  LxTransition_insert_at(curr_state, new_transition);
  return new_transition;
}

static int LxRange_contains(struct lemon *lemp, int rch0, int rch1, int cch0, int cch1, int is_cleaf){
  /* cch is a range, skip */
  if(cch1 != 0){
    return 0;
  }

  /* cch is a special range, skip */
  if(cch0 == 0){
    return 0;
  }

  /* rch is a char, skip */
  if(rch1 == 0){
    return 0;
  }

  /* rch is a loop transition, skip */
  if((rch0 == 0) && (rch1 == 0)){
    return 0;
  }

  /* if rch is a special range */
  if(rch0 == 0){
    int cls = 0;
    switch(rch1){
      case LXCLASS_LETTER:
        cls = 'l';
        break;
      case LXCLASS_DIGIT:
        cls = 'd';
        break;
      case LXCLASS_WORD:
        cls = 'w';
        break;
      case LXCLASS_SPACE:
        cls = 's';
        break;
      case LXCLASS_DOT:
        return (is_cleaf == 1)?0:1;
      default:
        printf("Internal error(1): unknown range(%d)\n", rch1);
        exit(1);
    }
    int i = 0;
    while(lemp->lxclasslist[i+1] != 0) {
      if((lemp->lxclasslist[i] == 0) && (lemp->lxclasslist[i+1] == cls)) {
        break;
      }
      i += 2;
    }
    if(lemp->lxclasslist[i+1] == 0) {
      printf("INTERNAL-ERROR:unhandled classtype:%d(%c)\n", cls, cls);
      exit(1);
    }

    i+=2;
    while(lemp->lxclasslist[i] != 0) {
      if((lemp->lxclasslist[i] <= cch0) && (cch0 <= lemp->lxclasslist[i+1])) {
        return 1;
      }
      i += 2;
    }
    return 0;
  }

  /* if rch is a regular range */
  assert((rch0 > 0) && (rch1 > 0));
  if((rch0 >= cch0) && (cch0 <= rch1)){
    return 1;
  }
  return 0;
}

static int LxState_find_transition_by_next(struct pstate *psp, struct LxTransition* except_transition){
  for(struct LxState* curr_state = psp->first_state; curr_state != 0; curr_state = curr_state->next_state){
    for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
      if((tx == except_transition) || (tx->next_state != except_transition->next_state)){
        continue;
      }
      int cmp = LxTransition_cmp(tx->ch0, tx->ch1, tx->tx_type, except_transition->ch0, except_transition->ch1, REGULAR_TX);
      if(cmp == 0){
        continue;
      }
#if LEMONEX_DBG>=2
      printf("has_tx:%d[%d-%d]->%d\n"
        , curr_state->state_id
        , tx->ch0, tx->ch1
        , tx->next_state->state_id
      );
#endif
      return 1;
    }
  }
  return 0;
}

static void LxState_set_drop(struct LxState *curr_state, struct LxState *drop_state){
  assert(curr_state->drop_state == 0);
  curr_state->drop_state = drop_state;
}

static void LxState_set_goto(struct LxState *curr_state, struct LxState *goto_state){
  assert(curr_state->goto_state == 0);
  curr_state->goto_state = goto_state;
}

static struct LxState *LxNode_process_charnode(struct pstate *psp, struct LxAstNode *curr_node, struct LxState *curr_state, int is_chk){
  assert(curr_node->lhs == 0);
  assert(curr_node->rhs == 0);

#if LEMONEX_DBG>=2
  printf("proc-char:%d[%d-%d]\n", curr_state->state_id, curr_node->ch0, curr_node->ch1);
#endif

  struct LxTransition* tx1 = LxState_find_transition(curr_state, curr_node->ch0, curr_node->ch1, REGULAR_TX);
  if(tx1 != 0){
    if(tx1->next_state->is_loop_return == 1){
      /// \todo should do this only if this is a child of a star node
      assert(tx1->is_capturing == psp->is_capturing);
      return tx1->next_state->goto_state;
    }
    return tx1->next_state;
  }
  if(is_chk == 1){
    return 0;
  }

  struct LxState *new_state = LxState_create(psp);
  LxTransition_insert(psp, curr_node, REGULAR_TX, curr_state, new_state);

  if(curr_state->star_state != 0){
    struct LxTransition* tx2 = LxState_find_transition(curr_state->star_state, curr_node->ch0, curr_node->ch1, REGULAR_TX);
    if(tx2 != 0){
      if(tx2->next_state->goto_state != 0){
        printf("Internal error(2): inconsistent state\n");
        exit(1);
      }
      LxState_set_goto(tx2->next_state, new_state);
    }else{
      LxTransition_insert(psp, curr_node, REGULAR_TX, curr_state->star_state, new_state);
    }
  }

  return new_state;
}

static struct LxState *LxNode_process_classnode(struct pstate *psp, struct LxAstNode *curr_node, struct LxState *curr_state, int tx_type, int is_chk){
  struct LxState *new_state = 0;
  assert(curr_node->lhs == 0);
  assert(curr_node->rhs != 0);

  /* search for existing dst state for each item in this class*/
  for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
    for(struct LxAstNode* node = curr_node->rhs; node != 0; node = node->rhs){
      int cmp = LxTransition_cmp(tx->ch0, tx->ch1, tx->tx_type, node->ch0, node->ch1, tx_type);
      if(cmp == 0){
        if(new_state == 0){
          new_state = tx->next_state;
        }else if(new_state != tx->next_state){
          printf("Overlapping class in regex\n");
          exit(1);
        }
        if(tx->tx_type != tx_type){
          printf("Negative class mismatch\n");
          exit(1);
        }
      }
    }
  }
  if(new_state != 0){
    return new_state;
  }

  if(is_chk == 1){
    return 0;
  }

  new_state = LxState_create(psp);
  for(struct LxAstNode* node = curr_node->rhs; node != 0; node = node->rhs){
    struct LxTransition *dtx = LxTransition_insert(psp, node, tx_type, curr_state, new_state);
    dtx->tx_type = tx_type;
  }

  return new_state;
}

static struct LxState *LxNode_process(struct pstate *psp, int lvl, char pos, struct LxAstNode *curr_node, struct LxState *curr_state, int is_chk);

static struct LxState *LxNode_process_loopnode(struct pstate *psp, int lvl, struct LxAstNode *curr_node, struct LxState *curr_state, int is_chk, int is_star){
  struct LxState *lhs = 0;
  struct LxState *new_state = 0;
  assert(curr_node->lhs != 0);
  assert(curr_node->rhs == 0);

  /* process all 0-0 transitions out of this state */
  for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
    if((tx->ch0 != 0) || (tx->ch1 != 0)){
      continue;
    }
    assert((tx->ch0 == 0) && (tx->ch1 == 0));
    lhs = LxNode_process(psp, lvl+1, 'L', curr_node->lhs, tx->next_state, 1);
    if(lhs != 0){
      assert((lhs->is_loop_head == 1) || (lhs->is_loop_return == 1));
      if(lhs->is_loop_return == 1){
        lhs = lhs->goto_state;
      }
      assert(lhs->is_loop_head == 1);
      return lhs;
    }
  }
  if(is_chk == 1){
    return 0;
  }

  new_state = LxState_create(psp);
  new_state->is_loop_head = 1;
  lhs = LxNode_process(psp, lvl+1, 'L', curr_node->lhs, new_state, is_chk);
  assert(lhs != 0);
  for(struct LxTransition* tx = new_state->head_transition; tx != 0; tx = tx->next_transition){
    tx->is_loop_set = 0;
  }
  for(struct LxTransition* tx = new_state->head_transition; tx != 0; tx = tx->next_transition){
    if(tx->is_loop_set == 1){
      continue;
    }
    tx->is_loop_set = 1;
    struct LxTransition* tx1 = LxState_find_transition(curr_state, tx->ch0, tx->ch1, tx->tx_type);
    if(tx1 != 0){
      struct LxState *dup_state = tx1->next_state;
#if LEMONEX_DBG>=2
      printf("%d[%d-%d]-> dup_state:%d, goto:%d, gotoing:%d\n"
        , curr_state->state_id
        , tx->ch0, tx->ch1
        , dup_state->state_id
        , (dup_state->goto_state != 0)?dup_state->goto_state->state_id:0
        , tx->next_state->state_id
      );
#endif
      assert(tx1->is_capturing == psp->is_capturing);
      dup_state->is_loop_enter = 1;
      if(dup_state->goto_state == 0){
        LxState_set_goto(dup_state, tx->next_state);
      }
    }else{
      struct LxState *dup_state = LxState_create(psp);
      dup_state->is_loop_enter = 1;
      LxState_set_goto(dup_state, tx->next_state);
      struct LxTransition *dup_transition = LxTransition_create(psp, tx->ch0, tx->ch1, tx->tx_type, tx->is_capturing, dup_state);
      LxTransition_insert_at(curr_state, dup_transition);
      for(struct LxTransition* tx2 = new_state->head_transition; tx2 != 0; tx2 = tx2->next_transition){
        if(tx2->is_loop_set == 1){
          continue;
        }
        if(tx->next_state == tx2->next_state){
          dup_transition = LxTransition_create(psp, tx2->ch0, tx2->ch1, tx2->tx_type, tx2->is_capturing, dup_state);
          LxTransition_insert_at(curr_state, dup_transition);
          tx2->is_loop_set = 1;
        }
      }
    }
  }

  LxState_set_goto(lhs, new_state);
  lhs->is_loop_return = 1;
  struct LxTransition *loop_transition = LxTransition_create(psp, 0, 0, LOOP_TX, 0, new_state);
  LxTransition_insert_at(curr_state, loop_transition);
  if(is_star == 1){
    new_state->star_state = curr_state;
  }
  return new_state;
}

static struct LxState *LxNode_process(struct pstate *psp, int lvl, char pos, struct LxAstNode *curr_node, struct LxState *curr_state, int is_chk){
  assert(curr_state);
  struct LxState *lhs = 0;
  struct LxState *rhs = 0;
  struct LxState *new_state = 0;
  switch(curr_node->node_type){
    case CHAR_NODE:
      return LxNode_process_charnode(psp, curr_node, curr_state, is_chk);
    case CLASS_NODE:
      return LxNode_process_classnode(psp, curr_node, curr_state, REGULAR_TX, is_chk);
    case NCLASS_NODE:
      return LxNode_process_classnode(psp, curr_node, curr_state, NOT_TX, is_chk);
    case STAR_NODE:
      return LxNode_process_loopnode(psp, lvl, curr_node, curr_state, is_chk, 1);
    case PLUS_NODE:
      return LxNode_process_loopnode(psp, lvl, curr_node, curr_state, is_chk, 0);
    case OPT_NODE:
      assert(curr_node->lhs != 0);
      assert(curr_node->rhs == 0);
      lhs = LxNode_process(psp, lvl+1, 'L', curr_node->lhs, curr_state, is_chk);
      assert(lhs != 0);
      LxState_set_goto(curr_state, lhs);
      return lhs;
    case OR_NODE:
      assert(curr_node->lhs != 0);
      assert(curr_node->rhs != 0);
      lhs = LxNode_process(psp, lvl+1, 'L', curr_node->lhs, curr_state, is_chk);
      rhs = LxNode_process(psp, lvl+1, 'R', curr_node->rhs, curr_state, is_chk);
      assert(lhs != 0);
      assert(rhs != 0);
      LxState_set_goto(rhs, lhs);
      return lhs;
    case AND_NODE:
      assert(curr_node->lhs != 0);
      assert(curr_node->rhs != 0);
      lhs = LxNode_process(psp, lvl+1, 'L', curr_node->lhs, curr_state, is_chk);
      rhs = LxNode_process(psp, lvl+1, 'R', curr_node->rhs, lhs, is_chk);
      assert(lhs != 0);
      assert(rhs != 0);
      return rhs;
  }
  assert(0);
  return 0;
}

struct LxAstNode *lx_expr(struct LxScanner *s);

struct LxAstNode *lx_primary_expr(struct LxScanner *s, int chk_range){
  int ch0 = lx_lookahead(s);
//  printf("primary_expr:%c\n", ch0);
  if(ch0 == 0){
    return 0;
  }
  if(ch0 == ')'){
    return 0;
  }
  lx_advance(s);
  if(ch0 == '.'){
    return LxNode_create(CHAR_NODE, 0, 0, 0, LXCLASS_DOT);
  }
  if(ch0 == '\\'){
    ch0 = lx_lookahead(s);
    if(ch0 == 0){
      return 0;
    }
    lx_advance(s);
    switch(ch0){
      case 'l':
        return LxNode_create(CHAR_NODE, 0, 0, 0, LXCLASS_LETTER);
      case 'd':
        return LxNode_create(CHAR_NODE, 0, 0, 0, LXCLASS_DIGIT);
      case 'w':
        return LxNode_create(CHAR_NODE, 0, 0, 0, LXCLASS_WORD);
      case 's':
        return LxNode_create(CHAR_NODE, 0, 0, 0, LXCLASS_SPACE);
      case 't':
        return LxNode_create(CHAR_NODE, 0, 0, '\t', 0);
      case 'r':
        return LxNode_create(CHAR_NODE, 0, 0, '\r', 0);
      case 'n':
        return LxNode_create(CHAR_NODE, 0, 0, '\n', 0);
    }
  }
  if(chk_range && (lx_lookahead(s) == '-')){
    lx_advance(s);
    int ch1 = lx_lookahead(s);
    if(ch1 == 0){
      return 0;
    }
    lx_advance(s);
    return LxNode_create(CHAR_NODE, 0, 0, ch0, ch1);
  }
  return LxNode_create(CHAR_NODE, 0, 0, ch0, 0);
}

struct LxAstNode *lx_range_expr(struct LxScanner *s){
  return lx_primary_expr(s, 1);
}

struct LxAstNode *lx_inner_expr(struct LxScanner *s){
  struct LxAstNode *lhs = 0;
  struct LxAstNode *rhs = 0;
  int tx_type = REGULAR_TX;
  switch(lx_lookahead(s)){
    case '(':
      lx_advance(s);
      lhs = lx_expr(s);
      if(lx_lookahead(s) != ')'){
        printf("syntax error in regex while looking for ')'\n");
        exit(1);
      }
      lx_advance(s);
      return lhs;
    case '[':
      lx_advance(s);
      if(lx_lookahead(s) == '^'){
        lx_advance(s);
        tx_type = NOT_TX;
      }
      lhs = lx_range_expr(s);
      rhs = lhs;
      while(lx_lookahead(s) != ']'){
        assert(rhs != 0);
        rhs->rhs = lx_range_expr(s);
        rhs = rhs->rhs;
      }
      if(lx_lookahead(s) != ']'){
        printf("syntax error in regex while looking for ']'\n");
        exit(1);
      }
      lx_advance(s);
      if(tx_type == NOT_TX){
        return LxNode_create(NCLASS_NODE, 0, lhs, 0, 0);
      }
      return LxNode_create(CLASS_NODE, 0, lhs, 0, 0);
    case '?':
      lx_advance(s);
      return LxNode_create(OPT_NODE, lhs, 0, 0, 0);
  }
  return lx_primary_expr(s, 0);
}

struct LxAstNode *lx_unary_expr(struct LxScanner *s){
  struct LxAstNode *lhs = lx_inner_expr(s);
  if(lhs == 0){
    return 0;
  }
  int node_type = 0;
  switch(lx_lookahead(s)){
    case '*':
      node_type = STAR_NODE;
      break;
    case '+':
      node_type = PLUS_NODE;
      break;
    case '?':
      node_type = OPT_NODE;
      break;
    default:
      return lhs;
  }
  lx_advance(s);
  return LxNode_create(node_type, lhs, 0, 0, 0);
}

struct LxAstNode *lx_or_expr(struct LxScanner *s){
  struct LxAstNode *lhs = lx_unary_expr(s);
  if(lhs == 0){
    return 0;
  }

  while(lx_lookahead(s) == '|') {
    lx_advance(s);
    struct LxAstNode *rhs = lx_expr(s);
    lhs = LxNode_create(OR_NODE, lhs, rhs, 0, 0);
  }

  return lhs;
}

struct LxAstNode *lx_and_expr(struct LxScanner *s){
  struct LxAstNode *lhs = lx_or_expr(s);
  if(lhs == 0){
    return 0;
  }

  struct LxAstNode *rhs = 0;
  while((rhs = lx_expr(s)) != 0){
    lhs = LxNode_create(AND_NODE, lhs, rhs, 0, 0);
  }

  return lhs;
}

struct LxAstNode *lx_expr(struct LxScanner *s){
  return lx_and_expr(s);
}

static struct LxState *LxState_normalize(struct LxState *next_state){
  if(next_state->is_loop_enter == 1){
    assert(next_state->goto_state != 0);
    next_state = next_state->goto_state;
  }
  if(next_state->is_loop_return == 1){
    assert(next_state->goto_state != 0);
    next_state = next_state->goto_state;
  }
  return next_state;
}

static void LxState_setdrop_at(struct pstate *psp, struct LxState *next_state, struct LxState *drop_state){
  next_state = LxState_normalize(next_state);
  if(next_state->is_processed == 1){
    return;
  }

  drop_state = LxState_normalize(drop_state);
#if LEMONEX_DBG>=1
  printf("SETDROP_AT:%d->%d\n", next_state->state_id, drop_state->state_id);
#endif

  if(next_state->drop_state == 0){
    LxState_set_drop(next_state, drop_state);
  }else{
    assert((next_state->drop_state == drop_state) || (next_state->drop_state == drop_state->star_state));
  }

  /* possibly a join node after an OR */
  if(next_state->goto_state == 0){
    LxState_set_goto(next_state, next_state->drop_state);
  }
}

static void LxState_postprocess_setdrop(struct pstate *psp, int lvl, struct LxState *curr_state){
  if(curr_state->is_processed == 1){
    return;
  }
  curr_state->is_processed = 1;

  struct LxState *drop_state = curr_state->drop_state;
  if((drop_state != 0) && (drop_state->is_loop_return == 1)){
    assert(drop_state->goto_state != 0);
    drop_state = drop_state->goto_state;
  }
  for(struct LxTransition* ctx = curr_state->head_transition; ctx != 0; ctx = ctx->next_transition){
    int found = 0;
    for(struct LxTransition* rtx = curr_state->head_transition; rtx != 0; rtx = rtx->next_transition){
      if(LxRange_contains(psp->gp, rtx->ch0, rtx->ch1, ctx->ch0, ctx->ch1, ctx->next_state->is_leaf) == 1){
        LxState_setdrop_at(psp, ctx->next_state, rtx->next_state);
        found = 1;
      }
    }
    if((found == 0) && (drop_state != 0)){
      for(struct LxTransition* rtx = drop_state->head_transition; rtx != 0; rtx = rtx->next_transition){
        if(LxRange_contains(psp->gp, rtx->ch0, rtx->ch1, ctx->ch0, ctx->ch1, ctx->next_state->is_leaf) == 1){
          LxState_setdrop_at(psp, ctx->next_state, rtx->next_state);
          found = 1;
        }
      }
    }
  }

  /* recurse into each next state */
  for(struct LxTransition* ctx = curr_state->head_transition; ctx != 0; ctx = ctx->next_transition){
    LxState_postprocess_setdrop(psp, lvl+1, ctx->next_state);
  }
}

static void LxState_postprocess_duptransition(struct pstate *psp, struct LxState *curr_state, struct LxState *from_state, struct LxState *entry_state){
  for(struct LxTransition* tx = from_state->head_transition; tx != 0; tx = tx->next_transition){
    if(curr_state->state_id == tx->next_state->state_id){
      continue;
    }
    if(tx->next_state == entry_state){
      continue;
    }
    if((tx->ch0 == 0) && (tx->ch1 == 0)){
      continue;
    }
    if((tx->ch0 == 0) && (tx->ch1 == LXCLASS_DOT)){
      continue;
    }
    struct LxTransition* tx1 = LxState_find_transition(curr_state, tx->ch0, tx->ch1, INIT_TX);
    if(tx1 != 0){
      continue;
    }
    struct LxTransition *dup_transition = LxTransition_create(psp, tx->ch0, tx->ch1, INIT_TX, tx->is_capturing, tx->next_state);
    LxTransition_insert_at(curr_state, dup_transition);
  }
}

static void LxState_postprocess_setinit(struct pstate *psp, int lvl, struct LxState *curr_state, struct LxState *entry_state){
  if(curr_state->is_processed == 1){
    return;
  }
  curr_state->is_processed = 1;

  for(struct LxTransition* ctx = curr_state->head_transition; ctx != 0; ctx = ctx->next_transition){
    /* set not_transition for each next state */
    if(ctx->tx_type == NOT_TX){
      if((curr_state->not_transition != 0) && (curr_state->not_transition->next_state != ctx->next_state)){
        printf("ERROR: Multiple overlapping not-transitions at the same state\n");
        exit(1);
      }
      if(curr_state->not_transition == 0){
        curr_state->not_transition = ctx;
      }
    }

    /* and dot_transition as well */
    if((ctx->ch0 == 0) && (ctx->ch1 == LXCLASS_DOT)){
      if(curr_state->dot_transition != 0){
        printf("ERROR: Multiple dot-transitions at the same state\n");
        exit(1);
      }
      curr_state->dot_transition = ctx;
    }
  }

  if(curr_state->is_leaf == 1){
    if(curr_state->drop_state != 0){
      LxState_postprocess_duptransition(psp, curr_state, curr_state->drop_state, entry_state);
    }

    if(curr_state->dot_transition != 0){
      assert(curr_state->init_mode);
      assert(curr_state->init_mode->init_state);
      LxState_postprocess_duptransition(psp, curr_state, curr_state->init_mode->init_state, entry_state);
    }
  }else{
    for(struct LxTransition* ctx = curr_state->head_transition; ctx != 0; ctx = ctx->next_transition){
      if((ctx->ch1 != 0) || (ctx->ch0 != 0)){
        continue;
      }
      if(ctx->next_state->is_leaf == 0){
        if(ctx->next_state->goto_state == 0){
          LxState_set_goto(ctx->next_state, curr_state->goto_state);
        }
      }
    }
  }

  /* recurse into each next state */
  for(struct LxTransition* ctx = curr_state->head_transition; ctx != 0; ctx = ctx->next_transition){
    struct LxState *es = entry_state;
    if(es == 0){
      es = ctx->next_state;
    }
    LxState_postprocess_setinit(psp, lvl+1, ctx->next_state, es);
  }
}

static void LxState_postprocess(struct pstate *psp){
  for(struct LxMode *curr_mode = psp->first_mode; curr_mode != 0; curr_mode = curr_mode->next_mode){
    LxState_postprocess_setdrop(psp, 0, curr_mode->init_state);
  }
  for(struct LxState* curr_state = psp->first_state; curr_state != 0; curr_state = curr_state->next_state){
    curr_state->is_processed = 0;
  }
  for(struct LxMode *curr_mode = psp->first_mode; curr_mode != 0; curr_mode = curr_mode->next_mode){
    LxState_postprocess_setinit(psp, 0, curr_mode->init_state, 0);
  }
}

int Lexer_process_regex(struct pstate *psp, const char *regex){
#if LEMONEX_DBG>=1
  printf("reading regex '%s' as symbol '%s' in mode '%s'\n", regex, (psp->lastlxsym)?psp->lastlxsym->name:"", psp->last_mode->name);
#endif

  struct LxScanner s;
  s.p = regex;
  s.ch = 0;
  s.offset = 0;
  struct LxAstNode *root_node = lx_expr(&s);
  if(root_node->node_type != STAR_NODE){
    psp->nstarcount++;
  }
  psp->curr_state = LxNode_process(psp, 0, '*', root_node, psp->curr_state, 0);
  return 0;
}
#endif /* LEMONEX */

/* Parse a single token */
static void parseonetoken(struct pstate *psp)
{
  const char *x;
  x = Strsafe(psp->tokenstart);     /* Save the token permanently */
#if 0
  printf("%s:%d: Token=[%s] state=%d\n",psp->filename,psp->tokenlineno,
    x,psp->state);
#endif
  switch( psp->state ){
    case INITIALIZE:
      psp->prevrule = 0;
      psp->preccounter = 0;
      psp->firstrule = psp->lastrule = 0;
      psp->gp->nrule = 0;
#ifdef LEMONEX
      psp->is_defininglx = 0;
      psp->next_lxstate_id = 0;
      psp->last_state = 0;
      psp->first_state = 0;
      psp->curr_state = 0;
      psp->last_mode = 0;
      psp->first_mode = 0;
      psp->lastlxsym = 0;
      psp->nstarcount = 0;
      psp->is_capturing = 1;
#endif
      /* Fall thru to next case */
    case WAITING_FOR_DECL_OR_RULE:
      if( x[0]=='%' ){
        psp->state = WAITING_FOR_DECL_KEYWORD;
      }else if( islower(x[0]) ){
        psp->lhs = Symbol_new(x);
        psp->nrhs = 0;
        psp->lhsalias = 0;
        psp->state = WAITING_FOR_ARROW;
#ifdef LEMONEX
        psp->is_defininglx = 0;
      }else if( isupper(x[0]) ){
        psp->lastlxsym = Symbol_find(x); /* this might be 0 if symbol not found */
        psp->nstarcount = 0;
        psp->is_capturing = (psp->lastlxsym==0)?0:1;
        psp->state = WAITING_FOR_ARROW_LEX;
        psp->is_defininglx = 1;
#endif
      }else if( x[0]=='{' ){
#ifdef LEMONEX
        if((psp->is_defininglx != 0) && (psp->curr_state == 0)) {
          ErrorMsg(psp->filename,psp->tokenlineno,
"There is no prior lexer rule upon which to attach the code \
fragment which begins on this line.");
          psp->errorcnt++;
        } else if((psp->is_defininglx != 0) && (psp->curr_state != 0)) {
          assert(psp->curr_state->is_leaf == 1);
          psp->curr_state->code = &x[1];
          if(psp->curr_state->star_state != 0){
            assert(psp->curr_state->star_state->is_leaf == 1);
            psp->curr_state->star_state->code = &x[1];
          }
        } else
#endif
        if( psp->prevrule==0 ){
          ErrorMsg(psp->filename,psp->tokenlineno,
"There is no prior rule upon which to attach the code \
fragment which begins on this line.");
          psp->errorcnt++;
        }else if( psp->prevrule->code!=0 ){
          ErrorMsg(psp->filename,psp->tokenlineno,
"Code fragment beginning on this line is not the first \
to follow the previous rule.");
          psp->errorcnt++;
        }else{
          psp->prevrule->line = psp->tokenlineno;
          psp->prevrule->code = &x[1];
        }
      }else if( x[0]=='[' ){
#ifdef LEMONEX
        if(psp->is_defininglx != 0){
          psp->state = IN_NEXTMODE;
        } else
#endif
        psp->state = PRECEDENCE_MARK_1;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Token \"%s\" should be either \"%%\" or a nonterminal name.",
          x);
        psp->errorcnt++;
      }
      break;
    case PRECEDENCE_MARK_1:
      if( !isupper(x[0]) ){
        ErrorMsg(psp->filename,psp->tokenlineno,
          "The precedence symbol must be a terminal.");
        psp->errorcnt++;
      }else if( psp->prevrule==0 ){
        ErrorMsg(psp->filename,psp->tokenlineno,
          "There is no prior rule to assign precedence \"[%s]\".",x);
        psp->errorcnt++;
      }else if( psp->prevrule->precsym!=0 ){
        ErrorMsg(psp->filename,psp->tokenlineno,
"Precedence mark on this line is not the first \
to follow the previous rule.");
        psp->errorcnt++;
      }else{
        psp->prevrule->precsym = Symbol_new(x);
      }
      psp->state = PRECEDENCE_MARK_2;
      break;
    case PRECEDENCE_MARK_2:
      if( x[0]!=']' ){
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Missing \"]\" on precedence mark.");
        psp->errorcnt++;
      }
      psp->state = WAITING_FOR_DECL_OR_RULE;
      break;
    case WAITING_FOR_ARROW:
      if( x[0]==':' && x[1]==':' && x[2]=='=' ){
        psp->state = IN_RHS;
      }else if( x[0]=='(' ){
        psp->state = LHS_ALIAS_1;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \":\" following the LHS symbol \"%s\".",
          psp->lhs->name);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case LHS_ALIAS_1:
      if( isalpha(x[0]) ){
        psp->lhsalias = x;
        psp->state = LHS_ALIAS_2;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "\"%s\" is not a valid alias for the LHS \"%s\"\n",
          x,psp->lhs->name);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case LHS_ALIAS_2:
      if( x[0]==')' ){
        psp->state = LHS_ALIAS_3;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Missing \")\" following LHS alias name \"%s\".",psp->lhsalias);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case LHS_ALIAS_3:
      if( x[0]==':' && x[1]==':' && x[2]=='=' ){
        psp->state = IN_RHS;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Missing \"->\" following: \"%s(%s)\".",
           psp->lhs->name,psp->lhsalias);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case IN_RHS:
      if( x[0]=='.' ){
        struct rule *rp;
        rp = (struct rule *)calloc( sizeof(struct rule) +
             sizeof(struct symbol*)*psp->nrhs + sizeof(char*)*psp->nrhs, 1);
        if( rp==0 ){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Can't allocate enough memory for this rule.");
          psp->errorcnt++;
          psp->prevrule = 0;
        }else{
          int i;
          rp->ruleline = psp->tokenlineno;
          rp->rhs = (struct symbol**)&rp[1];
          rp->rhsalias = (const char**)&(rp->rhs[psp->nrhs]);
          for(i=0; i<psp->nrhs; i++){
            rp->rhs[i] = psp->rhs[i];
            rp->rhsalias[i] = psp->alias[i];
          }
          rp->lhs = psp->lhs;
          rp->lhsalias = psp->lhsalias;
          rp->nrhs = psp->nrhs;
          rp->code = 0;
          rp->precsym = 0;
          rp->index = psp->gp->nrule++;
          rp->nextlhs = rp->lhs->rule;
          rp->lhs->rule = rp;
          rp->next = 0;
          if( psp->firstrule==0 ){
            psp->firstrule = psp->lastrule = rp;
          }else{
            psp->lastrule->next = rp;
            psp->lastrule = rp;
          }
          psp->prevrule = rp;
        }
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else if( isalpha(x[0]) ){
        if( psp->nrhs>=MAXRHS ){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Too many symbols on RHS of rule beginning at \"%s\".",
            x);
          psp->errorcnt++;
          psp->state = RESYNC_AFTER_RULE_ERROR;
        }else{
          psp->rhs[psp->nrhs] = Symbol_new(x);
          psp->alias[psp->nrhs] = 0;
          psp->nrhs++;
        }
      }else if( (x[0]=='|' || x[0]=='/') && psp->nrhs>0 ){
        struct symbol *msp = psp->rhs[psp->nrhs-1];
        if( msp->type!=MULTITERMINAL ){
          struct symbol *origsp = msp;
          msp = (struct symbol *) calloc(1,sizeof(*msp));
          memset(msp, 0, sizeof(*msp));
          msp->type = MULTITERMINAL;
          msp->nsubsym = 1;
          msp->subsym = (struct symbol **) calloc(1,sizeof(struct symbol*));
          msp->subsym[0] = origsp;
          msp->name = origsp->name;
          psp->rhs[psp->nrhs-1] = msp;
        }
        msp->nsubsym++;
        msp->subsym = (struct symbol **) realloc(msp->subsym,
          sizeof(struct symbol*)*msp->nsubsym);
        msp->subsym[msp->nsubsym-1] = Symbol_new(&x[1]);
        if( islower(x[1]) || islower(msp->subsym[0]->name[0]) ){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Cannot form a compound containing a non-terminal");
          psp->errorcnt++;
        }
      }else if( x[0]=='(' && psp->nrhs>0 ){
        psp->state = RHS_ALIAS_1;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Illegal character on RHS of rule: \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case RHS_ALIAS_1:
      if( isalpha(x[0]) ){
        psp->alias[psp->nrhs-1] = x;
        psp->state = RHS_ALIAS_2;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "\"%s\" is not a valid alias for the RHS symbol \"%s\"\n",
          x,psp->rhs[psp->nrhs-1]->name);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case RHS_ALIAS_2:
      if( x[0]==')' ){
        psp->state = IN_RHS;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Missing \")\" following LHS alias name \"%s\".",psp->lhsalias);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case WAITING_FOR_DECL_KEYWORD:
      if( isalpha(x[0]) ){
        psp->declkeyword = x;
        psp->declargslot = 0;
        psp->decllinenoslot = 0;
        psp->insertLineMacro = 1;
        psp->state = WAITING_FOR_DECL_ARG;
        if( strcmp(x,"name")==0 ){
          psp->declargslot = &(psp->gp->name);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"include")==0 ){
          psp->declargslot = &(psp->gp->include);
        }else if( strcmp(x,"code")==0 ){
          psp->declargslot = &(psp->gp->extracode);
        }else if( strcmp(x,"token_destructor")==0 ){
          psp->declargslot = &psp->gp->tokendest;
        }else if( strcmp(x,"default_destructor")==0 ){
          psp->declargslot = &psp->gp->vardest;
        }else if( strcmp(x,"token_prefix")==0 ){
          psp->declargslot = &psp->gp->tokenprefix;
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"syntax_error")==0 ){
          psp->declargslot = &(psp->gp->error);
        }else if( strcmp(x,"parse_accept")==0 ){
          psp->declargslot = &(psp->gp->accept);
        }else if( strcmp(x,"parse_failure")==0 ){
          psp->declargslot = &(psp->gp->failure);
        }else if( strcmp(x,"stack_overflow")==0 ){
          psp->declargslot = &(psp->gp->overflow);
        }else if( strcmp(x,"extra_argument")==0 ){
          psp->declargslot = &(psp->gp->arg);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"token_type")==0 ){
          psp->declargslot = &(psp->gp->tokentype);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"default_type")==0 ){
          psp->declargslot = &(psp->gp->vartype);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"stack_size")==0 ){
          psp->declargslot = &(psp->gp->stacksize);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"start_symbol")==0 ){
          psp->declargslot = &(psp->gp->start);
          psp->insertLineMacro = 0;
        }else if( strcmp(x,"left")==0 ){
          psp->preccounter++;
          psp->declassoc = LEFT;
          psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;
        }else if( strcmp(x,"right")==0 ){
          psp->preccounter++;
          psp->declassoc = RIGHT;
          psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;
        }else if( strcmp(x,"nonassoc")==0 ){
          psp->preccounter++;
          psp->declassoc = NONE;
          psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;
        }else if( strcmp(x,"destructor")==0 ){
          psp->state = WAITING_FOR_DESTRUCTOR_SYMBOL;
        }else if( strcmp(x,"type")==0 ){
          psp->state = WAITING_FOR_DATATYPE_SYMBOL;
        }else if( strcmp(x,"fallback")==0 ){
          psp->fallback = 0;
          psp->state = WAITING_FOR_FALLBACK_ID;
        }else if( strcmp(x,"wildcard")==0 ){
          psp->state = WAITING_FOR_WILDCARD_ID;
        }else if( strcmp(x,"token_class")==0 ){
          psp->state = WAITING_FOR_CLASS_ID;
#ifdef LEMONEX
        }else if( strcmp(x,"lexer_integration")==0 ){
          psp->state = WAITING_FOR_INTEGRATIONMODE_1;
        }else if( strcmp(x,"lexer_nestingdepth")==0 ){
          psp->state = WAITING_FOR_NESTINGDEPTH_1;
        }else if( strcmp(x,"lexer_encoding")==0 ){
          psp->state = WAITING_FOR_ENCODING_ID_1;
        }else if( strcmp(x,"lexer_code")==0 ){
          psp->declargslot = &(psp->gp->lexercode);
        }else if( strcmp(x,"lexer_mode")==0 ){
          psp->state = WAITING_FOR_MODE_ID_1;
        }else if( strcmp(x,"lexer_debuglevel")==0 ){
          psp->state = WAITING_FOR_DEBUG_LEVEL_1;
        }else if( strcmp(x,"token_constructor")==0 ){
          psp->declargslot = &psp->gp->tokenctor;
#endif
        }else{
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Unknown declaration keyword: \"%%%s\".",x);
          psp->errorcnt++;
          psp->state = RESYNC_AFTER_DECL_ERROR;
        }
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Illegal declaration keyword: \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_DESTRUCTOR_SYMBOL:
      if( !isalpha(x[0]) ){
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Symbol name missing after %%destructor keyword");
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }else{
        struct symbol *sp = Symbol_new(x);
        psp->declargslot = &sp->destructor;
        psp->decllinenoslot = &sp->destLineno;
        psp->insertLineMacro = 1;
        psp->state = WAITING_FOR_DECL_ARG;
      }
      break;
    case WAITING_FOR_DATATYPE_SYMBOL:
      if( !isalpha(x[0]) ){
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Symbol name missing after %%type keyword");
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }else{
        struct symbol *sp = Symbol_find(x);
        if((sp) && (sp->datatype)){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Symbol %%type \"%s\" already defined", x);
          psp->errorcnt++;
          psp->state = RESYNC_AFTER_DECL_ERROR;
        }else{
          if (!sp){
            sp = Symbol_new(x);
          }
          psp->declargslot = &sp->datatype;
          psp->insertLineMacro = 0;
          psp->state = WAITING_FOR_DECL_ARG;
        }
      }
      break;
    case WAITING_FOR_PRECEDENCE_SYMBOL:
      if( x[0]=='.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else if( isupper(x[0]) ){
        struct symbol *sp;
        sp = Symbol_new(x);
        if( sp->prec>=0 ){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Symbol \"%s\" has already be given a precedence.",x);
          psp->errorcnt++;
        }else{
          sp->prec = psp->preccounter;
          sp->assoc = psp->declassoc;
        }
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Can't assign a precedence to \"%s\".",x);
        psp->errorcnt++;
      }
      break;
    case WAITING_FOR_DECL_ARG:
      if( x[0]=='{' || x[0]=='\"' || isalnum(x[0]) ){
        const char *zOld, *zNew;
        char *zBuf, *z;
        int nOld, n, nLine = 0, nNew, nBack;
        int addLineMacro;
        char zLine[50];
        zNew = x;
        if( zNew[0]=='"' || zNew[0]=='{' ) zNew++;
        nNew = lemonStrlen(zNew);
        if( *psp->declargslot ){
          zOld = *psp->declargslot;
        }else{
          zOld = "";
        }
        nOld = lemonStrlen(zOld);
        n = nOld + nNew + 20;
        addLineMacro = !psp->gp->nolinenosflag && psp->insertLineMacro &&
                        (psp->decllinenoslot==0 || psp->decllinenoslot[0]!=0);
        if( addLineMacro ){
          for(z=psp->filename, nBack=0; *z; z++){
            if( *z=='\\' ) nBack++;
          }
          lemon_sprintf(zLine, "#line %d ", psp->tokenlineno);
          nLine = lemonStrlen(zLine);
          n += nLine + lemonStrlen(psp->filename) + nBack;
        }
        *psp->declargslot = (char *) realloc(*psp->declargslot, n);
        zBuf = *psp->declargslot + nOld;
        if( addLineMacro ){
          if( nOld && zBuf[-1]!='\n' ){
            *(zBuf++) = '\n';
          }
          memcpy(zBuf, zLine, nLine);
          zBuf += nLine;
          *(zBuf++) = '"';
          for(z=psp->filename; *z; z++){
            if( *z=='\\' ){
              *(zBuf++) = '\\';
            }
            *(zBuf++) = *z;
          }
          *(zBuf++) = '"';
          *(zBuf++) = '\n';
        }
        if( psp->decllinenoslot && psp->decllinenoslot[0]==0 ){
          psp->decllinenoslot[0] = psp->tokenlineno;
        }
        memcpy(zBuf, zNew, nNew);
        zBuf += nNew;
        *zBuf = 0;
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Illegal argument to %%%s: %s",psp->declkeyword,x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_FALLBACK_ID:
      if( x[0]=='.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else if( !isupper(x[0]) ){
        ErrorMsg(psp->filename, psp->tokenlineno,
          "%%fallback argument \"%s\" should be a token", x);
        psp->errorcnt++;
      }else{
        struct symbol *sp = Symbol_new(x);
        if( psp->fallback==0 ){
          psp->fallback = sp;
        }else if( sp->fallback ){
          ErrorMsg(psp->filename, psp->tokenlineno,
            "More than one fallback assigned to token %s", x);
          psp->errorcnt++;
        }else{
          sp->fallback = psp->fallback;
          psp->gp->has_fallback = 1;
        }
      }
      break;
    case WAITING_FOR_WILDCARD_ID:
      if( x[0]=='.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else if( !isupper(x[0]) ){
        ErrorMsg(psp->filename, psp->tokenlineno,
          "%%wildcard argument \"%s\" should be a token", x);
        psp->errorcnt++;
      }else{
        struct symbol *sp = Symbol_new(x);
        if( psp->gp->wildcard==0 ){
          psp->gp->wildcard = sp;
        }else{
          ErrorMsg(psp->filename, psp->tokenlineno,
            "Extra wildcard to token: %s", x);
          psp->errorcnt++;
        }
      }
      break;
    case WAITING_FOR_CLASS_ID:
      if( !islower(x[0]) ){
        ErrorMsg(psp->filename, psp->tokenlineno,
          "%%token_class must be followed by an identifier: ", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
     }else if( Symbol_find(x) ){
        ErrorMsg(psp->filename, psp->tokenlineno,
          "Symbol \"%s\" already used", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }else{
        psp->tkclass = Symbol_new(x);
        psp->tkclass->type = MULTITERMINAL;
        psp->state = WAITING_FOR_CLASS_TOKEN;
      }
      break;
    case WAITING_FOR_CLASS_TOKEN:
      if( x[0]=='.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else if( isupper(x[0]) || ((x[0]=='|' || x[0]=='/') && isupper(x[1])) ){
        struct symbol *msp = psp->tkclass;
        msp->nsubsym++;
        msp->subsym = (struct symbol **) realloc(msp->subsym,
          sizeof(struct symbol*)*msp->nsubsym);
        if( !isupper(x[0]) ) x++;
        msp->subsym[msp->nsubsym-1] = Symbol_new(x);
      }else{
        ErrorMsg(psp->filename, psp->tokenlineno,
          "%%token_class argument \"%s\" should be a token", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
#ifdef LEMONEX
    case WAITING_FOR_INTEGRATIONMODE_1:
      if( strcmp(x, "ON") == 0 ){
        psp->gp->lxintegration = 1;
        psp->state = WAITING_FOR_INTEGRATIONMODE_2;
      } else if( strcmp(x, "OFF") == 0 ){
        psp->gp->lxintegration = 0;
        psp->state = WAITING_FOR_INTEGRATIONMODE_2;
      }else{
        ErrorMsg(psp->filename, psp->tokenlineno,
          "Integration mode value must be ON or OFF, received \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_INTEGRATIONMODE_2:
      if( x[0] == '.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \".\" following integration mode, saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_NESTINGDEPTH_1:
      if( (x[0] > 0) && (x[0] <= 9) ){
        psp->gp->lxnestingdepth = atol(x);
        psp->state = WAITING_FOR_NESTINGDEPTH_2;
      }else{
        ErrorMsg(psp->filename, psp->tokenlineno,
          "Nesting depth value must be a non-zero positive integer, received \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_NESTINGDEPTH_2:
      if( x[0] == '.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \".\" following nesting depth, saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_ENCODING_ID_1:
      if( isupper(x[0]) ){
        psp->gp->lxencoding = x;
        psp->state = WAITING_FOR_ENCODING_ID_2;
      }else{
        ErrorMsg(psp->filename, psp->tokenlineno,
          "Encoding name must be an uppercase ID \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_ENCODING_ID_2:
      if( x[0] == '.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \".\" following encoding name, saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_DECL_ERROR;
      }
      break;
    case WAITING_FOR_ARROW_LEX:
      if( x[0]==':' && x[1]==':' && x[2]=='=' ){
        if(psp->first_mode == 0){
          psp->first_mode = LxMode_new(psp, "INITMODE");
        }
        psp->curr_state = psp->last_mode->init_state;
        psp->is_capturing = 1;
        psp->nstarcount = 0;
        psp->state = IN_REGEX;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \":\" following the LHS symbol \"%s\".",
          psp->lhs->name);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case IN_REGEX:
      if( x[0]=='!' ){
        psp->is_capturing = 0;
      }else if( x[0]=='"' ){
        Lexer_process_regex(psp, x+1);
        psp->is_capturing = (psp->lastlxsym==0)?0:1;
      }else if( x[0]=='.' ){
#if 0
        if(psp->nstarcount == 0){
          ErrorMsg(psp->filename,psp->tokenlineno,
            "Regular expression matches empty string.",
            psp->lhs->name);
          psp->errorcnt++;
          psp->state = RESYNC_AFTER_RULE_ERROR;
        }else
#endif
        if(psp->curr_state != 0){
          if(psp->curr_state->is_leaf != 0){
            printf("INTERNAL-ERROR:multiple final-states at state: %d\n", psp->curr_state->state_id);
            exit(1);
          }
          if(psp->lastlxsym != 0) {
            psp->lastlxsym->defined = 1;
          }
          psp->curr_state->is_leaf = 1;
          psp->curr_state->matchedsym = psp->lastlxsym;
          psp->curr_state->init_mode = psp->last_mode;
          if(psp->curr_state->star_state != 0){
            if(psp->curr_state->star_state->is_leaf == 1){
              ErrorMsg(psp->filename,psp->tokenlineno,
                "Overlapping symbols defined, second definition at: '%s'.", x);
              psp->errorcnt++;
              psp->state = RESYNC_AFTER_RULE_ERROR;
            }
            psp->curr_state->star_state->is_leaf = 1;
            psp->curr_state->star_state->matchedsym = psp->curr_state->matchedsym;
            psp->curr_state->star_state->init_mode = psp->curr_state->init_mode;
          }
          psp->state = WAITING_FOR_DECL_OR_RULE;
        }else{
          psp->state = WAITING_FOR_DECL_OR_RULE;
        }
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \"\"\" or \"!\" or \".\" following \"::=\", saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case IN_NEXTMODE:
      if( isupper(x[0]) || (x[0] == '<')){
        psp->last_state->next_mode = x;
        psp->state = NEXT_MODE_1;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Mode name must be an uppercase ID \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case NEXT_MODE_1:
      if( x[0]==']' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \"]\" following the next lexer mode symbol \"%s\".",
          psp->last_state->next_mode);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case WAITING_FOR_MODE_ID_1:
      if( isupper(x[0]) ){
        LxMode_new(psp, x);
        psp->state = WAITING_FOR_MODE_ID_2;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Mode name must be an uppercase ID \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case WAITING_FOR_MODE_ID_2:
      if( x[0] == '.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \".\" following mode name, saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case WAITING_FOR_DEBUG_LEVEL_1:
      if (strcmp(x, "LOW") == 0) {
        psp->gp->lxdebuglevel = 1;
        psp->state = WAITING_FOR_DEBUG_LEVEL_2;
      }else if (strcmp(x, "MEDIUM") == 0) {
        psp->gp->lxdebuglevel = 2;
        psp->state = WAITING_FOR_DEBUG_LEVEL_2;
      }else if (strcmp(x, "HIGH") == 0) {
        psp->gp->lxdebuglevel = 3;
        psp->state = WAITING_FOR_DEBUG_LEVEL_2;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Debug level must be LOW, MEDIUM or HIGH: \"%s\".",x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
    case WAITING_FOR_DEBUG_LEVEL_2:
      if( x[0] == '.' ){
        psp->state = WAITING_FOR_DECL_OR_RULE;
      }else{
        ErrorMsg(psp->filename,psp->tokenlineno,
          "Expected to see a \".\" following debug level, saw '%s'.", x);
        psp->errorcnt++;
        psp->state = RESYNC_AFTER_RULE_ERROR;
      }
      break;
#endif
    case RESYNC_AFTER_RULE_ERROR:
/*      if( x[0]=='.' ) psp->state = WAITING_FOR_DECL_OR_RULE;
**      break; */
    case RESYNC_AFTER_DECL_ERROR:
      if( x[0]=='.' ) psp->state = WAITING_FOR_DECL_OR_RULE;
      if( x[0]=='%' ) psp->state = WAITING_FOR_DECL_KEYWORD;
      break;
  }
}

/* Run the preprocessor over the input file text.  The global variables
** azDefine[0] through azDefine[nDefine-1] contains the names of all defined
** macros.  This routine looks for "%ifdef" and "%ifndef" and "%endif" and
** comments them out.  Text in between is also commented out as appropriate.
*/
static void preprocess_input(char *z){
  int i, j, k, n;
  int exclude = 0;
  int start = 0;
  int lineno = 1;
  int start_lineno = 1;
  for(i=0; z[i]; i++){
    if( z[i]=='\n' ) lineno++;
    if( z[i]!='%' || (i>0 && z[i-1]!='\n') ) continue;
    if( strncmp(&z[i],"%endif",6)==0 && isspace(z[i+6]) ){
      if( exclude ){
        exclude--;
        if( exclude==0 ){
          for(j=start; j<i; j++) if( z[j]!='\n' ) z[j] = ' ';
        }
      }
      for(j=i; z[j] && z[j]!='\n'; j++) z[j] = ' ';
    }else if( (strncmp(&z[i],"%ifdef",6)==0 && isspace(z[i+6]))
          || (strncmp(&z[i],"%ifndef",7)==0 && isspace(z[i+7])) ){
      if( exclude ){
        exclude++;
      }else{
        for(j=i+7; isspace(z[j]); j++){}
        for(n=0; z[j+n] && !isspace(z[j+n]); n++){}
        exclude = 1;
        for(k=0; k<nDefine; k++){
          if( strncmp(azDefine[k],&z[j],n)==0 && lemonStrlen(azDefine[k])==n ){
            exclude = 0;
            break;
          }
        }
        if( z[i+3]=='n' ) exclude = !exclude;
        if( exclude ){
          start = i;
          start_lineno = lineno;
        }
      }
      for(j=i; z[j] && z[j]!='\n'; j++) z[j] = ' ';
    }
  }
  if( exclude ){
    fprintf(stderr,"unterminated %%ifdef starting on line %d\n", start_lineno);
    exit(1);
  }
}

/* In spite of its name, this function is really a scanner.  It read
** in the entire input file (all at once) then tokenizes it.  Each
** token is passed to the function "parseonetoken" which builds all
** the appropriate data structures in the global state vector "gp".
*/
void Parse(struct lemon *gp)
{
  struct pstate ps;
  FILE *fp;
  char *filebuf;
  unsigned int filesize;
  int lineno;
  int c;
  char *cp, *nextcp;
  int startline = 0;

  memset(&ps, '\0', sizeof(ps));
  ps.gp = gp;
  ps.filename = gp->filename;
  ps.errorcnt = 0;
  ps.state = INITIALIZE;

  /* Begin by reading the input file */
  fp = fopen(ps.filename,"rb");
  if( fp==0 ){
    ErrorMsg(ps.filename,0,"Can't open this file for reading.");
    gp->errorcnt++;
    return;
  }
  fseek(fp,0,2);
  filesize = ftell(fp);
  rewind(fp);
  filebuf = (char *)malloc( filesize+1 );
  if( filesize>100000000 || filebuf==0 ){
    ErrorMsg(ps.filename,0,"Input file too large.");
    gp->errorcnt++;
    fclose(fp);
    return;
  }
  if( fread(filebuf,1,filesize,fp)!=filesize ){
    ErrorMsg(ps.filename,0,"Can't read in all %d bytes of this file.",
      filesize);
    free(filebuf);
    gp->errorcnt++;
    fclose(fp);
    return;
  }
  fclose(fp);
  filebuf[filesize] = 0;

  /* Make an initial pass through the file to handle %ifdef and %ifndef */
  preprocess_input(filebuf);

  /* Now scan the text of the input file */
  lineno = 1;
  for(cp=filebuf; (c= *cp)!=0; ){
    if( c=='\n' ) lineno++;              /* Keep track of the line number */
    if( isspace(c) ){ cp++; continue; }  /* Skip all white space */
    if( c=='/' && cp[1]=='/' ){          /* Skip C++ style comments */
      cp+=2;
      while( (c= *cp)!=0 && c!='\n' ) cp++;
      continue;
    }
    if( c=='/' && cp[1]=='*' ){          /* Skip C style comments */
      cp+=2;
      while( (c= *cp)!=0 && (c!='/' || cp[-1]!='*') ){
        if( c=='\n' ) lineno++;
        cp++;
      }
      if( c ) cp++;
      continue;
    }
    ps.tokenstart = cp;                /* Mark the beginning of the token */
    ps.tokenlineno = lineno;           /* Linenumber on which token begins */
    if( c=='\"' ){                     /* String literals */
      cp++;
      while( (c= *cp)!=0 && c!='\"' ){
        if( c=='\n' ) lineno++;
#ifdef LEMONEX
        if((c == '\\') && (cp[1] != 0)){
            cp++;
        }
#endif
        cp++;
      }
      if( c==0 ){
        ErrorMsg(ps.filename,startline,
"String starting on this line is not terminated before the end of the file.");
        ps.errorcnt++;
        nextcp = cp;
      }else{
        nextcp = cp+1;
      }
    }else if( c=='{' ){               /* A block of C code */
      int level;
      cp++;
      for(level=1; (c= *cp)!=0 && (level>1 || c!='}'); cp++){
        if( c=='\n' ) lineno++;
        else if( c=='{' ) level++;
        else if( c=='}' ) level--;
        else if( c=='/' && cp[1]=='*' ){  /* Skip comments */
          int prevc;
          cp = &cp[2];
          prevc = 0;
          while( (c= *cp)!=0 && (c!='/' || prevc!='*') ){
            if( c=='\n' ) lineno++;
            prevc = c;
            cp++;
          }
        }else if( c=='/' && cp[1]=='/' ){  /* Skip C++ style comments too */
          cp = &cp[2];
          while( (c= *cp)!=0 && c!='\n' ) cp++;
          if( c ) lineno++;
        }else if( c=='\'' || c=='\"' ){    /* String a character literals */
          int startchar, prevc;
          startchar = c;
          prevc = 0;
          for(cp++; (c= *cp)!=0 && (c!=startchar || prevc=='\\'); cp++){
            if( c=='\n' ) lineno++;
            if( prevc=='\\' ) prevc = 0;
            else              prevc = c;
          }
        }
      }
      if( c==0 ){
        ErrorMsg(ps.filename,ps.tokenlineno,
"C code starting on this line is not terminated before the end of the file.");
        ps.errorcnt++;
        nextcp = cp;
      }else{
        nextcp = cp+1;
      }
    }else if( isalnum(c) ){          /* Identifiers */
      while( (c= *cp)!=0 && (isalnum(c) || c=='_') ) cp++;
      nextcp = cp;
    }else if( c==':' && cp[1]==':' && cp[2]=='=' ){ /* The operator "::=" */
      cp += 3;
      nextcp = cp;
    }else if( (c=='/' || c=='|') && isalpha(cp[1]) ){
      cp += 2;
      while( (c = *cp)!=0 && (isalnum(c) || c=='_') ) cp++;
      nextcp = cp;
    }else{                          /* All other (one character) operators */
      cp++;
      nextcp = cp;
    }
    c = *cp;
    *cp = 0;                        /* Null terminate the token */
    parseonetoken(&ps);             /* Parse the token */
    *cp = (char)c;                  /* Restore the buffer */
    cp = nextcp;
  }
  free(filebuf);                    /* Release the buffer after parsing */
  gp->rule = ps.firstrule;
  gp->errorcnt = ps.errorcnt;
#ifdef LEMONEX
  if( gp->errorcnt ) exit(gp->errorcnt);
  LxState_postprocess(&ps);
  gp->headmode = ps.first_mode;
  gp->headstate = ps.first_state;
#endif
}
/*************************** From the file "plink.c" *********************/
/*
** Routines processing configuration follow-set propagation links
** in the LEMON parser generator.
*/
static struct plink *plink_freelist = 0;

/* Allocate a new plink */
struct plink *Plink_new(){
  struct plink *newlink;

  if( plink_freelist==0 ){
    int i;
    int amt = 100;
    plink_freelist = (struct plink *)calloc( amt, sizeof(struct plink) );
    if( plink_freelist==0 ){
      fprintf(stderr,
      "Unable to allocate memory for a new follow-set propagation link.\n");
      exit(1);
    }
    for(i=0; i<amt-1; i++) plink_freelist[i].next = &plink_freelist[i+1];
    plink_freelist[amt-1].next = 0;
  }
  newlink = plink_freelist;
  plink_freelist = plink_freelist->next;
  return newlink;
}

/* Add a plink to a plink list */
void Plink_add(struct plink **plpp, struct config *cfp)
{
  struct plink *newlink;
  newlink = Plink_new();
  newlink->next = *plpp;
  *plpp = newlink;
  newlink->cfp = cfp;
}

/* Transfer every plink on the list "from" to the list "to" */
void Plink_copy(struct plink **to, struct plink *from)
{
  struct plink *nextpl;
  while( from ){
    nextpl = from->next;
    from->next = *to;
    *to = from;
    from = nextpl;
  }
}

/* Delete every plink on the list */
void Plink_delete(struct plink *plp)
{
  struct plink *nextpl;

  while( plp ){
    nextpl = plp->next;
    plp->next = plink_freelist;
    plink_freelist = plp;
    plp = nextpl;
  }
}
/*********************** From the file "report.c" **************************/
/*
** Procedures for generating reports and tables in the LEMON parser generator.
*/

/* Generate a filename with the given suffix.  Space to hold the
** name comes from malloc() and must be freed by the calling
** function.
*/
PRIVATE char *file_makename(struct lemon *lemp, const char *suffix)
{
  char *name;
  char *cp;
#ifdef LEMONEX
  cp = strrchr(lemp->filename,'/');
  if(cp == 0)
      cp = strrchr(lemp->filename,'\\');
  if(cp == 0)
      cp = lemp->filename;
  name = malloc( lemonStrlen(ofiledir) + lemonStrlen(cp) + lemonStrlen(suffix) + 5 +1);
  if( name==0 ){
    fprintf(stderr,"Can't allocate space for a filename.\n");
    exit(1);
  }
  strcpy(name,ofiledir);
  strcat(name,"/");
  strcat(name,cp);
#else
  name = (char*)malloc( lemonStrlen(lemp->filename) + lemonStrlen(suffix) + 5 +1);
  if( name==0 ){
    fprintf(stderr,"Can't allocate space for a filename.\n");
    exit(1);
  }
  lemon_strcpy(name,lemp->filename);
#endif
  cp = strrchr(name,'.');
  strcat(name,"/");
  if( cp ) *cp = 0;
  lemon_strcat(name,suffix);
  return name;
}

/* Open a file with a name based on the name of the input file,
** but with a different (specified) suffix, and return a pointer
** to the stream */
PRIVATE FILE *file_open(
  struct lemon *lemp,
  const char *suffix,
  const char *mode
){
  FILE *fp;

  if( lemp->outname ) free(lemp->outname);
  lemp->outname = file_makename(lemp, suffix);
  fp = fopen(lemp->outname,mode);
  if( fp==0 && *mode=='w' ){
    fprintf(stderr,"Can't open file \"%s\".\n",lemp->outname);
    lemp->errorcnt++;
    return 0;
  }
  return fp;
}

/* Duplicate the input file without comments and without actions
** on rules */
void Reprint(struct lemon *lemp)
{
  struct rule *rp;
  struct symbol *sp;
  int i, j, maxlen, len, ncolumns, skip;
  printf("// Reprint of input file \"%s\".\n// Symbols:\n",lemp->filename);
  maxlen = 10;
  for(i=0; i<lemp->nsymbol; i++){
    sp = lemp->symbols[i];
    len = lemonStrlen(sp->name);
    if( len>maxlen ) maxlen = len;
  }
  ncolumns = 76/(maxlen+5);
  if( ncolumns<1 ) ncolumns = 1;
  skip = (lemp->nsymbol + ncolumns - 1)/ncolumns;
  for(i=0; i<skip; i++){
    printf("//");
    for(j=i; j<lemp->nsymbol; j+=skip){
      sp = lemp->symbols[j];
      assert( sp->index==j );
      printf(" %3d %-*.*s",j,maxlen,maxlen,sp->name);
    }
    printf("\n");
  }
  for(rp=lemp->rule; rp; rp=rp->next){
    printf("%s",rp->lhs->name);
    /*    if( rp->lhsalias ) printf("(%s)",rp->lhsalias); */
    printf(" ::=");
    for(i=0; i<rp->nrhs; i++){
      sp = rp->rhs[i];
      if( sp->type==MULTITERMINAL ){
        printf(" %s", sp->subsym[0]->name);
        for(j=1; j<sp->nsubsym; j++){
          printf("|%s", sp->subsym[j]->name);
        }
      }else{
        printf(" %s", sp->name);
      }
      /* if( rp->rhsalias[i] ) printf("(%s)",rp->rhsalias[i]); */
    }
    printf(".");
    if( rp->precsym ) printf(" [%s]",rp->precsym->name);
    /* if( rp->code ) printf("\n    %s",rp->code); */
    printf("\n");
  }
}

/* Print a single rule.
*/
void RulePrint(FILE *fp, struct rule *rp, int iCursor){
  struct symbol *sp;
  int i, j;
  fprintf(fp,"%s ::=",rp->lhs->name);
  for(i=0; i<=rp->nrhs; i++){
    if( i==iCursor ) fprintf(fp," *");
    if( i==rp->nrhs ) break;
    sp = rp->rhs[i];
    if( sp->type==MULTITERMINAL ){
      fprintf(fp," %s", sp->subsym[0]->name);
      for(j=1; j<sp->nsubsym; j++){
        fprintf(fp,"|%s",sp->subsym[j]->name);
      }
    }else{
      fprintf(fp," %s", sp->name);
    }
  }
}

/* Print the rule for a configuration.
*/
void ConfigPrint(FILE *fp, struct config *cfp){
  RulePrint(fp, cfp->rp, cfp->dot);
}

/* #define TEST */
#if 0
/* Print a set */
PRIVATE void SetPrint(out,set,lemp)
FILE *out;
char *set;
struct lemon *lemp;
{
  int i;
  char *spacer;
  spacer = "";
  fprintf(out,"%12s[","");
  for(i=0; i<lemp->nterminal; i++){
    if( SetFind(set,i) ){
      fprintf(out,"%s%s",spacer,lemp->symbols[i]->name);
      spacer = " ";
    }
  }
  fprintf(out,"]\n");
}

/* Print a plink chain */
PRIVATE void PlinkPrint(out,plp,tag)
FILE *out;
struct plink *plp;
char *tag;
{
  while( plp ){
    fprintf(out,"%12s%s (state %2d) ","",tag,plp->cfp->stp->statenum);
    ConfigPrint(out,plp->cfp);
    fprintf(out,"\n");
    plp = plp->next;
  }
}
#endif

/* Print an action to the given file descriptor.  Return FALSE if
** nothing was actually printed.
*/
int PrintAction(
  struct action *ap,          /* The action to print */
  FILE *fp,                   /* Print the action here */
  int indent                  /* Indent by this amount */
){
  int result = 1;
  switch( ap->type ){
    case SHIFT: {
      struct state *stp = ap->x.stp;
      fprintf(fp,"%*s shift        %-7d",indent,ap->sp->name,stp->statenum);
      break;
    }
    case REDUCE: {
      struct rule *rp = ap->x.rp;
      fprintf(fp,"%*s reduce       %-7d",indent,ap->sp->name,rp->index);
      RulePrint(fp, rp, -1);
      break;
    }
    case SHIFTREDUCE: {
      struct rule *rp = ap->x.rp;
      fprintf(fp,"%*s shift-reduce %-7d",indent,ap->sp->name,rp->index);
      RulePrint(fp, rp, -1);
      break;
    }
    case ACCEPT:
      fprintf(fp,"%*s accept",indent,ap->sp->name);
      break;
    case ERROR:
      fprintf(fp,"%*s error",indent,ap->sp->name);
      break;
    case SRCONFLICT:
    case RRCONFLICT:
      fprintf(fp,"%*s reduce       %-7d ** Parsing conflict **",
        indent,ap->sp->name,ap->x.rp->index);
      break;
    case SSCONFLICT:
      fprintf(fp,"%*s shift        %-7d ** Parsing conflict **",
        indent,ap->sp->name,ap->x.stp->statenum);
      break;
    case SH_RESOLVED:
      if( showPrecedenceConflict ){
        fprintf(fp,"%*s shift        %-7d -- dropped by precedence",
                indent,ap->sp->name,ap->x.stp->statenum);
      }else{
        result = 0;
      }
      break;
    case RD_RESOLVED:
      if( showPrecedenceConflict ){
        fprintf(fp,"%*s reduce %-7d -- dropped by precedence",
                indent,ap->sp->name,ap->x.rp->index);
      }else{
        result = 0;
      }
      break;
    case NOT_USED:
      result = 0;
      break;
  }
  return result;
}

/* Generate the "*.out" log file */
void ReportOutput(struct lemon *lemp)
{
  int i;
  struct state *stp;
  struct config *cfp;
  struct action *ap;
  FILE *fp;

  fp = file_open(lemp,".out","wb");
  if( fp==0 ) return;
  for(i=0; i<lemp->nxstate; i++){
    stp = lemp->sorted[i];
    fprintf(fp,"State %d:\n",stp->statenum);
    if( lemp->basisflag ) cfp=stp->bp;
    else                  cfp=stp->cfp;
    while( cfp ){
      char buf[20];
      if( cfp->dot==cfp->rp->nrhs ){
        lemon_sprintf(buf,"(%d)",cfp->rp->index);
        fprintf(fp,"    %5s ",buf);
      }else{
        fprintf(fp,"          ");
      }
      ConfigPrint(fp,cfp);
      fprintf(fp,"\n");
#if 0
      SetPrint(fp,cfp->fws,lemp);
      PlinkPrint(fp,cfp->fplp,"To  ");
      PlinkPrint(fp,cfp->bplp,"From");
#endif
      if( lemp->basisflag ) cfp=cfp->bp;
      else                  cfp=cfp->next;
    }
    fprintf(fp,"\n");
    for(ap=stp->ap; ap; ap=ap->next){
      if( PrintAction(ap,fp,30) ) fprintf(fp,"\n");
    }
    fprintf(fp,"\n");
  }
  fprintf(fp, "----------------------------------------------------\n");
  fprintf(fp, "Symbols:\n");
  for(i=0; i<lemp->nsymbol; i++){
    int j;
    struct symbol *sp;

    sp = lemp->symbols[i];
    fprintf(fp, "  %3d: %s", i, sp->name);
    if( sp->type==NONTERMINAL ){
      fprintf(fp, ":");
      if( sp->lambda ){
        fprintf(fp, " <lambda>");
      }
      for(j=0; j<lemp->nterminal; j++){
        if( sp->firstset && SetFind(sp->firstset, j) ){
          fprintf(fp, " %s", lemp->symbols[j]->name);
        }
      }
    }
    fprintf(fp, "\n");
  }
  fclose(fp);
  return;
}

/* Search for the file "name" which is in the same directory as
** the exacutable */
PRIVATE char *pathsearch(char *argv0, char *name, int modemask)
{
  const char *pathlist;
  char *pathbufptr;
  char *pathbuf;
  char *path,*cp;
  char c;

#ifdef __WIN32__
  cp = strrchr(argv0,'\\');
#else
  cp = strrchr(argv0,'/');
#endif
  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( lemonStrlen(argv0) + lemonStrlen(name) + 2 );
    if( path ) lemon_sprintf(path,"%s/%s",argv0,name);
    *cp = c;
  }else{
    pathlist = getenv("PATH");
    if( pathlist==0 ) pathlist = ".:/bin:/usr/bin";
    pathbuf = (char *) malloc( lemonStrlen(pathlist) + 1 );
    path = (char *)malloc( lemonStrlen(pathlist)+lemonStrlen(name)+2 );
    if( (pathbuf != 0) && (path!=0) ){
      pathbufptr = pathbuf;
      lemon_strcpy(pathbuf, pathlist);
      while( *pathbuf ){
        cp = strchr(pathbuf,':');
        if( cp==0 ) cp = &pathbuf[lemonStrlen(pathbuf)];
        c = *cp;
        *cp = 0;
        lemon_sprintf(path,"%s/%s",pathbuf,name);
        *cp = c;
        if( c==0 ) pathbuf[0] = 0;
        else pathbuf = &cp[1];
        if( access(path,modemask)==0 ) break;
      }
      free(pathbufptr);
    }
  }
  return path;
}

/* Given an action, compute the integer value for that action
** which is to be put in the action table of the generated machine.
** Return negative if no action should be generated.
*/
PRIVATE int compute_action(struct lemon *lemp, struct action *ap)
{
  int act;
  switch( ap->type ){
    case SHIFT:  act = ap->x.stp->statenum;                        break;
    case SHIFTREDUCE: act = ap->x.rp->index + lemp->nstate;        break;
    case REDUCE: act = ap->x.rp->index + lemp->nstate+lemp->nrule; break;
    case ERROR:  act = lemp->nstate + lemp->nrule*2;               break;
    case ACCEPT: act = lemp->nstate + lemp->nrule*2 + 1;           break;
    default:     act = -1; break;
  }
  return act;
}

#define LINESIZE 1000
/* The next cluster of routines are for reading the template file
** and writing the results to the generated parser */
/* The first function transfers data from "in" to "out" until
** a line is seen which begins with "%%".  The line number is
** tracked.
**
** if name!=0, then any word that begin with "Parse" is changed to
** begin with *name instead.
*/
PRIVATE void tplt_xfer(char *name, FILE *in, FILE *out, int *lineno)
{
  int i, iStart;
  char line[LINESIZE];
  while( fgets(line,LINESIZE,in) && (line[0]!='%' || line[1]!='%') ){
    (*lineno)++;
    iStart = 0;
    if( name ){
      for(i=0; line[i]; i++){
        if( line[i]=='P' && strncmp(&line[i],"Parse",5)==0
          && (i==0 || !isalpha(line[i-1]))
        ){
          if( i>iStart ) fprintf(out,"%.*s",i-iStart,&line[iStart]);
          fprintf(out,"%s",name);
          i += 4;
          iStart = i+1;
        }
      }
    }
    fprintf(out,"%s",&line[iStart]);
  }
}

/* The next function finds the template file and opens it, returning
** a pointer to the opened file. */
PRIVATE FILE *tplt_open(struct lemon *lemp)
{
  static char templatename[] = "lempar.c";
  char buf[1000];
  FILE *in;
  char *tpltname;
  char *cp;

  /* first, see if user specified a template filename on the command line. */
  if (user_templatename != 0) {
    if( access(user_templatename,004)==-1 ){
      fprintf(stderr,"Can't find the parser driver template file \"%s\".\n",
        user_templatename);
      lemp->errorcnt++;
      return 0;
    }
    in = fopen(user_templatename,"rb");
    if( in==0 ){
      fprintf(stderr,"Can't open the template file \"%s\".\n",
              user_templatename);
      lemp->errorcnt++;
      return 0;
    }
    return in;
  }

  cp = strrchr(lemp->filename,'.');
  if( cp ){
    lemon_sprintf(buf,"%.*s.lt",(int)(cp-lemp->filename),lemp->filename);
  }else{
    lemon_sprintf(buf,"%s.lt",lemp->filename);
  }
  if( access(buf,004)==0 ){
    tpltname = buf;
  }else if( access(templatename,004)==0 ){
    tpltname = templatename;
  }else{
    tpltname = pathsearch(lemp->argv0,templatename,0);
  }
  if( tpltname==0 ){
    fprintf(stderr,"Can't find the parser driver template file \"%s\".\n",
    templatename);
    lemp->errorcnt++;
    return 0;
  }
  in = fopen(tpltname,"rb");
  if( in==0 ){
    fprintf(stderr,"Can't open the template file \"%s\".\n",templatename);
    lemp->errorcnt++;
    return 0;
  }
  return in;
}

/* Print a #line directive line to the output file. */
PRIVATE void tplt_linedir(FILE *out, int lineno, char *filename)
{
  fprintf(out,"#line %d \"",lineno);
  while( *filename ){
    if( *filename == '\\' ) putc('\\',out);
    putc(*filename,out);
    filename++;
  }
  fprintf(out,"\"\n");
}

/* Print a string to the file and keep the linenumber up to date */
PRIVATE void tplt_print(FILE *out, struct lemon *lemp, char *str, int *lineno)
{
  if( str==0 ) return;
  while( *str ){
    putc(*str,out);
    if( *str=='\n' ) (*lineno)++;
    str++;
  }
  if( str[-1]!='\n' ){
    putc('\n',out);
    (*lineno)++;
  }
  if (!lemp->nolinenosflag) {
    (*lineno)++; tplt_linedir(out,*lineno,lemp->outname);
  }
  return;
}

#ifdef LEMONEX
/*
** The following routine emits code for the token constructor
*/
void emit_lexer_actioncode(
  FILE *out,
  const char *code,
  struct lemon *lemp,
  int *lineno
){
 const char *cp = code;
 for(; *cp; cp++){
   if( *cp=='$' && cp[1]=='$' ){
     fprintf(out,"(lxpLexer->token)");
     cp++;
     continue;
   }
   if( *cp=='\n' ) (*lineno)++;
   fputc(*cp,out);
 }
}

/*
** The following routine emits code for the token constructor
*/
void emit_constructor_code(
  FILE *out,
  const char *ctorcode,
  struct lemon *lemp,
  int *lineno
){
  emit_lexer_actioncode(out, ctorcode, lemp, lineno);
}
#endif

/*
** The following routine emits code for the destructor for the
** symbol sp
*/
void emit_destructor_code(
  FILE *out,
  struct symbol *sp,
  struct lemon *lemp,
  int *lineno
){
 char *cp = 0;

 if( sp->type==TERMINAL ){
#ifdef LEMONEX
  if(lemp->tokentype == 0){
   fprintf(out,"#ifdef LEMONEX\n"); (*lineno)++;
   fprintf(out,"      LX_FREETOK;\n"); (*lineno)++;
   fprintf(out,"#endif /*LEMONEX*/\n"); (*lineno)++;
   return;
  }
#endif
   cp = lemp->tokendest;
   if( cp==0 ) return;
   fprintf(out,"{\n"); (*lineno)++;
 }else if( sp->destructor ){
   cp = sp->destructor;
   fprintf(out,"{\n"); (*lineno)++;
   if( !lemp->nolinenosflag ){
     (*lineno)++;
     tplt_linedir(out,sp->destLineno,lemp->filename);
   }
 }else if( lemp->vardest ){
   cp = lemp->vardest;
   if( cp==0 ) return;
   fprintf(out,"{\n"); (*lineno)++;
 }else{
   assert( 0 );  /* Cannot happen */
 }
 for(; *cp; cp++){
   if( *cp=='$' && cp[1]=='$' ){
     fprintf(out,"(yypminor->yy%d)",sp->dtnum);
     cp++;
     continue;
   }
   if( *cp=='\n' ) (*lineno)++;
   fputc(*cp,out);
 }
 fprintf(out,"\n"); (*lineno)++;
 if (!lemp->nolinenosflag) {
   (*lineno)++; tplt_linedir(out,*lineno,lemp->outname);
 }
 fprintf(out,"}\n"); (*lineno)++;
 return;
}

/*
** Return TRUE (non-zero) if the given symbol has a destructor.
*/
int has_destructor(struct symbol *sp, struct lemon *lemp)
{
  int ret;
  if( sp->type==TERMINAL ){
#ifdef LEMONEX
    ret = (lemp->tokendest!=0)||(lemp->tokentype == 0);
#else
    ret = lemp->tokendest!=0;
#endif
  }else{
    ret = lemp->vardest!=0 || sp->destructor!=0;
  }
  return ret;
}

/*
** Append text to a dynamically allocated string.  If zText is 0 then
** reset the string to be empty again.  Always return the complete text
** of the string (which is overwritten with each call).
**
** n bytes of zText are stored.  If n==0 then all of zText up to the first
** \000 terminator is stored.  zText can contain up to two instances of
** %d.  The values of p1 and p2 are written into the first and second
** %d.
**
** If n==-1, then the previous character is overwritten.
*/
PRIVATE char *append_str(const char *zText, int n, int p1, int p2){
  static char empty[1] = { 0 };
  static char *z = 0;
  static int alloced = 0;
  static int used = 0;
  int c;
  char zInt[40];
  if( zText==0 ){
    used = 0;
    return z;
  }
  if( n<=0 ){
    if( n<0 ){
      used += n;
      assert( used>=0 );
    }
    n = lemonStrlen(zText);
  }
  if( (int) (n+sizeof(zInt)*2+used) >= alloced ){
    alloced = n + sizeof(zInt)*2 + used + 200;
    z = (char *) realloc(z,  alloced);
  }
  if( z==0 ) return empty;
  while( n-- > 0 ){
    c = *(zText++);
    if( c=='%' && n>0 && zText[0]=='d' ){
      lemon_sprintf(zInt, "%d", p1);
      p1 = p2;
      lemon_strcpy(&z[used], zInt);
      used += lemonStrlen(&z[used]);
      zText++;
      n--;
    }else{
      z[used++] = (char)c;
    }
  }
  z[used] = 0;
  return z;
}

/*
** zCode is a string that is the action associated with a rule.  Expand
** the symbols in this string so that the refer to elements of the parser
** stack.
*/
PRIVATE void translate_code(struct lemon *lemp, struct rule *rp){
  char *cp, *xp;
  int i;
  char lhsused = 0;    /* True if the LHS element has been used */
  char used[MAXRHS];   /* True for each RHS element which is used */

  for(i=0; i<rp->nrhs; i++) used[i] = 0;
  lhsused = 0;

  if( rp->code==0 ){
    static char newlinestr[2] = { '\n', '\0' };
    rp->code = newlinestr;
    rp->line = rp->ruleline;
  }

  append_str(0,0,0,0);

  /* This const cast is wrong but harmless, if we're careful. */
  for(cp=(char *)rp->code; *cp; cp++){
    if( isalpha(*cp) && (cp==rp->code || (!isalnum(cp[-1]) && cp[-1]!='_')) ){
      char saved;
      for(xp= &cp[1]; isalnum(*xp) || *xp=='_'; xp++);
      saved = *xp;
      *xp = 0;
      if( rp->lhsalias && strcmp(cp,rp->lhsalias)==0 ){
        append_str("yygotominor.yy%d",0,rp->lhs->dtnum,0);
        cp = xp;
        lhsused = 1;
      }else{
        for(i=0; i<rp->nrhs; i++){
          if( rp->rhsalias[i] && strcmp(cp,rp->rhsalias[i])==0 ){
            if( cp!=rp->code && cp[-1]=='@' ){
              /* If the argument is of the form @X then substituted
              ** the token number of X, not the value of X */
              append_str("yymsp[%d].major",-1,i-rp->nrhs+1,0);
            }else{
              struct symbol *sp = rp->rhs[i];
              int dtnum;
              if( sp->type==MULTITERMINAL ){
                dtnum = sp->subsym[0]->dtnum;
              }else{
                dtnum = sp->dtnum;
              }
              append_str("yymsp[%d].minor.yy%d",0,i-rp->nrhs+1, dtnum);
            }
            cp = xp;
            used[i] = 1;
            break;
          }
        }
      }
      *xp = saved;
    }
    append_str(cp, 1, 0, 0);
  } /* End loop */

  /* Check to make sure the LHS has been used */
  if( rp->lhsalias && !lhsused ){
    ErrorMsg(lemp->filename,rp->ruleline,
      "Label \"%s\" for \"%s(%s)\" is never used.",
        rp->lhsalias,rp->lhs->name,rp->lhsalias);
    lemp->errorcnt++;
  }

  /* Generate destructor code for RHS symbols which are not used in the
  ** reduce code */
  for(i=0; i<rp->nrhs; i++){
    if( rp->rhsalias[i] && !used[i] ){
      ErrorMsg(lemp->filename,rp->ruleline,
        "Label %s for \"%s(%s)\" is never used.",
        rp->rhsalias[i],rp->rhs[i]->name,rp->rhsalias[i]);
      lemp->errorcnt++;
    }else if( rp->rhsalias[i]==0 ){
      if( has_destructor(rp->rhs[i],lemp) ){
        append_str("  yy_destructor(yypParser,%d,&yymsp[%d].minor);\n", 0,
           rp->rhs[i]->index,i-rp->nrhs+1);
      }else{
        /* No destructor defined for this term */
      }
    }
  }
  if( rp->code ){
    cp = append_str(0,0,0,0);
    rp->code = Strsafe(cp?cp:"");
  }
}

/*
** Generate code which executes when the rule "rp" is reduced.  Write
** the code to "out".  Make sure lineno stays up-to-date.
*/
PRIVATE void emit_code(
  FILE *out,
  struct rule *rp,
  struct lemon *lemp,
  int *lineno
){
 const char *cp;

 /* Generate code to do the reduce action */
 if( rp->code ){
   if( !lemp->nolinenosflag ){
     (*lineno)++;
     tplt_linedir(out,rp->line,lemp->filename);
   }
   fprintf(out,"{%s",rp->code);
   for(cp=rp->code; *cp; cp++){
     if( *cp=='\n' ) (*lineno)++;
   } /* End loop */
   fprintf(out,"}\n"); (*lineno)++;
   if( !lemp->nolinenosflag ){
     (*lineno)++;
     tplt_linedir(out,*lineno,lemp->outname);
   }
 } /* End if( rp->code ) */

 return;
}

/*
** Print the definition of the union used for the parser's data stack.
** This union contains fields for every possible data type for tokens
** and nonterminals.  In the process of computing and printing this
** union, also set the ".dtnum" field of every terminal and nonterminal
** symbol.
*/
void print_stack_union(
  FILE *out,                  /* The output stream */
  struct lemon *lemp,         /* The main info structure for this parser */
  int *plineno,               /* Pointer to the line number */
  int mhflag                  /* True if generating makeheaders output */
){
  int lineno = *plineno;    /* The line number of the output */
  char **types;             /* A hash table of datatypes */
  int arraysize;            /* Size of the "types" array */
  int maxdtlength;          /* Maximum length of any ".datatype" field. */
  char *stddt;              /* Standardized name for a datatype */
  int i,j;                  /* Loop counters */
  unsigned hash;            /* For hashing the name of a type */
  const char *name;         /* Name of the parser */

  /* Allocate and initialize types[] and allocate stddt[] */
  arraysize = lemp->nsymbol * 2;
  types = (char**)calloc( arraysize, sizeof(char*) );
  if( types==0 ){
    fprintf(stderr,"Out of memory.\n");
    exit(1);
  }
  for(i=0; i<arraysize; i++) types[i] = 0;
  maxdtlength = 0;
  if( lemp->vartype ){
    maxdtlength = lemonStrlen(lemp->vartype);
  }
  for(i=0; i<lemp->nsymbol; i++){
    int len;
    struct symbol *sp = lemp->symbols[i];
    if( sp->datatype==0 ) continue;
    len = lemonStrlen(sp->datatype);
    if( len>maxdtlength ) maxdtlength = len;
  }
  stddt = (char*)malloc( maxdtlength*2 + 1 );
  if( stddt==0 ){
    fprintf(stderr,"Out of memory.\n");
    exit(1);
  }

  /* Build a hash table of datatypes. The ".dtnum" field of each symbol
  ** is filled in with the hash index plus 1.  A ".dtnum" value of 0 is
  ** used for terminal symbols.  If there is no %default_type defined then
  ** 0 is also used as the .dtnum value for nonterminals which do not specify
  ** a datatype using the %type directive.
  */
  for(i=0; i<lemp->nsymbol; i++){
    struct symbol *sp = lemp->symbols[i];
    char *cp;
    if( sp==lemp->errsym ){
      sp->dtnum = arraysize+1;
      continue;
    }
    if( sp->type!=NONTERMINAL || (sp->datatype==0 && lemp->vartype==0) ){
      sp->dtnum = 0;
      continue;
    }
    cp = sp->datatype;
    if( cp==0 ) cp = lemp->vartype;
    j = 0;
    while( isspace(*cp) ) cp++;
    while( *cp ) stddt[j++] = *cp++;
    while( j>0 && isspace(stddt[j-1]) ) j--;
    stddt[j] = 0;
    if( lemp->tokentype && strcmp(stddt, lemp->tokentype)==0 ){
      sp->dtnum = 0;
      continue;
    }
    hash = 0;
    for(j=0; stddt[j]; j++){
      hash = hash*53 + stddt[j];
    }
    hash = (hash & 0x7fffffff)%arraysize;
    while( types[hash] ){
      if( strcmp(types[hash],stddt)==0 ){
        sp->dtnum = hash + 1;
        break;
      }
      hash++;
      if( hash>=(unsigned)arraysize ) hash = 0;
    }
    if( types[hash]==0 ){
      sp->dtnum = hash + 1;
      types[hash] = (char*)malloc( lemonStrlen(stddt)+1 );
      if( types[hash]==0 ){
        fprintf(stderr,"Out of memory.\n");
        exit(1);
      }
      lemon_strcpy(types[hash],stddt);
    }
  }

  /* Print out the definition of YYTOKENTYPE and YYMINORTYPE */
  name = lemp->name ? lemp->name : "Parse";
  lineno = *plineno;
  if( mhflag ){ fprintf(out,"#if INTERFACE\n"); lineno++; }
#ifdef LEMONEX
  fprintf(out,"#ifdef LEMONEX\n");lineno++;
  fprintf(out,"#define %sTOKENTYPE %s\n",name,
    lemp->tokentype?lemp->tokentype:"struct lxToken");  lineno++;
  fprintf(out,"#define %sTOKENTYPE_DEF %d\n",name,
    lemp->tokentype?0:1);  lineno++;
  fprintf(out,"#else /* LEMONEX */\n");lineno++;
  fprintf(out,"#define %sTOKENTYPE %s\n",name,
    lemp->tokentype?lemp->tokentype:"void*");  lineno++;
  fprintf(out,"#endif /* LEMONEX */\n");lineno++;
#else
  fprintf(out,"#define %sTOKENTYPE %s\n",name,
    lemp->tokentype?lemp->tokentype:"void*");  lineno++;
#endif
  if( mhflag ){ fprintf(out,"#endif\n"); lineno++; }
  fprintf(out,"typedef union {\n"); lineno++;
  fprintf(out,"  int yyinit;\n"); lineno++;
  fprintf(out,"  %sTOKENTYPE yy0;\n",name); lineno++;
  for(i=0; i<arraysize; i++){
    if( types[i]==0 ) continue;
    fprintf(out,"  %s yy%d;\n",types[i],i+1); lineno++;
    free(types[i]);
  }
  if( lemp->errsym->useCnt ){
    fprintf(out,"  int yy%d;\n",lemp->errsym->dtnum); lineno++;
  }
  free(stddt);
  free(types);
  fprintf(out,"} YYMINORTYPE;\n"); lineno++;
  *plineno = lineno;
}

/*
** Return the name of a C datatype able to represent values between
** lwr and upr, inclusive.  If pnByte!=NULL then also write the sizeof
** for that type (1, 2, or 4) into *pnByte.
*/
static const char *minimum_size_type(int lwr, int upr, int *pnByte){
  const char *zType = "int";
  int nByte = 4;
  if( lwr>=0 ){
    if( upr<=255 ){
      zType = "unsigned char";
      nByte = 1;
    }else if( upr<65535 ){
      zType = "unsigned short int";
      nByte = 2;
    }else{
      zType = "unsigned int";
      nByte = 4;
    }
  }else if( lwr>=-127 && upr<=127 ){
    zType = "signed char";
    nByte = 1;
  }else if( lwr>=-32767 && upr<32767 ){
    zType = "short";
    nByte = 2;
  }
  if( pnByte ) *pnByte = nByte;
  return zType;
}

/*
** Each state contains a set of token transaction and a set of
** nonterminal transactions.  Each of these sets makes an instance
** of the following structure.  An array of these structures is used
** to order the creation of entries in the yy_action[] table.
*/
struct axset {
  struct state *stp;   /* A pointer to a state */
  int isTkn;           /* True to use tokens.  False for non-terminals */
  int nAction;         /* Number of actions */
  int iOrder;          /* Original order of action sets */
};

/*
** Compare to axset structures for sorting purposes
*/
static int axset_compare(const void *a, const void *b){
  struct axset *p1 = (struct axset*)a;
  struct axset *p2 = (struct axset*)b;
  int c;
  c = p2->nAction - p1->nAction;
  if( c==0 ){
    c = p1->iOrder - p2->iOrder;
  }
  assert( c!=0 || p1==p2 );
  return c;
}

/*
** Write text on "out" that describes the rule "rp".
*/
static void writeRuleText(FILE *out, struct rule *rp){
  int j;
  fprintf(out,"%s ::=", rp->lhs->name);
  for(j=0; j<rp->nrhs; j++){
    struct symbol *sp = rp->rhs[j];
    if( sp->type!=MULTITERMINAL ){
      fprintf(out," %s", sp->name);
    }else{
      int k;
      fprintf(out," %s", sp->subsym[0]->name);
      for(k=1; k<sp->nsubsym; k++){
        fprintf(out,"|%s",sp->subsym[k]->name);
      }
    }
  }
}

#ifdef LEMONEX
void Lexer_generate_class_list(struct lemon *lemp, FILE *fp, int *lineno){
  int i = 0;
  while(lemp->lxclasslist[i+1] != 0) {
    if(lemp->lxclasslist[i] == 0) {
      if(i > 0){
        fprintf(fp, "  0,0\n");(*lineno)++;
        fprintf(fp, "};\n");(*lineno)++;
      }
      fprintf(fp, "static int lxcls_%c[] = {\n", lemp->lxclasslist[i+1]);(*lineno)++;
    }else{
      fprintf(fp, "  0x%-6X,0x%-6X,", lemp->lxclasslist[i], lemp->lxclasslist[i+1]);(*lineno)++;
      if((i%8) == 0){
        fprintf(fp, "\n");
      }
    }
    i += 2;
  }
  fprintf(fp, "  0,0\n");(*lineno)++;
  fprintf(fp, "};\n");(*lineno)++;
}

static void lx_generate_send(struct lemon* lemp, FILE* out, struct LxState *curr_state){
  /* generate user action code if specified */
  if(curr_state->code != 0){
    fprintf(out, "  LX_ACTION(%d);", curr_state->state_id);
  }else{
    fprintf(out, "  ");
  }

  /* send token, if set */
  if(curr_state->matchedsym > 0){
    const char *prefix;
    if( lemp->tokenprefix ) prefix = lemp->tokenprefix;
    else                    prefix = "";
    fprintf(out, "LX_SEND(%s%s);"
      , prefix
      , lemp->symbols[curr_state->matchedsym->index]->name
    );
  }else{
    fprintf(out, "/*NO_SEND*/");
  }

  /* reset current capture */
  fprintf(out, "LX_RESET;");
}

static void lx_generate_conditions(struct lemon* lemp, FILE* out, int *lineno, struct LxState *curr_state, struct LxTransition *tx){
  if(tx->ch0 == 0){
    switch(tx->ch1){
      case LXCLASS_LETTER:
        fprintf(out, "  if(LX_ISLETTER(ch)==1)");
        break;
      case LXCLASS_DIGIT:
        fprintf(out, "  if(LX_ISDIGIT(ch)==1)");
        break;
      case LXCLASS_WORD:
        fprintf(out, "  if(LX_ISWORD(ch)==1)");
        break;
      case LXCLASS_SPACE:
        fprintf(out, "  if(LX_ISSPACE(ch)==1)");
        break;
      case LXCLASS_DOT:
        /* DOT transition should always be the last one */
        assert(tx->next_transition == 0);
        assert(curr_state->dot_transition == tx);
        fprintf(out, "  if(ch != 0)");
        break;
      default:
        printf("Internal error: unknown range\n");
        exit(1);
    }
  }else if(tx->ch1 == 0){
    fprintf(out, "  if(ch == %d)", tx->ch0);
  }else{
    fprintf(out, "  if((ch >= %d) && (ch <= %d))", tx->ch0, tx->ch1);
  }
}

static void lx_generate_leaf(struct lemon* lemp, FILE* out, int *lineno, struct LxState *curr_state, int tx_type){
  if(tx_type == NOT_TX){
    if(curr_state->dot_transition == 0){
      lx_generate_send(lemp, out, curr_state);
    }
    return;
  }
  assert(tx_type == REGULAR_TX);

  /* if this is not a leaf state */
  if(curr_state->is_leaf == 0) {
    if(curr_state->dot_transition != 0){
      fprintf(out, "  lxpLexer->lxstate=%d;", curr_state->state_id);
      fprintf(out, "return 0;\n");(*lineno)++;
    }else if(curr_state->head_transition != 0){
      fprintf(out, "  if(ch == 0){");
      fprintf(out, "lxpLexer->lxstate=%d;", curr_state->state_id);
      fprintf(out, "return 0;");
      fprintf(out, "}\n");(*lineno)++;
    }
    return;
  }

  /* if this is a leaf state */
  assert(curr_state->is_leaf == 1);

  if(curr_state->dot_transition != 0){
    fprintf(out, "  if(is_final == 0) {");
  }else{
    fprintf(out, "  if((ch == 0) && (is_final == 0)) {");
  }
  fprintf(out, "lxpLexer->lxstate=%d;", curr_state->state_id);
  fprintf(out, "return 0;");
  fprintf(out, "}\n");(*lineno)++;

  if((curr_state->not_transition == 0) && (curr_state->dot_transition == 0)){
    lx_generate_send(lemp, out, curr_state);
    fprintf(out, "\n");(*lineno)++;
  }

  /* if ch is 0 here, is_final will be 1, so send EOF marker */
  if(curr_state->dot_transition == 0){
    fprintf(out, "  if(ch == 0) {");
  }else{
    fprintf(out, "  ");
  }
  fprintf(out, "LX_SEND(0);");
  fprintf(out, "return 0;");
  if(curr_state->dot_transition == 0){
    fprintf(out, "}");
  }
  fprintf(out, "\n");(*lineno)++;
}

static void lx_generate_jump(struct lemon* lemp, FILE* out, int *lineno, struct LxState *curr_state, int tx_type){
  if(tx_type == REGULAR_TX){
    fprintf(out, "  ");
  }
  if(curr_state->is_leaf == 1) {
    /* if curr_state transitions to another mode, go to that mode's init state */
    if(curr_state->next_mode != 0){
      if(strcmp(curr_state->next_mode, "<") != 0){
        struct LxMode* next_mode = LxMode_find(lemp, curr_state->next_mode);
        if(next_mode == 0) {
          printf("INTERNAL-ERROR:invalid next-mode in state: %s\n", curr_state->next_mode);
          exit(1);
        }
        if(next_mode->init_state != curr_state->init_mode->init_state){
          fprintf(out, "LX_ENTER_NESTING(%d);", curr_state->init_mode->init_state->state_id);
        }else{
          fprintf(out, "LX_RENEW_NESTING;");
        }
        if(tx_type == REGULAR_TX){
          fprintf(out, "\n  ");(*lineno)++;
        }
        fprintf(out, "goto S%d; /* by retn_state */", next_mode->init_state->state_id);
      }else{
        /* if next mode is <, return to calling mode */
        fprintf(out, "if(LX_LEAVE_NESTING() == 1){goto L0;}");
        if(tx_type == REGULAR_TX){
          fprintf(out, "\n  ");(*lineno)++;
        }
        fprintf(out, "goto S%d; /* by next_state */", curr_state->init_mode->init_state->state_id);
      }
    }else{
      if(curr_state->dot_transition == 0){
        fprintf(out, "goto S%d; /* by init_state */", curr_state->init_mode->init_state->state_id);
      }
    }
  }else if(curr_state->goto_state != 0){
    if(curr_state->dot_transition == 0){
      fprintf(out, "goto S%d; /* by goto_state */", curr_state->goto_state->state_id);
    }
  }else{
    if(curr_state->dot_transition == 0){
#if LEMONEX_DBG>=1
      fprintf(out, "printf(\"(%%d,%%d):Error in state %d on %%u(%%c)###########\\n\", lxpLexer->lxrow, lxpLexer->lxcol, ch, ch);",
        curr_state->state_id);
      if(tx_type == REGULAR_TX){
        fprintf(out, "\n  ");(*lineno)++;
      }
#endif
      fprintf(out, "LX_SENDERR(%d);return -1;", lemp->errsym->index);
    }
  }
  if(tx_type == REGULAR_TX){
    fprintf(out, "\n");(*lineno)++;
  }
}

static void lx_generate_output(struct lemon* lemp, FILE* out, int *lineno){
  fprintf(out, "  LX_ADVANCE(lxpLexer->lxstate);\n");(*lineno)++;
  fprintf(out, "L0:\n");(*lineno)++;
  if (lemp->lxdebuglevel >= 1) {
    fprintf(out, "  printf(\"L0:%%d\\n\", lxpLexer->lxstate);\n");(*lineno)++;
  }
  fprintf(out, "  switch(lxpLexer->lxstate) {\n");(*lineno)++;
  for(struct LxState* curr_state = lemp->headstate; curr_state != 0; curr_state = curr_state->next_state){
    fprintf(out, "    case %d:goto S%d;\n",
      curr_state->state_id, curr_state->state_id);(*lineno)++;
  }
  fprintf(out, "  }\n");(*lineno)++;

  for(struct LxState* curr_state = lemp->headstate; curr_state != 0; curr_state = curr_state->next_state){
    fprintf(out, "S%d:\n", curr_state->state_id);(*lineno)++;
    assert((curr_state->code == 0) || (curr_state->is_leaf != 0));

    if (lemp->lxdebuglevel >= 1) {
      fprintf(out, "  printf(\"S%d(%%d,%%d):0x%%X(%%c)\\n\", lxpLexer->lxrow, lxpLexer->lxcol, ch, ((ch>= 32) && (ch <= 127))?ch:' ');\n"
        ,curr_state->state_id
      );(*lineno)++;
    }
    if (lemp->lxdebuglevel >= 2) {
      LX_PRINT_STATE(out, curr_state);
    }

    for(struct LxTransition* tx = curr_state->head_transition; tx != 0; tx = tx->next_transition){
      LX_PRINT_TRANSITION(out, curr_state, tx);
      if((tx->ch0 == 0) && (tx->ch1 == 0)){
        fprintf(out, "  /*loop --> %d*/\n", tx->next_state->state_id);(*lineno)++;
      }else{
        lx_generate_conditions(lemp, out, lineno, curr_state, tx);
        fprintf(out, "{");
        if(tx->tx_type == NOT_TX){
          lx_generate_leaf(lemp, out, lineno, curr_state, 1);
          lx_generate_jump(lemp, out, lineno, curr_state, 1);
        }else{
          if(curr_state->is_leaf == 1){
            if((curr_state->not_transition != 0) && (curr_state->not_transition != tx)){
              if(tx->tx_type == INIT_TX){
                lx_generate_send(lemp, out, curr_state);
              }
            }else if((curr_state->dot_transition != 0) && (curr_state->dot_transition != tx)){
              if(tx->tx_type == INIT_TX){
                lx_generate_send(lemp, out, curr_state);
              }
            }
          }
          if(tx->is_capturing == 1){
            fprintf(out, "LX_CAPTURE(curr_pos, curr_len);");
          }
          fprintf(out, "LX_ADVANCE(%d);goto S%d; /*1*/", tx->next_state->state_id, tx->next_state->state_id);
        }
        fprintf(out, "}");
        fprintf(out, "\n");(*lineno)++;
      }
    }

    if(curr_state->not_transition != 0){
      lx_generate_leaf(lemp, out, lineno, curr_state, 0);
      fprintf(out, "  ");
      if(curr_state->not_transition->is_capturing == 1){
        fprintf(out, "LX_CAPTURE(curr_pos, curr_len);");
      }
      fprintf(out, "LX_ADVANCE(%d);goto S%d; /*2*/\n", curr_state->not_transition->next_state->state_id, curr_state->not_transition->next_state->state_id);(*lineno)++;
    }else{
      lx_generate_leaf(lemp, out, lineno, curr_state, 0);
      lx_generate_jump(lemp, out, lineno, curr_state, 0);
    }
  }

  /* generate undefined warnings */
  for(int i=0; i<lemp->nsymbol; i++){
    if((lemp->symbols[i]->type == TERMINAL) && (lemp->symbols[i]->defined == 0)) {
      printf("WARNING:Symbol not defined in lexer:%s\n", lemp->symbols[i]->name);
    }
  }
}
#endif

/* Generate C source code for the parser */
void ReportTable(
  struct lemon *lemp,
  int mhflag     /* Output in makeheaders format if true */
){
  FILE *out, *in;
  char line[LINESIZE];
  int  lineno;
  struct state *stp;
  struct action *ap;
  struct rule *rp;
  struct acttab *pActtab;
  int i, j, n, sz;
  int szActionType;     /* sizeof(YYACTIONTYPE) */
  int szCodeType;       /* sizeof(YYCODETYPE)   */
  const char *name;
  int mnTknOfst, mxTknOfst;
  int mnNtOfst, mxNtOfst;
  struct axset *ax;

  in = tplt_open(lemp);
  if( in==0 ) return;
#ifdef LEMONEX
  out = file_open(lemp,ofileext,"wb");
#else
  out = file_open(lemp,".c","wb");
#endif
  if( out==0 ){
    fclose(in);
    return;
  }
  lineno = 1;
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate the include code, if any */
  tplt_print(out,lemp,lemp->include,&lineno);
#ifdef LEMONEX
  /* The include code might contain pch header, so include stdio.h here */
  fprintf(out, "#define LEMONEX_DBGLVL %d\n", lemp->lxdebuglevel); lineno++;
#endif
  if (mhflag){
    char *incName = file_makename(lemp, ".h");
    fprintf(out,"#include \"%s\"\n", incName); lineno++;
    free(incName);
  }
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate #defines for all tokens */
#ifdef LEMONEX
  const char *prefix;
  if( lemp->tokenprefix ) prefix = lemp->tokenprefix;
  else                    prefix = "";
  for(i=1; i<lemp->nterminal; i++){
    fprintf(out,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);
    lineno++;
  }
#else
  if( mhflag ){
    const char *prefix;
    fprintf(out,"#if INTERFACE\n"); lineno++;
    if( lemp->tokenprefix ) prefix = lemp->tokenprefix;
    else                    prefix = "";
    for(i=1; i<lemp->nterminal; i++){
      fprintf(out,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);
      lineno++;
    }
    fprintf(out,"#endif\n"); lineno++;
  }
#endif
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate the defines */
  fprintf(out,"#define YYCODETYPE %s\n",
    minimum_size_type(0, lemp->nsymbol+1, &szCodeType)); lineno++;
  fprintf(out,"#define YYNOCODE %d\n",lemp->nsymbol+1);  lineno++;
  fprintf(out,"#define YYACTIONTYPE %s\n",
    minimum_size_type(0,lemp->nstate+lemp->nrule*2+5,&szActionType)); lineno++;
  if( lemp->wildcard ){
    fprintf(out,"#define YYWILDCARD %d\n",
       lemp->wildcard->index); lineno++;
  }
  print_stack_union(out,lemp,&lineno,mhflag);
  fprintf(out, "#ifndef YYSTACKDEPTH\n"); lineno++;
  if( lemp->stacksize ){
    fprintf(out,"#define YYSTACKDEPTH %s\n",lemp->stacksize);  lineno++;
  }else{
    fprintf(out,"#define YYSTACKDEPTH 100\n");  lineno++;
  }
  fprintf(out, "#endif\n"); lineno++;
  if( mhflag ){
    fprintf(out,"#if INTERFACE\n"); lineno++;
  }
  name = lemp->name ? lemp->name : "Parse";
  if( lemp->arg && lemp->arg[0] ){
    i = lemonStrlen(lemp->arg);
    while( i>=1 && isspace(lemp->arg[i-1]) ) i--;
    while( i>=1 && (isalnum(lemp->arg[i-1]) || lemp->arg[i-1]=='_') ) i--;
    fprintf(out,"#define %sARG_SDECL %s;\n",name,lemp->arg);  lineno++;
    fprintf(out,"#define %sARG_PDECL ,%s\n",name,lemp->arg);  lineno++;
    fprintf(out,"#define %sARG_FETCH %s = yypParser->%s\n",
                 name,lemp->arg,&lemp->arg[i]);  lineno++;
    fprintf(out,"#define %sARG_STORE yypParser->%s = %s\n",
                 name,&lemp->arg[i],&lemp->arg[i]);  lineno++;
#ifdef LEMONEX
    fprintf(out,"#ifdef LEMONEX\n"); lineno++;
    fprintf(out,"#define %sARG_VNAME ,%s\n",
                 name,&lemp->arg[i]);  lineno++;
    fprintf(out,"#endif\n"); lineno++;
#endif
  }else{
    fprintf(out,"#define %sARG_SDECL\n",name);  lineno++;
    fprintf(out,"#define %sARG_PDECL\n",name);  lineno++;
    fprintf(out,"#define %sARG_FETCH\n",name); lineno++;
    fprintf(out,"#define %sARG_STORE\n",name); lineno++;
#ifdef LEMONEX
    fprintf(out,"#ifdef LEMONEX\n"); lineno++;
    fprintf(out,"#define %sARG_VNAME\n",name); lineno++;
    fprintf(out,"#endif\n"); lineno++;
#endif
  }
  if( mhflag ){
    fprintf(out,"#endif\n"); lineno++;
  }
  if( lemp->errsym->useCnt ){
    fprintf(out,"#define YYERRORSYMBOL %d\n",lemp->errsym->index); lineno++;
    fprintf(out,"#define YYERRSYMDT yy%d\n",lemp->errsym->dtnum); lineno++;
  }
  if( lemp->has_fallback ){
    fprintf(out,"#define YYFALLBACK 1\n");  lineno++;
  }

#ifdef LEMONEX
  fprintf(out,"#ifdef LEMONEX\n"); lineno++;
  fprintf(out,"#define %sLX_INTEGRATEDMODE %d\n", name, lemp->lxintegration); lineno++;
  fprintf(out,"#define %sLX_NESTINGDEPTH %d\n", name, lemp->lxnestingdepth); lineno++;
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes when token needs to be created */
  if(lemp->tokenctor) {
    emit_constructor_code(out, lemp->tokenctor, lemp, &lineno);
  }

  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate char class list */
  Lexer_generate_class_list(lemp, out, &lineno);
  fprintf(out,"#endif\n"); lineno++;
#endif

  /* Compute the action table, but do not output it yet.  The action
  ** table must be computed before generating the YYNSTATE macro because
  ** we need to know how many states can be eliminated.
  */
  ax = (struct axset *) calloc(lemp->nxstate*2, sizeof(ax[0]));
  if( ax==0 ){
    fprintf(stderr,"malloc failed\n");
    exit(1);
  }
  for(i=0; i<lemp->nxstate; i++){
    stp = lemp->sorted[i];
    ax[i*2].stp = stp;
    ax[i*2].isTkn = 1;
    ax[i*2].nAction = stp->nTknAct;
    ax[i*2+1].stp = stp;
    ax[i*2+1].isTkn = 0;
    ax[i*2+1].nAction = stp->nNtAct;
  }
  mxTknOfst = mnTknOfst = 0;
  mxNtOfst = mnNtOfst = 0;
  /* In an effort to minimize the action table size, use the heuristic
  ** of placing the largest action sets first */
  for(i=0; i<lemp->nxstate*2; i++) ax[i].iOrder = i;
  qsort(ax, lemp->nxstate*2, sizeof(ax[0]), axset_compare);
  pActtab = acttab_alloc();
  for(i=0; i<lemp->nxstate*2 && ax[i].nAction>0; i++){
    stp = ax[i].stp;
    if( ax[i].isTkn ){
      for(ap=stp->ap; ap; ap=ap->next){
        int action;
        if( ap->sp->index>=lemp->nterminal ) continue;
        action = compute_action(lemp, ap);
        if( action<0 ) continue;
        acttab_action(pActtab, ap->sp->index, action);
      }
      stp->iTknOfst = acttab_insert(pActtab);
      if( stp->iTknOfst<mnTknOfst ) mnTknOfst = stp->iTknOfst;
      if( stp->iTknOfst>mxTknOfst ) mxTknOfst = stp->iTknOfst;
    }else{
      for(ap=stp->ap; ap; ap=ap->next){
        int action;
        if( ap->sp->index<lemp->nterminal ) continue;
        if( ap->sp->index==lemp->nsymbol ) continue;
        action = compute_action(lemp, ap);
        if( action<0 ) continue;
        acttab_action(pActtab, ap->sp->index, action);
      }
      stp->iNtOfst = acttab_insert(pActtab);
      if( stp->iNtOfst<mnNtOfst ) mnNtOfst = stp->iNtOfst;
      if( stp->iNtOfst>mxNtOfst ) mxNtOfst = stp->iNtOfst;
    }
#if 0  /* Uncomment for a trace of how the yy_action[] table fills out */
    { int jj, nn;
      for(jj=nn=0; jj<pActtab->nAction; jj++){
        if( pActtab->aAction[jj].action<0 ) nn++;
      }
      printf("%4d: State %3d %s n: %2d size: %5d freespace: %d\n",
             i, stp->statenum, ax[i].isTkn ? "Token" : "Var  ",
             ax[i].nAction, pActtab->nAction, nn);
    }
#endif
  }
  free(ax);

  /* Finish rendering the constants now that the action table has
  ** been computed */
  fprintf(out,"#define YYNSTATE             %d\n",lemp->nxstate);  lineno++;
  fprintf(out,"#define YYNRULE              %d\n",lemp->nrule);  lineno++;
  fprintf(out,"#define YY_MAX_SHIFT         %d\n",lemp->nxstate-1); lineno++;
  fprintf(out,"#define YY_MIN_SHIFTREDUCE   %d\n",lemp->nstate); lineno++;
  i = lemp->nstate + lemp->nrule;
  fprintf(out,"#define YY_MAX_SHIFTREDUCE   %d\n", i-1); lineno++;
  fprintf(out,"#define YY_MIN_REDUCE        %d\n", i); lineno++;
  i = lemp->nstate + lemp->nrule*2;
  fprintf(out,"#define YY_MAX_REDUCE        %d\n", i-1); lineno++;
  fprintf(out,"#define YY_ERROR_ACTION      %d\n", i); lineno++;
  fprintf(out,"#define YY_ACCEPT_ACTION     %d\n", i+1); lineno++;
  fprintf(out,"#define YY_NO_ACTION         %d\n", i+2); lineno++;
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Now output the action table and its associates:
  **
  **  yy_action[]        A single table containing all actions.
  **  yy_lookahead[]     A table containing the lookahead for each entry in
  **                     yy_action.  Used to detect hash collisions.
  **  yy_shift_ofst[]    For each state, the offset into yy_action for
  **                     shifting terminals.
  **  yy_reduce_ofst[]   For each state, the offset into yy_action for
  **                     shifting non-terminals after a reduce.
  **  yy_default[]       Default action for each state.
  */

  /* Output the yy_action table */
  lemp->nactiontab = n = acttab_size(pActtab);
  lemp->tablesize += n*szActionType;
  fprintf(out,"#define YY_ACTTAB_COUNT (%d)\n", n); lineno++;
  fprintf(out,"static const YYACTIONTYPE yy_action[] = {\n"); lineno++;
  for(i=j=0; i<n; i++){
    int action = acttab_yyaction(pActtab, i);
    if( action<0 ) action = lemp->nstate + lemp->nrule + 2;
    if( j==0 ) fprintf(out," /* %5d */ ", i);
    fprintf(out, " %4d,", action);
    if( j==9 || i==n-1 ){
      fprintf(out, "\n"); lineno++;
      j = 0;
    }else{
      j++;
    }
  }
  fprintf(out, "};\n"); lineno++;

  /* Output the yy_lookahead table */
  lemp->tablesize += n*szCodeType;
  fprintf(out,"static const YYCODETYPE yy_lookahead[] = {\n"); lineno++;
  for(i=j=0; i<n; i++){
    int la = acttab_yylookahead(pActtab, i);
    if( la<0 ) la = lemp->nsymbol;
    if( j==0 ) fprintf(out," /* %5d */ ", i);
    fprintf(out, " %4d,", la);
    if( j==9 || i==n-1 ){
      fprintf(out, "\n"); lineno++;
      j = 0;
    }else{
      j++;
    }
  }
  fprintf(out, "};\n"); lineno++;

  /* Output the yy_shift_ofst[] table */
  fprintf(out, "#define YY_SHIFT_USE_DFLT (%d)\n", mnTknOfst-1); lineno++;
  n = lemp->nxstate;
  while( n>0 && lemp->sorted[n-1]->iTknOfst==NO_OFFSET ) n--;
  fprintf(out, "#define YY_SHIFT_COUNT (%d)\n", n-1); lineno++;
  fprintf(out, "#define YY_SHIFT_MIN   (%d)\n", mnTknOfst); lineno++;
  fprintf(out, "#define YY_SHIFT_MAX   (%d)\n", mxTknOfst); lineno++;
  fprintf(out, "static const %s yy_shift_ofst[] = {\n",
          minimum_size_type(mnTknOfst-1, mxTknOfst, &sz)); lineno++;
  lemp->tablesize += n*sz;
  for(i=j=0; i<n; i++){
    int ofst;
    stp = lemp->sorted[i];
    ofst = stp->iTknOfst;
    if( ofst==NO_OFFSET ) ofst = mnTknOfst - 1;
    if( j==0 ) fprintf(out," /* %5d */ ", i);
    fprintf(out, " %4d,", ofst);
    if( j==9 || i==n-1 ){
      fprintf(out, "\n"); lineno++;
      j = 0;
    }else{
      j++;
    }
  }
  fprintf(out, "};\n"); lineno++;

  /* Output the yy_reduce_ofst[] table */
  fprintf(out, "#define YY_REDUCE_USE_DFLT (%d)\n", mnNtOfst-1); lineno++;
  n = lemp->nxstate;
  while( n>0 && lemp->sorted[n-1]->iNtOfst==NO_OFFSET ) n--;
  fprintf(out, "#define YY_REDUCE_COUNT (%d)\n", n-1); lineno++;
  fprintf(out, "#define YY_REDUCE_MIN   (%d)\n", mnNtOfst); lineno++;
  fprintf(out, "#define YY_REDUCE_MAX   (%d)\n", mxNtOfst); lineno++;
  fprintf(out, "static const %s yy_reduce_ofst[] = {\n",
          minimum_size_type(mnNtOfst-1, mxNtOfst, &sz)); lineno++;
  lemp->tablesize += n*sz;
  for(i=j=0; i<n; i++){
    int ofst;
    stp = lemp->sorted[i];
    ofst = stp->iNtOfst;
    if( ofst==NO_OFFSET ) ofst = mnNtOfst - 1;
    if( j==0 ) fprintf(out," /* %5d */ ", i);
    fprintf(out, " %4d,", ofst);
    if( j==9 || i==n-1 ){
      fprintf(out, "\n"); lineno++;
      j = 0;
    }else{
      j++;
    }
  }
  fprintf(out, "};\n"); lineno++;

  /* Output the default action table */
  fprintf(out, "static const YYACTIONTYPE yy_default[] = {\n"); lineno++;
  n = lemp->nxstate;
  lemp->tablesize += n*szActionType;
  for(i=j=0; i<n; i++){
    stp = lemp->sorted[i];
    if( j==0 ) fprintf(out," /* %5d */ ", i);
    fprintf(out, " %4d,", stp->iDfltReduce+lemp->nstate+lemp->nrule);
    if( j==9 || i==n-1 ){
      fprintf(out, "\n"); lineno++;
      j = 0;
    }else{
      j++;
    }
  }
  fprintf(out, "};\n"); lineno++;
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate the table of fallback tokens.
  */
  if( lemp->has_fallback ){
    int mx = lemp->nterminal - 1;
    while( mx>0 && lemp->symbols[mx]->fallback==0 ){ mx--; }
    lemp->tablesize += (mx+1)*szCodeType;
    for(i=0; i<=mx; i++){
      struct symbol *p = lemp->symbols[i];
      if( p->fallback==0 ){
        fprintf(out, "    0,  /* %10s => nothing */\n", p->name);
      }else{
        fprintf(out, "  %3d,  /* %10s => %s */\n", p->fallback->index,
          p->name, p->fallback->name);
      }
      lineno++;
    }
  }
  tplt_xfer(lemp->name, in, out, &lineno);

  /* Generate a table containing the symbolic name of every symbol
  */
  for(i=0; i<lemp->nsymbol; i++){
    lemon_sprintf(line,"\"%s\",",lemp->symbols[i]->name);
    fprintf(out,"  %-15s",line);
    if( (i&3)==3 ){ fprintf(out,"\n"); lineno++; }
  }
  if( (i&3)!=0 ){ fprintf(out,"\n"); lineno++; }
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate a table containing a text string that describes every
  ** rule in the rule set of the grammar.  This information is used
  ** when tracing REDUCE actions.
  */
  for(i=0, rp=lemp->rule; rp; rp=rp->next, i++){
    assert( rp->index==i );
    fprintf(out," /* %3d */ \"", i);
    writeRuleText(out, rp);
    fprintf(out,"\",\n"); lineno++;
  }
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes every time a symbol is popped from
  ** the stack while processing errors or while destroying the parser.
  ** (In other words, generate the %destructor actions)
  */
#ifdef LEMONEX
  if(( lemp->tokendest != 0) || (lemp->tokentype == 0))
#else
  if( lemp->tokendest )
#endif
 {
    int once = 1;
    for(i=0; i<lemp->nsymbol; i++){
      struct symbol *sp = lemp->symbols[i];
      if( sp==0 || sp->type!=TERMINAL ) continue;
      if( once ){
        fprintf(out, "      /* TERMINAL Destructor */\n"); lineno++;
        once = 0;
      }
      fprintf(out,"    case %d: /* %s */\n", sp->index, sp->name); lineno++;
    }
    for(i=0; i<lemp->nsymbol && lemp->symbols[i]->type!=TERMINAL; i++);
    if( i<lemp->nsymbol ){
      emit_destructor_code(out,lemp->symbols[i],lemp,&lineno);
      fprintf(out,"      break;\n"); lineno++;
    }
  }
  if( lemp->vardest ){
    struct symbol *dflt_sp = 0;
    int once = 1;
    for(i=0; i<lemp->nsymbol; i++){
      struct symbol *sp = lemp->symbols[i];
      if( sp==0 || sp->type==TERMINAL ||
          sp->index<=0 || sp->destructor!=0 ) continue;
      if( once ){
        fprintf(out, "      /* Default NON-TERMINAL Destructor */\n"); lineno++;
        once = 0;
      }
      fprintf(out,"    case %d: /* %s */\n", sp->index, sp->name); lineno++;
      dflt_sp = sp;
    }
    if( dflt_sp!=0 ){
      emit_destructor_code(out,dflt_sp,lemp,&lineno);
    }
    fprintf(out,"      break;\n"); lineno++;
  }
  for(i=0; i<lemp->nsymbol; i++){
    struct symbol *sp = lemp->symbols[i];
    if( sp==0 || sp->type==TERMINAL || sp->destructor==0 ) continue;
    fprintf(out,"    case %d: /* %s */\n", sp->index, sp->name); lineno++;

    /* Combine duplicate destructors into a single case */
    for(j=i+1; j<lemp->nsymbol; j++){
      struct symbol *sp2 = lemp->symbols[j];
      if( sp2 && sp2->type!=TERMINAL && sp2->destructor
          && sp2->dtnum==sp->dtnum
          && strcmp(sp->destructor,sp2->destructor)==0 ){
         fprintf(out,"    case %d: /* %s */\n",
                 sp2->index, sp2->name); lineno++;
         sp2->destructor = 0;
      }
    }

    emit_destructor_code(out,lemp->symbols[i],lemp,&lineno);
    fprintf(out,"      break;\n"); lineno++;
  }
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes whenever the parser stack overflows */
  tplt_print(out,lemp,lemp->overflow,&lineno);
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate the table of rule information
  **
  ** Note: This code depends on the fact that rules are number
  ** sequentually beginning with 0.
  */
  for(rp=lemp->rule; rp; rp=rp->next){
    fprintf(out,"  { %d, %d },\n",rp->lhs->index,rp->nrhs); lineno++;
  }
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which execution during each REDUCE action */
  for(rp=lemp->rule; rp; rp=rp->next){
    translate_code(lemp, rp);
  }
  /* First output rules other than the default: rule */
  for(rp=lemp->rule; rp; rp=rp->next){
    struct rule *rp2;               /* Other rules with the same action */
    if( rp->code==0 ) continue;
    if( rp->code[0]=='\n' && rp->code[1]==0 ) continue; /* Will be default: */
    fprintf(out,"      case %d: /* ", rp->index);
    writeRuleText(out, rp);
    fprintf(out, " */\n"); lineno++;
    for(rp2=rp->next; rp2; rp2=rp2->next){
      if( rp2->code==rp->code ){
        fprintf(out,"      case %d: /* ", rp2->index);
        writeRuleText(out, rp2);
        fprintf(out," */ yytestcase(yyruleno==%d);\n", rp2->index); lineno++;
        rp2->code = 0;
      }
    }
    emit_code(out,rp,lemp,&lineno);
    fprintf(out,"        break;\n"); lineno++;
    rp->code = 0;
  }
  /* Finally, output the default: rule.  We choose as the default: all
  ** empty actions. */
  fprintf(out,"      default:\n"); lineno++;
  for(rp=lemp->rule; rp; rp=rp->next){
    if( rp->code==0 ) continue;
    assert( rp->code[0]=='\n' && rp->code[1]==0 );
    fprintf(out,"      /* (%d) ", rp->index);
    writeRuleText(out, rp);
    fprintf(out, " */ yytestcase(yyruleno==%d);\n", rp->index); lineno++;
  }
  fprintf(out,"        break;\n"); lineno++;
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes if a parse fails */
  tplt_print(out,lemp,lemp->failure,&lineno);
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes when a syntax error occurs */
  tplt_print(out,lemp,lemp->error,&lineno);
  tplt_xfer(lemp->name,in,out,&lineno);

  /* Generate code which executes when the parser accepts its input */
  tplt_print(out,lemp,lemp->accept,&lineno);
  tplt_xfer(lemp->name,in,out,&lineno);

#ifdef LEMONEX
  /* Append any addition code the user desires */
  tplt_print(out,lemp,lemp->lexercode,&lineno);
  tplt_xfer(lemp->name,in,out,&lineno);
  for(struct LxState* curr_state = lemp->headstate; curr_state != 0; curr_state = curr_state->next_state){
    if(curr_state->code != 0){
      fprintf(out, "static void lx_state_action_%d(lxLexer *lxpLexer){", curr_state->state_id);
      emit_lexer_actioncode(out, curr_state->code, lemp, &lineno);
      fprintf(out, "}\n");lineno++;
    }
  }

  tplt_xfer(lemp->name,in,out,&lineno);
  lx_generate_output(lemp, out, &lineno);
  tplt_xfer(lemp->name,in,out,&lineno);
#endif

  /* Append any addition code the user desires */
  tplt_print(out,lemp,lemp->extracode,&lineno);

  fclose(in);
  fclose(out);
  return;
}

/* Generate a header file for the parser */
void ReportHeader(struct lemon *lemp)
{
  FILE *out, *in;
  const char *prefix;
  char line[LINESIZE];
  char pattern[LINESIZE];
  int i;

  if( lemp->tokenprefix ) prefix = lemp->tokenprefix;
  else                    prefix = "";
  in = file_open(lemp,".h","rb");
  if( in ){
    int nextChar;
    for(i=1; i<lemp->nterminal && fgets(line,LINESIZE,in); i++){
      lemon_sprintf(pattern,"#define %s%-30s %3d\n",
                    prefix,lemp->symbols[i]->name,i);
      if( strcmp(line,pattern) ) break;
    }
    nextChar = fgetc(in);
    fclose(in);
    if( i==lemp->nterminal && nextChar==EOF ){
      /* No change in the file.  Don't rewrite it. */
      return;
    }
  }
  out = file_open(lemp,".h","wb");
  if( out ){
    for(i=1; i<lemp->nterminal; i++){
      fprintf(out,"#define %s%-30s %3d\n",prefix,lemp->symbols[i]->name,i);
    }
    fclose(out);
  }
  return;
}

/* Reduce the size of the action tables, if possible, by making use
** of defaults.
**
** In this version, we take the most frequent REDUCE action and make
** it the default.  Except, there is no default if the wildcard token
** is a possible look-ahead.
*/
void CompressTables(struct lemon *lemp)
{
  struct state *stp;
  struct action *ap, *ap2;
  struct rule *rp, *rp2, *rbest;
  int nbest, n;
  int i;
  int usesWildcard;

  for(i=0; i<lemp->nstate; i++){
    stp = lemp->sorted[i];
    nbest = 0;
    rbest = 0;
    usesWildcard = 0;

    for(ap=stp->ap; ap; ap=ap->next){
      if( ap->type==SHIFT && ap->sp==lemp->wildcard ){
        usesWildcard = 1;
      }
      if( ap->type!=REDUCE ) continue;
      rp = ap->x.rp;
      if( rp->lhsStart ) continue;
      if( rp==rbest ) continue;
      n = 1;
      for(ap2=ap->next; ap2; ap2=ap2->next){
        if( ap2->type!=REDUCE ) continue;
        rp2 = ap2->x.rp;
        if( rp2==rbest ) continue;
        if( rp2==rp ) n++;
      }
      if( n>nbest ){
        nbest = n;
        rbest = rp;
      }
    }

    /* Do not make a default if the number of rules to default
    ** is not at least 1 or if the wildcard token is a possible
    ** lookahead.
    */
    if( nbest<1 || usesWildcard ) continue;


    /* Combine matching REDUCE actions into a single default */
    for(ap=stp->ap; ap; ap=ap->next){
      if( ap->type==REDUCE && ap->x.rp==rbest ) break;
    }
    assert( ap );
    ap->sp = Symbol_new("{default}");
    for(ap=ap->next; ap; ap=ap->next){
      if( ap->type==REDUCE && ap->x.rp==rbest ) ap->type = NOT_USED;
    }
    stp->ap = Action_sort(stp->ap);

    for(ap=stp->ap; ap; ap=ap->next){
      if( ap->type==SHIFT ) break;
      if( ap->type==REDUCE && ap->x.rp!=rbest ) break;
    }
    if( ap==0 ){
      stp->autoReduce = 1;
      stp->pDfltReduce = rbest;
    }
  }

  /* Make a second pass over all states and actions.  Convert
  ** every action that is a SHIFT to an autoReduce state into
  ** a SHIFTREDUCE action.
  */
  for(i=0; i<lemp->nstate; i++){
    stp = lemp->sorted[i];
    for(ap=stp->ap; ap; ap=ap->next){
      struct state *pNextState;
      if( ap->type!=SHIFT ) continue;
      pNextState = ap->x.stp;
      if( pNextState->autoReduce && pNextState->pDfltReduce!=0 ){
        ap->type = SHIFTREDUCE;
        ap->x.rp = pNextState->pDfltReduce;
      }
    }
  }
}


/*
** Compare two states for sorting purposes.  The smaller state is the
** one with the most non-terminal actions.  If they have the same number
** of non-terminal actions, then the smaller is the one with the most
** token actions.
*/
static int stateResortCompare(const void *a, const void *b){
  const struct state *pA = *(const struct state**)a;
  const struct state *pB = *(const struct state**)b;
  int n;

  n = pB->nNtAct - pA->nNtAct;
  if( n==0 ){
    n = pB->nTknAct - pA->nTknAct;
    if( n==0 ){
      n = pB->statenum - pA->statenum;
    }
  }
  assert( n!=0 );
  return n;
}


/*
** Renumber and resort states so that states with fewer choices
** occur at the end.  Except, keep state 0 as the first state.
*/
void ResortStates(struct lemon *lemp)
{
  int i;
  struct state *stp;
  struct action *ap;

  for(i=0; i<lemp->nstate; i++){
    stp = lemp->sorted[i];
    stp->nTknAct = stp->nNtAct = 0;
    stp->iDfltReduce = lemp->nrule;  /* Init dflt action to "syntax error" */
    stp->iTknOfst = NO_OFFSET;
    stp->iNtOfst = NO_OFFSET;
    for(ap=stp->ap; ap; ap=ap->next){
      int iAction = compute_action(lemp,ap);
      if( iAction>=0 ){
        if( ap->sp->index<lemp->nterminal ){
          stp->nTknAct++;
        }else if( ap->sp->index<lemp->nsymbol ){
          stp->nNtAct++;
        }else{
          assert( stp->autoReduce==0 || stp->pDfltReduce==ap->x.rp );
          stp->iDfltReduce = iAction - lemp->nstate - lemp->nrule;
        }
      }
    }
  }
  qsort(&lemp->sorted[1], lemp->nstate-1, sizeof(lemp->sorted[0]),
        stateResortCompare);
  for(i=0; i<lemp->nstate; i++){
    lemp->sorted[i]->statenum = i;
  }
  lemp->nxstate = lemp->nstate;
  while( lemp->nxstate>1 && lemp->sorted[lemp->nxstate-1]->autoReduce ){
    lemp->nxstate--;
  }
}


/***************** From the file "set.c" ************************************/
/*
** Set manipulation routines for the LEMON parser generator.
*/

static int size = 0;

/* Set the set size */
void SetSize(int n)
{
  size = n+1;
}

/* Allocate a new set */
char *SetNew(){
  char *s;
  s = (char*)calloc( size, 1);
  if( s==0 ){
    extern void memory_error();
    memory_error();
  }
  return s;
}

/* Deallocate a set */
void SetFree(char *s)
{
  free(s);
}

/* Add a new element to the set.  Return TRUE if the element was added
** and FALSE if it was already there. */
int SetAdd(char *s, int e)
{
  int rv;
  assert( e>=0 && e<size );
  rv = s[e];
  s[e] = 1;
  return !rv;
}

/* Add every element of s2 to s1.  Return TRUE if s1 changes. */
int SetUnion(char *s1, char *s2)
{
  int i, progress;
  progress = 0;
  for(i=0; i<size; i++){
    if( s2[i]==0 ) continue;
    if( s1[i]==0 ){
      progress = 1;
      s1[i] = 1;
    }
  }
  return progress;
}
/********************** From the file "table.c" ****************************/
/*
** All code in this file has been automatically generated
** from a specification in the file
**              "table.q"
** by the associative array code building program "aagen".
** Do not edit this file!  Instead, edit the specification
** file, then rerun aagen.
*/
/*
** Code for processing tables in the LEMON parser generator.
*/

PRIVATE unsigned strhash(const char *x)
{
  unsigned h = 0;
  while( *x ) h = h*13 + *(x++);
  return h;
}

/* Works like strdup, sort of.  Save a string in malloced memory, but
** keep strings in a table so that the same string is not in more
** than one place.
*/
const char *Strsafe(const char *y)
{
  const char *z;
  char *cpy;

  if( y==0 ) return 0;
  z = Strsafe_find(y);
  if( z==0 && (cpy=(char *)malloc( lemonStrlen(y)+1 ))!=0 ){
    lemon_strcpy(cpy,y);
    z = cpy;
    Strsafe_insert(z);
  }
  MemoryCheck(z);
  return z;
}

/* There is one instance of the following structure for each
** associative array of type "x1".
*/
struct s_x1 {
  int size;               /* The number of available slots. */
                          /*   Must be a power of 2 greater than or */
                          /*   equal to 1 */
  int count;              /* Number of currently slots filled */
  struct s_x1node *tbl;  /* The data stored here */
  struct s_x1node **ht;  /* Hash table for lookups */
};

/* There is one instance of this structure for every data element
** in an associative array of type "x1".
*/
typedef struct s_x1node {
  const char *data;        /* The data */
  struct s_x1node *next;   /* Next entry with the same hash */
  struct s_x1node **from;  /* Previous link */
} x1node;

/* There is only one instance of the array, which is the following */
static struct s_x1 *x1a;

/* Allocate a new associative array */
void Strsafe_init(){
  if( x1a ) return;
  x1a = (struct s_x1*)malloc( sizeof(struct s_x1) );
  if( x1a ){
    x1a->size = 1024;
    x1a->count = 0;
    x1a->tbl = (x1node*)calloc(1024, sizeof(x1node) + sizeof(x1node*));
    if( x1a->tbl==0 ){
      free(x1a);
      x1a = 0;
    }else{
      int i;
      x1a->ht = (x1node**)&(x1a->tbl[1024]);
      for(i=0; i<1024; i++) x1a->ht[i] = 0;
    }
  }
}
/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */
int Strsafe_insert(const char *data)
{
  x1node *np;
  unsigned h;
  unsigned ph;

  if( x1a==0 ) return 0;
  ph = strhash(data);
  h = ph & (x1a->size-1);
  np = x1a->ht[h];
  while( np ){
    if( strcmp(np->data,data)==0 ){
      /* An existing entry with the same key is found. */
      /* Fail because overwrite is not allows. */
      return 0;
    }
    np = np->next;
  }
  if( x1a->count>=x1a->size ){
    /* Need to make the hash table bigger */
    int i,arrSize;
    struct s_x1 array;
    array.size = arrSize = x1a->size*2;
    array.count = x1a->count;
    array.tbl = (x1node*)calloc(arrSize, sizeof(x1node) + sizeof(x1node*));
    if( array.tbl==0 ) return 0;  /* Fail due to malloc failure */
    array.ht = (x1node**)&(array.tbl[arrSize]);
    for(i=0; i<arrSize; i++) array.ht[i] = 0;
    for(i=0; i<x1a->count; i++){
      x1node *oldnp, *newnp;
      oldnp = &(x1a->tbl[i]);
      h = strhash(oldnp->data) & (arrSize-1);
      newnp = &(array.tbl[i]);
      if( array.ht[h] ) array.ht[h]->from = &(newnp->next);
      newnp->next = array.ht[h];
      newnp->data = oldnp->data;
      newnp->from = &(array.ht[h]);
      array.ht[h] = newnp;
    }
    free(x1a->tbl);
    *x1a = array;
  }
  /* Insert the new data */
  h = ph & (x1a->size-1);
  np = &(x1a->tbl[x1a->count++]);
  np->data = data;
  if( x1a->ht[h] ) x1a->ht[h]->from = &(np->next);
  np->next = x1a->ht[h];
  x1a->ht[h] = np;
  np->from = &(x1a->ht[h]);
  return 1;
}

/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */
const char *Strsafe_find(const char *key)
{
  unsigned h;
  x1node *np;

  if( x1a==0 ) return 0;
  h = strhash(key) & (x1a->size-1);
  np = x1a->ht[h];
  while( np ){
    if( strcmp(np->data,key)==0 ) break;
    np = np->next;
  }
  return np ? np->data : 0;
}

/* Return a pointer to the (terminal or nonterminal) symbol "x".
** Create a new symbol if this is the first time "x" has been seen.
*/
struct symbol *Symbol_new(const char *x)
{
  struct symbol *sp;

  sp = Symbol_find(x);
  if( sp==0 ){
    sp = (struct symbol *)calloc(1, sizeof(struct symbol) );
    MemoryCheck(sp);
    sp->name = Strsafe(x);
    sp->type = isupper(*x) ? TERMINAL : NONTERMINAL;
    sp->rule = 0;
    sp->fallback = 0;
    sp->prec = -1;
    sp->assoc = UNK;
    sp->firstset = 0;
    sp->lambda = LEMON_FALSE;
    sp->destructor = 0;
    sp->destLineno = 0;
    sp->datatype = 0;
    sp->useCnt = 0;
#ifdef LEMONEX
    sp->defined = 0;
#endif
    Symbol_insert(sp,sp->name);
  }
  sp->useCnt++;
  return sp;
}

/* Compare two symbols for sorting purposes.  Return negative,
** zero, or positive if a is less then, equal to, or greater
** than b.
**
** Symbols that begin with upper case letters (terminals or tokens)
** must sort before symbols that begin with lower case letters
** (non-terminals).  And MULTITERMINAL symbols (created using the
** %token_class directive) must sort at the very end. Other than
** that, the order does not matter.
**
** We find experimentally that leaving the symbols in their original
** order (the order they appeared in the grammar file) gives the
** smallest parser tables in SQLite.
*/
int Symbolcmpp(const void *_a, const void *_b)
{
  const struct symbol *a = *(const struct symbol **) _a;
  const struct symbol *b = *(const struct symbol **) _b;
  int i1 = a->type==MULTITERMINAL ? 3 : a->name[0]>'Z' ? 2 : 1;
  int i2 = b->type==MULTITERMINAL ? 3 : b->name[0]>'Z' ? 2 : 1;
  return i1==i2 ? a->index - b->index : i1 - i2;
}

/* There is one instance of the following structure for each
** associative array of type "x2".
*/
struct s_x2 {
  int size;               /* The number of available slots. */
                          /*   Must be a power of 2 greater than or */
                          /*   equal to 1 */
  int count;              /* Number of currently slots filled */
  struct s_x2node *tbl;  /* The data stored here */
  struct s_x2node **ht;  /* Hash table for lookups */
};

/* There is one instance of this structure for every data element
** in an associative array of type "x2".
*/
typedef struct s_x2node {
  struct symbol *data;     /* The data */
  const char *key;         /* The key */
  struct s_x2node *next;   /* Next entry with the same hash */
  struct s_x2node **from;  /* Previous link */
} x2node;

/* There is only one instance of the array, which is the following */
static struct s_x2 *x2a;

/* Allocate a new associative array */
void Symbol_init(){
  if( x2a ) return;
  x2a = (struct s_x2*)malloc( sizeof(struct s_x2) );
  if( x2a ){
    x2a->size = 128;
    x2a->count = 0;
    x2a->tbl = (x2node*)calloc(128, sizeof(x2node) + sizeof(x2node*));
    if( x2a->tbl==0 ){
      free(x2a);
      x2a = 0;
    }else{
      int i;
      x2a->ht = (x2node**)&(x2a->tbl[128]);
      for(i=0; i<128; i++) x2a->ht[i] = 0;
    }
  }
}
/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */
int Symbol_insert(struct symbol *data, const char *key)
{
  x2node *np;
  unsigned h;
  unsigned ph;

  if( x2a==0 ) return 0;
  ph = strhash(key);
  h = ph & (x2a->size-1);
  np = x2a->ht[h];
  while( np ){
    if( strcmp(np->key,key)==0 ){
      /* An existing entry with the same key is found. */
      /* Fail because overwrite is not allows. */
      return 0;
    }
    np = np->next;
  }
  if( x2a->count>=x2a->size ){
    /* Need to make the hash table bigger */
    int i,arrSize;
    struct s_x2 array;
    array.size = arrSize = x2a->size*2;
    array.count = x2a->count;
    array.tbl = (x2node*)calloc(arrSize, sizeof(x2node) + sizeof(x2node*));
    if( array.tbl==0 ) return 0;  /* Fail due to malloc failure */
    array.ht = (x2node**)&(array.tbl[arrSize]);
    for(i=0; i<arrSize; i++) array.ht[i] = 0;
    for(i=0; i<x2a->count; i++){
      x2node *oldnp, *newnp;
      oldnp = &(x2a->tbl[i]);
      h = strhash(oldnp->key) & (arrSize-1);
      newnp = &(array.tbl[i]);
      if( array.ht[h] ) array.ht[h]->from = &(newnp->next);
      newnp->next = array.ht[h];
      newnp->key = oldnp->key;
      newnp->data = oldnp->data;
      newnp->from = &(array.ht[h]);
      array.ht[h] = newnp;
    }
    free(x2a->tbl);
    *x2a = array;
  }
  /* Insert the new data */
  h = ph & (x2a->size-1);
  np = &(x2a->tbl[x2a->count++]);
  np->key = key;
  np->data = data;
  if( x2a->ht[h] ) x2a->ht[h]->from = &(np->next);
  np->next = x2a->ht[h];
  x2a->ht[h] = np;
  np->from = &(x2a->ht[h]);
  return 1;
}

/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */
struct symbol *Symbol_find(const char *key)
{
  unsigned h;
  x2node *np;

  if( x2a==0 ) return 0;
  h = strhash(key) & (x2a->size-1);
  np = x2a->ht[h];
  while( np ){
    if( strcmp(np->key,key)==0 ) break;
    np = np->next;
  }
  return np ? np->data : 0;
}

/* Return the n-th data.  Return NULL if n is out of range. */
struct symbol *Symbol_Nth(int n)
{
  struct symbol *data;
  if( x2a && n>0 && n<=x2a->count ){
    data = x2a->tbl[n-1].data;
  }else{
    data = 0;
  }
  return data;
}

/* Return the size of the array */
int Symbol_count()
{
  return x2a ? x2a->count : 0;
}

/* Return an array of pointers to all data in the table.
** The array is obtained from malloc.  Return NULL if memory allocation
** problems, or if the array is empty. */
struct symbol **Symbol_arrayof()
{
  struct symbol **array;
  int i,arrSize;
  if( x2a==0 ) return 0;
  arrSize = x2a->count;
  array = (struct symbol **)calloc(arrSize, sizeof(struct symbol *));
  if( array ){
    for(i=0; i<arrSize; i++) array[i] = x2a->tbl[i].data;
  }
  return array;
}

/* Compare two configurations */
int Configcmp(const char *_a,const char *_b)
{
  const struct config *a = (struct config *) _a;
  const struct config *b = (struct config *) _b;
  int x;
  x = a->rp->index - b->rp->index;
  if( x==0 ) x = a->dot - b->dot;
  return x;
}

/* Compare two states */
PRIVATE int statecmp(struct config *a, struct config *b)
{
  int rc;
  for(rc=0; rc==0 && a && b;  a=a->bp, b=b->bp){
    rc = a->rp->index - b->rp->index;
    if( rc==0 ) rc = a->dot - b->dot;
  }
  if( rc==0 ){
    if( a ) rc = 1;
    if( b ) rc = -1;
  }
  return rc;
}

/* Hash a state */
PRIVATE unsigned statehash(struct config *a)
{
  unsigned h=0;
  while( a ){
    h = h*571 + a->rp->index*37 + a->dot;
    a = a->bp;
  }
  return h;
}

/* Allocate a new state structure */
struct state *State_new()
{
  struct state *newstate;
  newstate = (struct state *)calloc(1, sizeof(struct state) );
  MemoryCheck(newstate);
  return newstate;
}

/* There is one instance of the following structure for each
** associative array of type "x3".
*/
struct s_x3 {
  int size;               /* The number of available slots. */
                          /*   Must be a power of 2 greater than or */
                          /*   equal to 1 */
  int count;              /* Number of currently slots filled */
  struct s_x3node *tbl;  /* The data stored here */
  struct s_x3node **ht;  /* Hash table for lookups */
};

/* There is one instance of this structure for every data element
** in an associative array of type "x3".
*/
typedef struct s_x3node {
  struct state *data;                  /* The data */
  struct config *key;                   /* The key */
  struct s_x3node *next;   /* Next entry with the same hash */
  struct s_x3node **from;  /* Previous link */
} x3node;

/* There is only one instance of the array, which is the following */
static struct s_x3 *x3a;

/* Allocate a new associative array */
void State_init(){
  if( x3a ) return;
  x3a = (struct s_x3*)malloc( sizeof(struct s_x3) );
  if( x3a ){
    x3a->size = 128;
    x3a->count = 0;
    x3a->tbl = (x3node*)calloc(128, sizeof(x3node) + sizeof(x3node*));
    if( x3a->tbl==0 ){
      free(x3a);
      x3a = 0;
    }else{
      int i;
      x3a->ht = (x3node**)&(x3a->tbl[128]);
      for(i=0; i<128; i++) x3a->ht[i] = 0;
    }
  }
}
/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */
int State_insert(struct state *data, struct config *key)
{
  x3node *np;
  unsigned h;
  unsigned ph;

  if( x3a==0 ) return 0;
  ph = statehash(key);
  h = ph & (x3a->size-1);
  np = x3a->ht[h];
  while( np ){
    if( statecmp(np->key,key)==0 ){
      /* An existing entry with the same key is found. */
      /* Fail because overwrite is not allows. */
      return 0;
    }
    np = np->next;
  }
  if( x3a->count>=x3a->size ){
    /* Need to make the hash table bigger */
    int i,arrSize;
    struct s_x3 array;
    array.size = arrSize = x3a->size*2;
    array.count = x3a->count;
    array.tbl = (x3node*)calloc(arrSize, sizeof(x3node) + sizeof(x3node*));
    if( array.tbl==0 ) return 0;  /* Fail due to malloc failure */
    array.ht = (x3node**)&(array.tbl[arrSize]);
    for(i=0; i<arrSize; i++) array.ht[i] = 0;
    for(i=0; i<x3a->count; i++){
      x3node *oldnp, *newnp;
      oldnp = &(x3a->tbl[i]);
      h = statehash(oldnp->key) & (arrSize-1);
      newnp = &(array.tbl[i]);
      if( array.ht[h] ) array.ht[h]->from = &(newnp->next);
      newnp->next = array.ht[h];
      newnp->key = oldnp->key;
      newnp->data = oldnp->data;
      newnp->from = &(array.ht[h]);
      array.ht[h] = newnp;
    }
    free(x3a->tbl);
    *x3a = array;
  }
  /* Insert the new data */
  h = ph & (x3a->size-1);
  np = &(x3a->tbl[x3a->count++]);
  np->key = key;
  np->data = data;
  if( x3a->ht[h] ) x3a->ht[h]->from = &(np->next);
  np->next = x3a->ht[h];
  x3a->ht[h] = np;
  np->from = &(x3a->ht[h]);
  return 1;
}

/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */
struct state *State_find(struct config *key)
{
  unsigned h;
  x3node *np;

  if( x3a==0 ) return 0;
  h = statehash(key) & (x3a->size-1);
  np = x3a->ht[h];
  while( np ){
    if( statecmp(np->key,key)==0 ) break;
    np = np->next;
  }
  return np ? np->data : 0;
}

/* Return an array of pointers to all data in the table.
** The array is obtained from malloc.  Return NULL if memory allocation
** problems, or if the array is empty. */
struct state **State_arrayof()
{
  struct state **array;
  int i,arrSize;
  if( x3a==0 ) return 0;
  arrSize = x3a->count;
  array = (struct state **)calloc(arrSize, sizeof(struct state *));
  if( array ){
    for(i=0; i<arrSize; i++) array[i] = x3a->tbl[i].data;
  }
  return array;
}

/* Hash a configuration */
PRIVATE unsigned confighash(struct config *a)
{
  unsigned h=0;
  h = h*571 + a->rp->index*37 + a->dot;
  return h;
}

/* There is one instance of the following structure for each
** associative array of type "x4".
*/
struct s_x4 {
  int size;               /* The number of available slots. */
                          /*   Must be a power of 2 greater than or */
                          /*   equal to 1 */
  int count;              /* Number of currently slots filled */
  struct s_x4node *tbl;  /* The data stored here */
  struct s_x4node **ht;  /* Hash table for lookups */
};

/* There is one instance of this structure for every data element
** in an associative array of type "x4".
*/
typedef struct s_x4node {
  struct config *data;                  /* The data */
  struct s_x4node *next;   /* Next entry with the same hash */
  struct s_x4node **from;  /* Previous link */
} x4node;

/* There is only one instance of the array, which is the following */
static struct s_x4 *x4a;

/* Allocate a new associative array */
void Configtable_init(){
  if( x4a ) return;
  x4a = (struct s_x4*)malloc( sizeof(struct s_x4) );
  if( x4a ){
    x4a->size = 64;
    x4a->count = 0;
    x4a->tbl = (x4node*)calloc(64, sizeof(x4node) + sizeof(x4node*));
    if( x4a->tbl==0 ){
      free(x4a);
      x4a = 0;
    }else{
      int i;
      x4a->ht = (x4node**)&(x4a->tbl[64]);
      for(i=0; i<64; i++) x4a->ht[i] = 0;
    }
  }
}
/* Insert a new record into the array.  Return TRUE if successful.
** Prior data with the same key is NOT overwritten */
int Configtable_insert(struct config *data)
{
  x4node *np;
  unsigned h;
  unsigned ph;

  if( x4a==0 ) return 0;
  ph = confighash(data);
  h = ph & (x4a->size-1);
  np = x4a->ht[h];
  while( np ){
    if( Configcmp((const char *) np->data,(const char *) data)==0 ){
      /* An existing entry with the same key is found. */
      /* Fail because overwrite is not allows. */
      return 0;
    }
    np = np->next;
  }
  if( x4a->count>=x4a->size ){
    /* Need to make the hash table bigger */
    int i,arrSize;
    struct s_x4 array;
    array.size = arrSize = x4a->size*2;
    array.count = x4a->count;
    array.tbl = (x4node*)calloc(arrSize, sizeof(x4node) + sizeof(x4node*));
    if( array.tbl==0 ) return 0;  /* Fail due to malloc failure */
    array.ht = (x4node**)&(array.tbl[arrSize]);
    for(i=0; i<arrSize; i++) array.ht[i] = 0;
    for(i=0; i<x4a->count; i++){
      x4node *oldnp, *newnp;
      oldnp = &(x4a->tbl[i]);
      h = confighash(oldnp->data) & (arrSize-1);
      newnp = &(array.tbl[i]);
      if( array.ht[h] ) array.ht[h]->from = &(newnp->next);
      newnp->next = array.ht[h];
      newnp->data = oldnp->data;
      newnp->from = &(array.ht[h]);
      array.ht[h] = newnp;
    }
    free(x4a->tbl);
    *x4a = array;
  }
  /* Insert the new data */
  h = ph & (x4a->size-1);
  np = &(x4a->tbl[x4a->count++]);
  np->data = data;
  if( x4a->ht[h] ) x4a->ht[h]->from = &(np->next);
  np->next = x4a->ht[h];
  x4a->ht[h] = np;
  np->from = &(x4a->ht[h]);
  return 1;
}

/* Return a pointer to data assigned to the given key.  Return NULL
** if no such key. */
struct config *Configtable_find(struct config *key)
{
  int h;
  x4node *np;

  if( x4a==0 ) return 0;
  h = confighash(key) & (x4a->size-1);
  np = x4a->ht[h];
  while( np ){
    if( Configcmp((const char *) np->data,(const char *) key)==0 ) break;
    np = np->next;
  }
  return np ? np->data : 0;
}

/* Remove all data from the table.  Pass each data to the function "f"
** as it is removed.  ("f" may be null to avoid this step.) */
void Configtable_clear(int(*f)(struct config *))
{
  int i;
  if( x4a==0 || x4a->count==0 ) return;
  if( f ) for(i=0; i<x4a->count; i++) (*f)(x4a->tbl[i].data);
  for(i=0; i<x4a->size; i++) x4a->ht[i] = 0;
  x4a->count = 0;
  return;
}
